"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

/*
Copyright 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * The NodeAnimator contains components and animates transitions.
 * It will only pick up direct changes to properties ('left', currently), and so
 * will not work for animating positional changes where the position is implicit
 * from DOM order. This makes it a lot simpler and lighter: if you need fully
 * automatic positional animation, look at react-shuffle or similar libraries.
 */
class NodeAnimator extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "nodes", {});
    (0, _defineProperty2.default)(this, "children", void 0);
    this.updateChildren(this.props.children);
  }

  componentDidUpdate() {
    this.updateChildren(this.props.children);
  }
  /**
   *
   * @param {HTMLElement} node element to apply styles to
   * @param {React.CSSProperties} styles a key/value pair of CSS properties
   * @returns {void}
   */


  applyStyles(node, styles) {
    Object.entries(styles).forEach(_ref => {
      let [property, value] = _ref;
      node.style[property] = value;
    });
  }

  updateChildren(newChildren) {
    const oldChildren = this.children || {};
    this.children = {};

    _react.default.Children.toArray(newChildren).forEach(c => {
      if (oldChildren[c.key]) {
        const old = oldChildren[c.key];

        const oldNode = _reactDom.default.findDOMNode(this.nodes[old.key]);

        if (oldNode && oldNode.style.left !== c.props.style.left) {
          this.applyStyles(oldNode, {
            left: c.props.style.left
          }); // console.log("translation: "+oldNode.style.left+" -> "+c.props.style.left);
        } // clone the old element with the props (and children) of the new element
        // so prop updates are still received by the children.


        this.children[c.key] = /*#__PURE__*/_react.default.cloneElement(old, c.props, c.props.children);
      } else {
        // new element. If we have a startStyle, use that as the style and go through
        // the enter animations
        const newProps = {};
        const restingStyle = c.props.style;
        const startStyles = this.props.startStyles;

        if (startStyles.length > 0) {
          const startStyle = startStyles[0];
          newProps.style = startStyle; // console.log("mounted@startstyle0: "+JSON.stringify(startStyle));
        }

        newProps.ref = n => this.collectNode(c.key, n, restingStyle);

        this.children[c.key] = /*#__PURE__*/_react.default.cloneElement(c, newProps);
      }
    });
  }

  collectNode(k, node, restingStyle) {
    if (node && this.nodes[k] === undefined && this.props.startStyles.length > 0) {
      const startStyles = this.props.startStyles;

      const domNode = _reactDom.default.findDOMNode(node); // start from startStyle 1: 0 is the one we gave it
      // to start with, so now we animate 1 etc.


      for (let i = 1; i < startStyles.length; ++i) {
        this.applyStyles(domNode, startStyles[i]); // console.log("start:"
        //             JSON.stringify(startStyles[i]),
        //             );
      } // and then we animate to the resting state


      setTimeout(() => {
        this.applyStyles(domNode, restingStyle);
      }, 0); // console.log("enter:",
      //             JSON.stringify(restingStyle));
    }

    this.nodes[k] = node;
  }

  render() {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, Object.values(this.children));
  }

}

exports.default = NodeAnimator;
(0, _defineProperty2.default)(NodeAnimator, "defaultProps", {
  startStyles: []
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOb2RlQW5pbWF0b3IiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJ1cGRhdGVDaGlsZHJlbiIsImNoaWxkcmVuIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiYXBwbHlTdHlsZXMiLCJub2RlIiwic3R5bGVzIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJwcm9wZXJ0eSIsInZhbHVlIiwic3R5bGUiLCJuZXdDaGlsZHJlbiIsIm9sZENoaWxkcmVuIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiYyIsImtleSIsIm9sZCIsIm9sZE5vZGUiLCJSZWFjdERvbSIsImZpbmRET01Ob2RlIiwibm9kZXMiLCJsZWZ0IiwiY2xvbmVFbGVtZW50IiwibmV3UHJvcHMiLCJyZXN0aW5nU3R5bGUiLCJzdGFydFN0eWxlcyIsImxlbmd0aCIsInN0YXJ0U3R5bGUiLCJyZWYiLCJuIiwiY29sbGVjdE5vZGUiLCJrIiwidW5kZWZpbmVkIiwiZG9tTm9kZSIsImkiLCJzZXRUaW1lb3V0IiwicmVuZGVyIiwidmFsdWVzIl0sInNvdXJjZXMiOlsiLi4vc3JjL05vZGVBbmltYXRvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIyIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RG9tIGZyb20gXCJyZWFjdC1kb21cIjtcblxuaW50ZXJmYWNlIElDaGlsZFByb3BzIHtcbiAgICBzdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcztcbiAgICByZWY6IChub2RlOiBSZWFjdC5SZWFjdEluc3RhbmNlKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyBlaXRoZXIgYSBsaXN0IG9mIGNoaWxkIG5vZGVzLCBvciBhIHNpbmdsZSBjaGlsZC5cbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuXG4gICAgLy8gb3B0aW9uYWwgdHJhbnNpdGlvbiBpbmZvcm1hdGlvbiBmb3IgY2hhbmdpbmcgZXhpc3RpbmcgY2hpbGRyZW5cbiAgICB0cmFuc2l0aW9uPzogb2JqZWN0O1xuXG4gICAgLy8gYSBsaXN0IG9mIHN0YXRlIG9iamVjdHMgdG8gYXBwbHkgdG8gZWFjaCBjaGlsZCBub2RlIGluIHR1cm5cbiAgICBzdGFydFN0eWxlczogUmVhY3QuQ1NTUHJvcGVydGllc1tdO1xufVxuXG4vKipcbiAqIFRoZSBOb2RlQW5pbWF0b3IgY29udGFpbnMgY29tcG9uZW50cyBhbmQgYW5pbWF0ZXMgdHJhbnNpdGlvbnMuXG4gKiBJdCB3aWxsIG9ubHkgcGljayB1cCBkaXJlY3QgY2hhbmdlcyB0byBwcm9wZXJ0aWVzICgnbGVmdCcsIGN1cnJlbnRseSksIGFuZCBzb1xuICogd2lsbCBub3Qgd29yayBmb3IgYW5pbWF0aW5nIHBvc2l0aW9uYWwgY2hhbmdlcyB3aGVyZSB0aGUgcG9zaXRpb24gaXMgaW1wbGljaXRcbiAqIGZyb20gRE9NIG9yZGVyLiBUaGlzIG1ha2VzIGl0IGEgbG90IHNpbXBsZXIgYW5kIGxpZ2h0ZXI6IGlmIHlvdSBuZWVkIGZ1bGx5XG4gKiBhdXRvbWF0aWMgcG9zaXRpb25hbCBhbmltYXRpb24sIGxvb2sgYXQgcmVhY3Qtc2h1ZmZsZSBvciBzaW1pbGFyIGxpYnJhcmllcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZUFuaW1hdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcz4ge1xuICAgIHByaXZhdGUgbm9kZXMgPSB7fTtcbiAgICBwcml2YXRlIGNoaWxkcmVuOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0LkRldGFpbGVkUmVhY3RIVE1MRWxlbWVudDxhbnksIEhUTUxFbGVtZW50PiB9O1xuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPElQcm9wcz4gPSB7XG4gICAgICAgIHN0YXJ0U3R5bGVzOiBbXSxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBlbGVtZW50IHRvIGFwcGx5IHN0eWxlcyB0b1xuICAgICAqIEBwYXJhbSB7UmVhY3QuQ1NTUHJvcGVydGllc30gc3R5bGVzIGEga2V5L3ZhbHVlIHBhaXIgb2YgQ1NTIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGx5U3R5bGVzKG5vZGU6IEhUTUxFbGVtZW50LCBzdHlsZXM6IFJlYWN0LkNTU1Byb3BlcnRpZXMpOiB2b2lkIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDaGlsZHJlbihuZXdDaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZENoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KG5ld0NoaWxkcmVuKS5mb3JFYWNoKChjOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChvbGRDaGlsZHJlbltjLmtleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBvbGRDaGlsZHJlbltjLmtleV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkTm9kZSA9IFJlYWN0RG9tLmZpbmRET01Ob2RlKHRoaXMubm9kZXNbb2xkLmtleV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZE5vZGUgJiYgKG9sZE5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmxlZnQgIT09IGMucHJvcHMuc3R5bGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKG9sZE5vZGUgYXMgSFRNTEVsZW1lbnQsIHsgbGVmdDogYy5wcm9wcy5zdHlsZS5sZWZ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRyYW5zbGF0aW9uOiBcIitvbGROb2RlLnN0eWxlLmxlZnQrXCIgLT4gXCIrYy5wcm9wcy5zdHlsZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG9sZCBlbGVtZW50IHdpdGggdGhlIHByb3BzIChhbmQgY2hpbGRyZW4pIG9mIHRoZSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHNvIHByb3AgdXBkYXRlcyBhcmUgc3RpbGwgcmVjZWl2ZWQgYnkgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bYy5rZXldID0gUmVhY3QuY2xvbmVFbGVtZW50KG9sZCwgYy5wcm9wcywgYy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5ldyBlbGVtZW50LiBJZiB3ZSBoYXZlIGEgc3RhcnRTdHlsZSwgdXNlIHRoYXQgYXMgdGhlIHN0eWxlIGFuZCBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVudGVyIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9wczogUGFydGlhbDxJQ2hpbGRQcm9wcz4gPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0aW5nU3R5bGUgPSBjLnByb3BzLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTdHlsZXMgPSB0aGlzLnByb3BzLnN0YXJ0U3R5bGVzO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3R5bGUgPSBzdGFydFN0eWxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMuc3R5bGUgPSBzdGFydFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1vdW50ZWRAc3RhcnRzdHlsZTA6IFwiK0pTT04uc3RyaW5naWZ5KHN0YXJ0U3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdQcm9wcy5yZWYgPSAoKG4pID0+IHRoaXMuY29sbGVjdE5vZGUoXG4gICAgICAgICAgICAgICAgICAgIGMua2V5LCBuLCByZXN0aW5nU3R5bGUsXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2Mua2V5XSA9IFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29sbGVjdE5vZGUoazogc3RyaW5nLCBub2RlOiBSZWFjdC5SZWFjdEluc3RhbmNlLCByZXN0aW5nU3R5bGU6IFJlYWN0LkNTU1Byb3BlcnRpZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSAmJlxuICAgICAgICAgICAgdGhpcy5ub2Rlc1trXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0YXJ0U3R5bGVzLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFN0eWxlcyA9IHRoaXMucHJvcHMuc3RhcnRTdHlsZXM7XG4gICAgICAgICAgICBjb25zdCBkb21Ob2RlID0gUmVhY3REb20uZmluZERPTU5vZGUobm9kZSk7XG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIHN0YXJ0U3R5bGUgMTogMCBpcyB0aGUgb25lIHdlIGdhdmUgaXRcbiAgICAgICAgICAgIC8vIHRvIHN0YXJ0IHdpdGgsIHNvIG5vdyB3ZSBhbmltYXRlIDEgZXRjLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGFydFN0eWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZXMoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCwgc3RhcnRTdHlsZXNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RhcnQ6XCJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzdGFydFN0eWxlc1tpXSksXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gd2UgYW5pbWF0ZSB0byB0aGUgcmVzdGluZyBzdGF0ZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlcyhkb21Ob2RlIGFzIEhUTUxFbGVtZW50LCByZXN0aW5nU3R5bGUpO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZW50ZXI6XCIsXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShyZXN0aW5nU3R5bGUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVzW2tdID0gbm9kZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IEpTWC5FbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+eyBPYmplY3QudmFsdWVzKHRoaXMuY2hpbGRyZW4pIH08Lz5cbiAgICAgICAgKTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOztBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTUEsWUFBTixTQUEyQkMsY0FBQSxDQUFNQyxTQUFqQyxDQUFtRDtFQU85REMsV0FBVyxDQUFDQyxLQUFELEVBQWdCO0lBQ3ZCLE1BQU1BLEtBQU47SUFEdUIsNkNBTlgsRUFNVztJQUFBO0lBR3ZCLEtBQUtDLGNBQUwsQ0FBb0IsS0FBS0QsS0FBTCxDQUFXRSxRQUEvQjtFQUNIOztFQUVNQyxrQkFBa0IsR0FBUztJQUM5QixLQUFLRixjQUFMLENBQW9CLEtBQUtELEtBQUwsQ0FBV0UsUUFBL0I7RUFDSDtFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0VBQ1lFLFdBQVcsQ0FBQ0MsSUFBRCxFQUFvQkMsTUFBcEIsRUFBdUQ7SUFDdEVDLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlRixNQUFmLEVBQXVCRyxPQUF2QixDQUErQixRQUF1QjtNQUFBLElBQXRCLENBQUNDLFFBQUQsRUFBV0MsS0FBWCxDQUFzQjtNQUNsRE4sSUFBSSxDQUFDTyxLQUFMLENBQVdGLFFBQVgsSUFBdUJDLEtBQXZCO0lBQ0gsQ0FGRDtFQUdIOztFQUVPVixjQUFjLENBQUNZLFdBQUQsRUFBcUM7SUFDdkQsTUFBTUMsV0FBVyxHQUFHLEtBQUtaLFFBQUwsSUFBaUIsRUFBckM7SUFDQSxLQUFLQSxRQUFMLEdBQWdCLEVBQWhCOztJQUNBTCxjQUFBLENBQU1rQixRQUFOLENBQWVDLE9BQWYsQ0FBdUJILFdBQXZCLEVBQW9DSixPQUFwQyxDQUE2Q1EsQ0FBRCxJQUFZO01BQ3BELElBQUlILFdBQVcsQ0FBQ0csQ0FBQyxDQUFDQyxHQUFILENBQWYsRUFBd0I7UUFDcEIsTUFBTUMsR0FBRyxHQUFHTCxXQUFXLENBQUNHLENBQUMsQ0FBQ0MsR0FBSCxDQUF2Qjs7UUFDQSxNQUFNRSxPQUFPLEdBQUdDLGlCQUFBLENBQVNDLFdBQVQsQ0FBcUIsS0FBS0MsS0FBTCxDQUFXSixHQUFHLENBQUNELEdBQWYsQ0FBckIsQ0FBaEI7O1FBRUEsSUFBSUUsT0FBTyxJQUFLQSxPQUFELENBQXlCUixLQUF6QixDQUErQlksSUFBL0IsS0FBd0NQLENBQUMsQ0FBQ2pCLEtBQUYsQ0FBUVksS0FBUixDQUFjWSxJQUFyRSxFQUEyRTtVQUN2RSxLQUFLcEIsV0FBTCxDQUFpQmdCLE9BQWpCLEVBQXlDO1lBQUVJLElBQUksRUFBRVAsQ0FBQyxDQUFDakIsS0FBRixDQUFRWSxLQUFSLENBQWNZO1VBQXRCLENBQXpDLEVBRHVFLENBRXZFO1FBQ0gsQ0FQbUIsQ0FRcEI7UUFDQTs7O1FBQ0EsS0FBS3RCLFFBQUwsQ0FBY2UsQ0FBQyxDQUFDQyxHQUFoQixpQkFBdUJyQixjQUFBLENBQU00QixZQUFOLENBQW1CTixHQUFuQixFQUF3QkYsQ0FBQyxDQUFDakIsS0FBMUIsRUFBaUNpQixDQUFDLENBQUNqQixLQUFGLENBQVFFLFFBQXpDLENBQXZCO01BQ0gsQ0FYRCxNQVdPO1FBQ0g7UUFDQTtRQUNBLE1BQU13QixRQUE4QixHQUFHLEVBQXZDO1FBQ0EsTUFBTUMsWUFBWSxHQUFHVixDQUFDLENBQUNqQixLQUFGLENBQVFZLEtBQTdCO1FBRUEsTUFBTWdCLFdBQVcsR0FBRyxLQUFLNUIsS0FBTCxDQUFXNEIsV0FBL0I7O1FBQ0EsSUFBSUEsV0FBVyxDQUFDQyxNQUFaLEdBQXFCLENBQXpCLEVBQTRCO1VBQ3hCLE1BQU1DLFVBQVUsR0FBR0YsV0FBVyxDQUFDLENBQUQsQ0FBOUI7VUFDQUYsUUFBUSxDQUFDZCxLQUFULEdBQWlCa0IsVUFBakIsQ0FGd0IsQ0FHeEI7UUFDSDs7UUFFREosUUFBUSxDQUFDSyxHQUFULEdBQWlCQyxDQUFELElBQU8sS0FBS0MsV0FBTCxDQUNuQmhCLENBQUMsQ0FBQ0MsR0FEaUIsRUFDWmMsQ0FEWSxFQUNUTCxZQURTLENBQXZCOztRQUlBLEtBQUt6QixRQUFMLENBQWNlLENBQUMsQ0FBQ0MsR0FBaEIsaUJBQXVCckIsY0FBQSxDQUFNNEIsWUFBTixDQUFtQlIsQ0FBbkIsRUFBc0JTLFFBQXRCLENBQXZCO01BQ0g7SUFDSixDQS9CRDtFQWdDSDs7RUFFT08sV0FBVyxDQUFDQyxDQUFELEVBQVk3QixJQUFaLEVBQXVDc0IsWUFBdkMsRUFBZ0Y7SUFDL0YsSUFDSXRCLElBQUksSUFDSixLQUFLa0IsS0FBTCxDQUFXVyxDQUFYLE1BQWtCQyxTQURsQixJQUVBLEtBQUtuQyxLQUFMLENBQVc0QixXQUFYLENBQXVCQyxNQUF2QixHQUFnQyxDQUhwQyxFQUlFO01BQ0UsTUFBTUQsV0FBVyxHQUFHLEtBQUs1QixLQUFMLENBQVc0QixXQUEvQjs7TUFDQSxNQUFNUSxPQUFPLEdBQUdmLGlCQUFBLENBQVNDLFdBQVQsQ0FBcUJqQixJQUFyQixDQUFoQixDQUZGLENBR0U7TUFDQTs7O01BQ0EsS0FBSyxJQUFJZ0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1QsV0FBVyxDQUFDQyxNQUFoQyxFQUF3QyxFQUFFUSxDQUExQyxFQUE2QztRQUN6QyxLQUFLakMsV0FBTCxDQUFpQmdDLE9BQWpCLEVBQXlDUixXQUFXLENBQUNTLENBQUQsQ0FBcEQsRUFEeUMsQ0FFekM7UUFDQTtRQUNBO01BQ0gsQ0FWSCxDQVlFOzs7TUFDQUMsVUFBVSxDQUFDLE1BQU07UUFDYixLQUFLbEMsV0FBTCxDQUFpQmdDLE9BQWpCLEVBQXlDVCxZQUF6QztNQUNILENBRlMsRUFFUCxDQUZPLENBQVYsQ0FiRixDQWlCRTtNQUNBO0lBQ0g7O0lBQ0QsS0FBS0osS0FBTCxDQUFXVyxDQUFYLElBQWdCN0IsSUFBaEI7RUFDSDs7RUFFTWtDLE1BQU0sR0FBZ0I7SUFDekIsb0JBQ0ksNERBQUloQyxNQUFNLENBQUNpQyxNQUFQLENBQWMsS0FBS3RDLFFBQW5CLENBQUosQ0FESjtFQUdIOztBQWxHNkQ7Ozs4QkFBN0NOLFksa0JBRzZCO0VBQzFDZ0MsV0FBVyxFQUFFO0FBRDZCLEMifQ==