"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCaretOffsetAndText = getCaretOffsetAndText;
exports.getRangeForSelection = getRangeForSelection;
exports.walkDOMDepthFirst = walkDOMDepthFirst;

var _render = require("./render");

var _offset = _interopRequireDefault(require("./offset"));

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function walkDOMDepthFirst(rootNode, enterNodeCallback, leaveNodeCallback) {
  let node = rootNode.firstChild;

  while (node && node !== rootNode) {
    const shouldDescend = enterNodeCallback(node);

    if (shouldDescend && node.firstChild) {
      node = node.firstChild;
    } else if (node.nextSibling) {
      node = node.nextSibling;
    } else {
      while (!node.nextSibling && node !== rootNode) {
        node = node.parentElement;

        if (node !== rootNode) {
          leaveNodeCallback(node);
        }
      }

      if (node !== rootNode) {
        node = node.nextSibling;
      }
    }
  }
}

function getCaretOffsetAndText(editor, sel) {
  const {
    offset,
    text
  } = getSelectionOffsetAndText(editor, sel.focusNode, sel.focusOffset);
  return {
    caret: offset,
    text
  };
}

function tryReduceSelectionToTextNode(selectionNode, selectionOffset) {
  // if selectionNode is an element, the selected location comes after the selectionOffset-th child node,
  // which can point past any childNode, in which case, the end of selectionNode is selected.
  // we try to simplify this to point at a text node with the offset being
  // a character offset within the text node
  // Also see https://developer.mozilla.org/en-US/docs/Web/API/Selection
  while (selectionNode && selectionNode.nodeType === Node.ELEMENT_NODE) {
    const childNodeCount = selectionNode.childNodes.length;

    if (childNodeCount) {
      if (selectionOffset >= childNodeCount) {
        selectionNode = selectionNode.lastChild;

        if (selectionNode.nodeType === Node.TEXT_NODE) {
          selectionOffset = selectionNode.textContent.length;
        } else {
          // this will select the last child node in the next iteration
          selectionOffset = Number.MAX_SAFE_INTEGER;
        }
      } else {
        selectionNode = selectionNode.childNodes[selectionOffset]; // this will select the first child node in the next iteration

        selectionOffset = 0;
      }
    } else {
      // here node won't be a text node,
      // but characterOffset should be 0,
      // this happens under some circumstances
      // when the editor is empty.
      // In this case characterOffset=0 is the right thing to do
      break;
    }
  }

  return {
    node: selectionNode,
    characterOffset: selectionOffset
  };
}

function getSelectionOffsetAndText(editor, selectionNode, selectionOffset) {
  const {
    node,
    characterOffset
  } = tryReduceSelectionToTextNode(selectionNode, selectionOffset);
  const {
    text,
    offsetToNode
  } = getTextAndOffsetToNode(editor, node);
  const offset = getCaret(node, offsetToNode, characterOffset);
  return {
    offset,
    text
  };
} // gets the caret position details, ignoring and adjusting to
// the ZWS if you're typing in a caret node


function getCaret(node, offsetToNode, offsetWithinNode) {
  // if no node is selected, return an offset at the start
  if (!node) {
    return new _offset.default(0, false);
  }

  let atNodeEnd = offsetWithinNode === node.textContent.length;

  if (node.nodeType === Node.TEXT_NODE && (0, _render.isCaretNode)(node.parentElement)) {
    const zwsIdx = node.nodeValue.indexOf(_render.CARET_NODE_CHAR);

    if (zwsIdx !== -1 && zwsIdx < offsetWithinNode) {
      offsetWithinNode -= 1;
    } // if typing in a caret node, you're either typing before or after the ZWS.
    // In both cases, you should be considered at node end because the ZWS is
    // not included in the text here, and once the model is updated and rerendered,
    // that caret node will be removed.


    atNodeEnd = true;
  }

  return new _offset.default(offsetToNode + offsetWithinNode, atNodeEnd);
} // gets the text of the editor as a string,
// and the offset in characters where the selectionNode starts in that string
// all ZWS from caret nodes are filtered out


function getTextAndOffsetToNode(editor, selectionNode) {
  let offsetToNode = 0;
  let foundNode = false;
  let text = "";

  function enterNodeCallback(node) {
    if (!foundNode) {
      if (node === selectionNode) {
        foundNode = true;
      }
    } // usually newlines are entered as new DIV elements,
    // but for example while pasting in some browsers, they are still
    // converted to BRs, so also take these into account when they
    // are not the last element in the DIV.


    if (node.tagName === "BR" && node.nextSibling) {
      if (!foundNode) {
        offsetToNode += 1;
      }

      text += "\n";
    }

    const nodeText = node.nodeType === Node.TEXT_NODE && getTextNodeValue(node);

    if (nodeText) {
      if (!foundNode) {
        offsetToNode += nodeText.length;
      }

      text += nodeText;
    }

    return true;
  }

  function leaveNodeCallback(node) {
    // if this is not the last DIV (which are only used as line containers atm)
    // we don't just check if there is a nextSibling because sometimes the caret ends up
    // after the last DIV and it creates a newline if you type then,
    // whereas you just want it to be appended to the current line
    if (node.tagName === "DIV" && node.nextSibling?.tagName === "DIV") {
      text += "\n";

      if (!foundNode) {
        offsetToNode += 1;
      }
    }
  }

  walkDOMDepthFirst(editor, enterNodeCallback, leaveNodeCallback);
  return {
    text,
    offsetToNode
  };
} // get text value of text node, ignoring ZWS if it's a caret node


function getTextNodeValue(node) {
  const nodeText = node.nodeValue; // filter out ZWS for caret nodes

  if ((0, _render.isCaretNode)(node.parentElement)) {
    // typed in the caret node, so there is now something more in it than the ZWS
    // so filter out the ZWS, and take the typed text into account
    if (nodeText.length !== 1) {
      return nodeText.replace(_render.CARET_NODE_CHAR, "");
    } else {
      // only contains ZWS, which is ignored, so return empty string
      return "";
    }
  } else {
    return nodeText;
  }
}

function getRangeForSelection(editor, model, selection) {
  const focusOffset = getSelectionOffsetAndText(editor, selection.focusNode, selection.focusOffset).offset;
  const anchorOffset = getSelectionOffsetAndText(editor, selection.anchorNode, selection.anchorOffset).offset;
  const focusPosition = focusOffset.asPosition(model);
  const anchorPosition = anchorOffset.asPosition(model);
  return model.startRange(focusPosition, anchorPosition);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ3YWxrRE9NRGVwdGhGaXJzdCIsInJvb3ROb2RlIiwiZW50ZXJOb2RlQ2FsbGJhY2siLCJsZWF2ZU5vZGVDYWxsYmFjayIsIm5vZGUiLCJmaXJzdENoaWxkIiwic2hvdWxkRGVzY2VuZCIsIm5leHRTaWJsaW5nIiwicGFyZW50RWxlbWVudCIsImdldENhcmV0T2Zmc2V0QW5kVGV4dCIsImVkaXRvciIsInNlbCIsIm9mZnNldCIsInRleHQiLCJnZXRTZWxlY3Rpb25PZmZzZXRBbmRUZXh0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJjYXJldCIsInRyeVJlZHVjZVNlbGVjdGlvblRvVGV4dE5vZGUiLCJzZWxlY3Rpb25Ob2RlIiwic2VsZWN0aW9uT2Zmc2V0Iiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiY2hpbGROb2RlQ291bnQiLCJjaGlsZE5vZGVzIiwibGVuZ3RoIiwibGFzdENoaWxkIiwiVEVYVF9OT0RFIiwidGV4dENvbnRlbnQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiY2hhcmFjdGVyT2Zmc2V0Iiwib2Zmc2V0VG9Ob2RlIiwiZ2V0VGV4dEFuZE9mZnNldFRvTm9kZSIsImdldENhcmV0Iiwib2Zmc2V0V2l0aGluTm9kZSIsIkRvY3VtZW50T2Zmc2V0IiwiYXROb2RlRW5kIiwiaXNDYXJldE5vZGUiLCJ6d3NJZHgiLCJub2RlVmFsdWUiLCJpbmRleE9mIiwiQ0FSRVRfTk9ERV9DSEFSIiwiZm91bmROb2RlIiwidGFnTmFtZSIsIm5vZGVUZXh0IiwiZ2V0VGV4dE5vZGVWYWx1ZSIsInJlcGxhY2UiLCJnZXRSYW5nZUZvclNlbGVjdGlvbiIsIm1vZGVsIiwic2VsZWN0aW9uIiwiYW5jaG9yT2Zmc2V0IiwiYW5jaG9yTm9kZSIsImZvY3VzUG9zaXRpb24iLCJhc1Bvc2l0aW9uIiwiYW5jaG9yUG9zaXRpb24iLCJzdGFydFJhbmdlIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2VkaXRvci9kb20udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IENBUkVUX05PREVfQ0hBUiwgaXNDYXJldE5vZGUgfSBmcm9tIFwiLi9yZW5kZXJcIjtcbmltcG9ydCBEb2N1bWVudE9mZnNldCBmcm9tIFwiLi9vZmZzZXRcIjtcbmltcG9ydCBFZGl0b3JNb2RlbCBmcm9tIFwiLi9tb2RlbFwiO1xuaW1wb3J0IFJhbmdlIGZyb20gXCIuL3JhbmdlXCI7XG5cbnR5cGUgUHJlZGljYXRlID0gKG5vZGU6IE5vZGUpID0+IGJvb2xlYW47XG50eXBlIENhbGxiYWNrID0gKG5vZGU6IE5vZGUpID0+IHZvaWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWxrRE9NRGVwdGhGaXJzdChyb290Tm9kZTogTm9kZSwgZW50ZXJOb2RlQ2FsbGJhY2s6IFByZWRpY2F0ZSwgbGVhdmVOb2RlQ2FsbGJhY2s6IENhbGxiYWNrKSB7XG4gICAgbGV0IG5vZGUgPSByb290Tm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZERlc2NlbmQgPSBlbnRlck5vZGVDYWxsYmFjayhub2RlKTtcbiAgICAgICAgaWYgKHNob3VsZERlc2NlbmQgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCFub2RlLm5leHRTaWJsaW5nICYmIG5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVOb2RlQ2FsbGJhY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXJldE9mZnNldEFuZFRleHQoZWRpdG9yOiBIVE1MRGl2RWxlbWVudCwgc2VsOiBTZWxlY3Rpb24pIHtcbiAgICBjb25zdCB7IG9mZnNldCwgdGV4dCB9ID0gZ2V0U2VsZWN0aW9uT2Zmc2V0QW5kVGV4dChlZGl0b3IsIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgcmV0dXJuIHsgY2FyZXQ6IG9mZnNldCwgdGV4dCB9O1xufVxuXG5mdW5jdGlvbiB0cnlSZWR1Y2VTZWxlY3Rpb25Ub1RleHROb2RlKHNlbGVjdGlvbk5vZGU6IE5vZGUsIHNlbGVjdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgLy8gaWYgc2VsZWN0aW9uTm9kZSBpcyBhbiBlbGVtZW50LCB0aGUgc2VsZWN0ZWQgbG9jYXRpb24gY29tZXMgYWZ0ZXIgdGhlIHNlbGVjdGlvbk9mZnNldC10aCBjaGlsZCBub2RlLFxuICAgIC8vIHdoaWNoIGNhbiBwb2ludCBwYXN0IGFueSBjaGlsZE5vZGUsIGluIHdoaWNoIGNhc2UsIHRoZSBlbmQgb2Ygc2VsZWN0aW9uTm9kZSBpcyBzZWxlY3RlZC5cbiAgICAvLyB3ZSB0cnkgdG8gc2ltcGxpZnkgdGhpcyB0byBwb2ludCBhdCBhIHRleHQgbm9kZSB3aXRoIHRoZSBvZmZzZXQgYmVpbmdcbiAgICAvLyBhIGNoYXJhY3RlciBvZmZzZXQgd2l0aGluIHRoZSB0ZXh0IG5vZGVcbiAgICAvLyBBbHNvIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VsZWN0aW9uXG4gICAgd2hpbGUgKHNlbGVjdGlvbk5vZGUgJiYgc2VsZWN0aW9uTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlQ291bnQgPSBzZWxlY3Rpb25Ob2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICBpZiAoY2hpbGROb2RlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25PZmZzZXQgPj0gY2hpbGROb2RlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ob2RlID0gc2VsZWN0aW9uTm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk9mZnNldCA9IHNlbGVjdGlvbk5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBzZWxlY3QgdGhlIGxhc3QgY2hpbGQgbm9kZSBpbiB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ob2RlID0gc2VsZWN0aW9uTm9kZS5jaGlsZE5vZGVzW3NlbGVjdGlvbk9mZnNldF07XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHNlbGVjdCB0aGUgZmlyc3QgY2hpbGQgbm9kZSBpbiB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25PZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGVyZSBub2RlIHdvbid0IGJlIGEgdGV4dCBub2RlLFxuICAgICAgICAgICAgLy8gYnV0IGNoYXJhY3Rlck9mZnNldCBzaG91bGQgYmUgMCxcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXNcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGVkaXRvciBpcyBlbXB0eS5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSBjaGFyYWN0ZXJPZmZzZXQ9MCBpcyB0aGUgcmlnaHQgdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHNlbGVjdGlvbk5vZGUsXG4gICAgICAgIGNoYXJhY3Rlck9mZnNldDogc2VsZWN0aW9uT2Zmc2V0LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbk9mZnNldEFuZFRleHQoZWRpdG9yOiBIVE1MRGl2RWxlbWVudCwgc2VsZWN0aW9uTm9kZTogTm9kZSwgc2VsZWN0aW9uT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCB7IG5vZGUsIGNoYXJhY3Rlck9mZnNldCB9ID0gdHJ5UmVkdWNlU2VsZWN0aW9uVG9UZXh0Tm9kZShzZWxlY3Rpb25Ob2RlLCBzZWxlY3Rpb25PZmZzZXQpO1xuICAgIGNvbnN0IHsgdGV4dCwgb2Zmc2V0VG9Ob2RlIH0gPSBnZXRUZXh0QW5kT2Zmc2V0VG9Ob2RlKGVkaXRvciwgbm9kZSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ2V0Q2FyZXQobm9kZSwgb2Zmc2V0VG9Ob2RlLCBjaGFyYWN0ZXJPZmZzZXQpO1xuICAgIHJldHVybiB7IG9mZnNldCwgdGV4dCB9O1xufVxuXG4vLyBnZXRzIHRoZSBjYXJldCBwb3NpdGlvbiBkZXRhaWxzLCBpZ25vcmluZyBhbmQgYWRqdXN0aW5nIHRvXG4vLyB0aGUgWldTIGlmIHlvdSdyZSB0eXBpbmcgaW4gYSBjYXJldCBub2RlXG5mdW5jdGlvbiBnZXRDYXJldChub2RlOiBOb2RlLCBvZmZzZXRUb05vZGU6IG51bWJlciwgb2Zmc2V0V2l0aGluTm9kZTogbnVtYmVyKSB7XG4gICAgLy8gaWYgbm8gbm9kZSBpcyBzZWxlY3RlZCwgcmV0dXJuIGFuIG9mZnNldCBhdCB0aGUgc3RhcnRcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudE9mZnNldCgwLCBmYWxzZSk7XG4gICAgfVxuICAgIGxldCBhdE5vZGVFbmQgPSBvZmZzZXRXaXRoaW5Ob2RlID09PSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgaXNDYXJldE5vZGUobm9kZS5wYXJlbnRFbGVtZW50KSkge1xuICAgICAgICBjb25zdCB6d3NJZHggPSBub2RlLm5vZGVWYWx1ZS5pbmRleE9mKENBUkVUX05PREVfQ0hBUik7XG4gICAgICAgIGlmICh6d3NJZHggIT09IC0xICYmIHp3c0lkeCA8IG9mZnNldFdpdGhpbk5vZGUpIHtcbiAgICAgICAgICAgIG9mZnNldFdpdGhpbk5vZGUgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0eXBpbmcgaW4gYSBjYXJldCBub2RlLCB5b3UncmUgZWl0aGVyIHR5cGluZyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIFpXUy5cbiAgICAgICAgLy8gSW4gYm90aCBjYXNlcywgeW91IHNob3VsZCBiZSBjb25zaWRlcmVkIGF0IG5vZGUgZW5kIGJlY2F1c2UgdGhlIFpXUyBpc1xuICAgICAgICAvLyBub3QgaW5jbHVkZWQgaW4gdGhlIHRleHQgaGVyZSwgYW5kIG9uY2UgdGhlIG1vZGVsIGlzIHVwZGF0ZWQgYW5kIHJlcmVuZGVyZWQsXG4gICAgICAgIC8vIHRoYXQgY2FyZXQgbm9kZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgIGF0Tm9kZUVuZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRG9jdW1lbnRPZmZzZXQob2Zmc2V0VG9Ob2RlICsgb2Zmc2V0V2l0aGluTm9kZSwgYXROb2RlRW5kKTtcbn1cblxuLy8gZ2V0cyB0aGUgdGV4dCBvZiB0aGUgZWRpdG9yIGFzIGEgc3RyaW5nLFxuLy8gYW5kIHRoZSBvZmZzZXQgaW4gY2hhcmFjdGVycyB3aGVyZSB0aGUgc2VsZWN0aW9uTm9kZSBzdGFydHMgaW4gdGhhdCBzdHJpbmdcbi8vIGFsbCBaV1MgZnJvbSBjYXJldCBub2RlcyBhcmUgZmlsdGVyZWQgb3V0XG5mdW5jdGlvbiBnZXRUZXh0QW5kT2Zmc2V0VG9Ob2RlKGVkaXRvcjogSFRNTERpdkVsZW1lbnQsIHNlbGVjdGlvbk5vZGU6IE5vZGUpIHtcbiAgICBsZXQgb2Zmc2V0VG9Ob2RlID0gMDtcbiAgICBsZXQgZm91bmROb2RlID0gZmFsc2U7XG4gICAgbGV0IHRleHQgPSBcIlwiO1xuXG4gICAgZnVuY3Rpb24gZW50ZXJOb2RlQ2FsbGJhY2sobm9kZTogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFmb3VuZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBzZWxlY3Rpb25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgZm91bmROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1c3VhbGx5IG5ld2xpbmVzIGFyZSBlbnRlcmVkIGFzIG5ldyBESVYgZWxlbWVudHMsXG4gICAgICAgIC8vIGJ1dCBmb3IgZXhhbXBsZSB3aGlsZSBwYXN0aW5nIGluIHNvbWUgYnJvd3NlcnMsIHRoZXkgYXJlIHN0aWxsXG4gICAgICAgIC8vIGNvbnZlcnRlZCB0byBCUnMsIHNvIGFsc28gdGFrZSB0aGVzZSBpbnRvIGFjY291bnQgd2hlbiB0aGV5XG4gICAgICAgIC8vIGFyZSBub3QgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgRElWLlxuICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIkJSXCIgJiYgbm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKCFmb3VuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRUb05vZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlVGV4dCA9IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGdldFRleHROb2RlVmFsdWUobm9kZSk7XG4gICAgICAgIGlmIChub2RlVGV4dCkge1xuICAgICAgICAgICAgaWYgKCFmb3VuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRUb05vZGUgKz0gbm9kZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCArPSBub2RlVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWF2ZU5vZGVDYWxsYmFjayhub2RlOiBIVE1MRWxlbWVudCkge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCBESVYgKHdoaWNoIGFyZSBvbmx5IHVzZWQgYXMgbGluZSBjb250YWluZXJzIGF0bSlcbiAgICAgICAgLy8gd2UgZG9uJ3QganVzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5leHRTaWJsaW5nIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBjYXJldCBlbmRzIHVwXG4gICAgICAgIC8vIGFmdGVyIHRoZSBsYXN0IERJViBhbmQgaXQgY3JlYXRlcyBhIG5ld2xpbmUgaWYgeW91IHR5cGUgdGhlbixcbiAgICAgICAgLy8gd2hlcmVhcyB5b3UganVzdCB3YW50IGl0IHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJESVZcIiAmJiAoPEhUTUxFbGVtZW50Pm5vZGUubmV4dFNpYmxpbmcpPy50YWdOYW1lID09PSBcIkRJVlwiKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBpZiAoIWZvdW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIG9mZnNldFRvTm9kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2Fsa0RPTURlcHRoRmlyc3QoZWRpdG9yLCBlbnRlck5vZGVDYWxsYmFjaywgbGVhdmVOb2RlQ2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHsgdGV4dCwgb2Zmc2V0VG9Ob2RlIH07XG59XG5cbi8vIGdldCB0ZXh0IHZhbHVlIG9mIHRleHQgbm9kZSwgaWdub3JpbmcgWldTIGlmIGl0J3MgYSBjYXJldCBub2RlXG5mdW5jdGlvbiBnZXRUZXh0Tm9kZVZhbHVlKG5vZGU6IE5vZGUpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5vZGVUZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgLy8gZmlsdGVyIG91dCBaV1MgZm9yIGNhcmV0IG5vZGVzXG4gICAgaWYgKGlzQ2FyZXROb2RlKG5vZGUucGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgLy8gdHlwZWQgaW4gdGhlIGNhcmV0IG5vZGUsIHNvIHRoZXJlIGlzIG5vdyBzb21ldGhpbmcgbW9yZSBpbiBpdCB0aGFuIHRoZSBaV1NcbiAgICAgICAgLy8gc28gZmlsdGVyIG91dCB0aGUgWldTLCBhbmQgdGFrZSB0aGUgdHlwZWQgdGV4dCBpbnRvIGFjY291bnRcbiAgICAgICAgaWYgKG5vZGVUZXh0Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVUZXh0LnJlcGxhY2UoQ0FSRVRfTk9ERV9DSEFSLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY29udGFpbnMgWldTLCB3aGljaCBpcyBpZ25vcmVkLCBzbyByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlVGV4dDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZUZvclNlbGVjdGlvbihlZGl0b3I6IEhUTUxEaXZFbGVtZW50LCBtb2RlbDogRWRpdG9yTW9kZWwsIHNlbGVjdGlvbjogU2VsZWN0aW9uKTogUmFuZ2Uge1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZ2V0U2VsZWN0aW9uT2Zmc2V0QW5kVGV4dChcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgICBzZWxlY3Rpb24uZm9jdXNPZmZzZXQsXG4gICAgKS5vZmZzZXQ7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gZ2V0U2VsZWN0aW9uT2Zmc2V0QW5kVGV4dChcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgICAgc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICApLm9mZnNldDtcbiAgICBjb25zdCBmb2N1c1Bvc2l0aW9uID0gZm9jdXNPZmZzZXQuYXNQb3NpdGlvbihtb2RlbCk7XG4gICAgY29uc3QgYW5jaG9yUG9zaXRpb24gPSBhbmNob3JPZmZzZXQuYXNQb3NpdGlvbihtb2RlbCk7XG4gICAgcmV0dXJuIG1vZGVsLnN0YXJ0UmFuZ2UoZm9jdXNQb3NpdGlvbiwgYW5jaG9yUG9zaXRpb24pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVTyxTQUFTQSxpQkFBVCxDQUEyQkMsUUFBM0IsRUFBMkNDLGlCQUEzQyxFQUF5RUMsaUJBQXpFLEVBQXNHO0VBQ3pHLElBQUlDLElBQUksR0FBR0gsUUFBUSxDQUFDSSxVQUFwQjs7RUFDQSxPQUFPRCxJQUFJLElBQUlBLElBQUksS0FBS0gsUUFBeEIsRUFBa0M7SUFDOUIsTUFBTUssYUFBYSxHQUFHSixpQkFBaUIsQ0FBQ0UsSUFBRCxDQUF2Qzs7SUFDQSxJQUFJRSxhQUFhLElBQUlGLElBQUksQ0FBQ0MsVUFBMUIsRUFBc0M7TUFDbENELElBQUksR0FBR0EsSUFBSSxDQUFDQyxVQUFaO0lBQ0gsQ0FGRCxNQUVPLElBQUlELElBQUksQ0FBQ0csV0FBVCxFQUFzQjtNQUN6QkgsSUFBSSxHQUFHQSxJQUFJLENBQUNHLFdBQVo7SUFDSCxDQUZNLE1BRUE7TUFDSCxPQUFPLENBQUNILElBQUksQ0FBQ0csV0FBTixJQUFxQkgsSUFBSSxLQUFLSCxRQUFyQyxFQUErQztRQUMzQ0csSUFBSSxHQUFHQSxJQUFJLENBQUNJLGFBQVo7O1FBQ0EsSUFBSUosSUFBSSxLQUFLSCxRQUFiLEVBQXVCO1VBQ25CRSxpQkFBaUIsQ0FBQ0MsSUFBRCxDQUFqQjtRQUNIO01BQ0o7O01BQ0QsSUFBSUEsSUFBSSxLQUFLSCxRQUFiLEVBQXVCO1FBQ25CRyxJQUFJLEdBQUdBLElBQUksQ0FBQ0csV0FBWjtNQUNIO0lBQ0o7RUFDSjtBQUNKOztBQUVNLFNBQVNFLHFCQUFULENBQStCQyxNQUEvQixFQUF1REMsR0FBdkQsRUFBdUU7RUFDMUUsTUFBTTtJQUFFQyxNQUFGO0lBQVVDO0VBQVYsSUFBbUJDLHlCQUF5QixDQUFDSixNQUFELEVBQVNDLEdBQUcsQ0FBQ0ksU0FBYixFQUF3QkosR0FBRyxDQUFDSyxXQUE1QixDQUFsRDtFQUNBLE9BQU87SUFBRUMsS0FBSyxFQUFFTCxNQUFUO0lBQWlCQztFQUFqQixDQUFQO0FBQ0g7O0FBRUQsU0FBU0ssNEJBQVQsQ0FBc0NDLGFBQXRDLEVBQTJEQyxlQUEzRCxFQUFvRjtFQUNoRjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBT0QsYUFBYSxJQUFJQSxhQUFhLENBQUNFLFFBQWQsS0FBMkJDLElBQUksQ0FBQ0MsWUFBeEQsRUFBc0U7SUFDbEUsTUFBTUMsY0FBYyxHQUFHTCxhQUFhLENBQUNNLFVBQWQsQ0FBeUJDLE1BQWhEOztJQUNBLElBQUlGLGNBQUosRUFBb0I7TUFDaEIsSUFBSUosZUFBZSxJQUFJSSxjQUF2QixFQUF1QztRQUNuQ0wsYUFBYSxHQUFHQSxhQUFhLENBQUNRLFNBQTlCOztRQUNBLElBQUlSLGFBQWEsQ0FBQ0UsUUFBZCxLQUEyQkMsSUFBSSxDQUFDTSxTQUFwQyxFQUErQztVQUMzQ1IsZUFBZSxHQUFHRCxhQUFhLENBQUNVLFdBQWQsQ0FBMEJILE1BQTVDO1FBQ0gsQ0FGRCxNQUVPO1VBQ0g7VUFDQU4sZUFBZSxHQUFHVSxNQUFNLENBQUNDLGdCQUF6QjtRQUNIO01BQ0osQ0FSRCxNQVFPO1FBQ0haLGFBQWEsR0FBR0EsYUFBYSxDQUFDTSxVQUFkLENBQXlCTCxlQUF6QixDQUFoQixDQURHLENBRUg7O1FBQ0FBLGVBQWUsR0FBRyxDQUFsQjtNQUNIO0lBQ0osQ0FkRCxNQWNPO01BQ0g7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO0lBQ0g7RUFDSjs7RUFDRCxPQUFPO0lBQ0hoQixJQUFJLEVBQUVlLGFBREg7SUFFSGEsZUFBZSxFQUFFWjtFQUZkLENBQVA7QUFJSDs7QUFFRCxTQUFTTix5QkFBVCxDQUFtQ0osTUFBbkMsRUFBMkRTLGFBQTNELEVBQWdGQyxlQUFoRixFQUF5RztFQUNyRyxNQUFNO0lBQUVoQixJQUFGO0lBQVE0QjtFQUFSLElBQTRCZCw0QkFBNEIsQ0FBQ0MsYUFBRCxFQUFnQkMsZUFBaEIsQ0FBOUQ7RUFDQSxNQUFNO0lBQUVQLElBQUY7SUFBUW9CO0VBQVIsSUFBeUJDLHNCQUFzQixDQUFDeEIsTUFBRCxFQUFTTixJQUFULENBQXJEO0VBQ0EsTUFBTVEsTUFBTSxHQUFHdUIsUUFBUSxDQUFDL0IsSUFBRCxFQUFPNkIsWUFBUCxFQUFxQkQsZUFBckIsQ0FBdkI7RUFDQSxPQUFPO0lBQUVwQixNQUFGO0lBQVVDO0VBQVYsQ0FBUDtBQUNILEMsQ0FFRDtBQUNBOzs7QUFDQSxTQUFTc0IsUUFBVCxDQUFrQi9CLElBQWxCLEVBQThCNkIsWUFBOUIsRUFBb0RHLGdCQUFwRCxFQUE4RTtFQUMxRTtFQUNBLElBQUksQ0FBQ2hDLElBQUwsRUFBVztJQUNQLE9BQU8sSUFBSWlDLGVBQUosQ0FBbUIsQ0FBbkIsRUFBc0IsS0FBdEIsQ0FBUDtFQUNIOztFQUNELElBQUlDLFNBQVMsR0FBR0YsZ0JBQWdCLEtBQUtoQyxJQUFJLENBQUN5QixXQUFMLENBQWlCSCxNQUF0RDs7RUFDQSxJQUFJdEIsSUFBSSxDQUFDaUIsUUFBTCxLQUFrQkMsSUFBSSxDQUFDTSxTQUF2QixJQUFvQyxJQUFBVyxtQkFBQSxFQUFZbkMsSUFBSSxDQUFDSSxhQUFqQixDQUF4QyxFQUF5RTtJQUNyRSxNQUFNZ0MsTUFBTSxHQUFHcEMsSUFBSSxDQUFDcUMsU0FBTCxDQUFlQyxPQUFmLENBQXVCQyx1QkFBdkIsQ0FBZjs7SUFDQSxJQUFJSCxNQUFNLEtBQUssQ0FBQyxDQUFaLElBQWlCQSxNQUFNLEdBQUdKLGdCQUE5QixFQUFnRDtNQUM1Q0EsZ0JBQWdCLElBQUksQ0FBcEI7SUFDSCxDQUpvRSxDQUtyRTtJQUNBO0lBQ0E7SUFDQTs7O0lBQ0FFLFNBQVMsR0FBRyxJQUFaO0VBQ0g7O0VBQ0QsT0FBTyxJQUFJRCxlQUFKLENBQW1CSixZQUFZLEdBQUdHLGdCQUFsQyxFQUFvREUsU0FBcEQsQ0FBUDtBQUNILEMsQ0FFRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNKLHNCQUFULENBQWdDeEIsTUFBaEMsRUFBd0RTLGFBQXhELEVBQTZFO0VBQ3pFLElBQUljLFlBQVksR0FBRyxDQUFuQjtFQUNBLElBQUlXLFNBQVMsR0FBRyxLQUFoQjtFQUNBLElBQUkvQixJQUFJLEdBQUcsRUFBWDs7RUFFQSxTQUFTWCxpQkFBVCxDQUEyQkUsSUFBM0IsRUFBOEM7SUFDMUMsSUFBSSxDQUFDd0MsU0FBTCxFQUFnQjtNQUNaLElBQUl4QyxJQUFJLEtBQUtlLGFBQWIsRUFBNEI7UUFDeEJ5QixTQUFTLEdBQUcsSUFBWjtNQUNIO0lBQ0osQ0FMeUMsQ0FNMUM7SUFDQTtJQUNBO0lBQ0E7OztJQUNBLElBQUl4QyxJQUFJLENBQUN5QyxPQUFMLEtBQWlCLElBQWpCLElBQXlCekMsSUFBSSxDQUFDRyxXQUFsQyxFQUErQztNQUMzQyxJQUFJLENBQUNxQyxTQUFMLEVBQWdCO1FBQ1pYLFlBQVksSUFBSSxDQUFoQjtNQUNIOztNQUNEcEIsSUFBSSxJQUFJLElBQVI7SUFDSDs7SUFDRCxNQUFNaUMsUUFBUSxHQUFHMUMsSUFBSSxDQUFDaUIsUUFBTCxLQUFrQkMsSUFBSSxDQUFDTSxTQUF2QixJQUFvQ21CLGdCQUFnQixDQUFDM0MsSUFBRCxDQUFyRTs7SUFDQSxJQUFJMEMsUUFBSixFQUFjO01BQ1YsSUFBSSxDQUFDRixTQUFMLEVBQWdCO1FBQ1pYLFlBQVksSUFBSWEsUUFBUSxDQUFDcEIsTUFBekI7TUFDSDs7TUFDRGIsSUFBSSxJQUFJaUMsUUFBUjtJQUNIOztJQUNELE9BQU8sSUFBUDtFQUNIOztFQUVELFNBQVMzQyxpQkFBVCxDQUEyQkMsSUFBM0IsRUFBOEM7SUFDMUM7SUFDQTtJQUNBO0lBQ0E7SUFDQSxJQUFJQSxJQUFJLENBQUN5QyxPQUFMLEtBQWlCLEtBQWpCLElBQXdDekMsSUFBSSxDQUFDRyxXQUFuQixFQUFpQ3NDLE9BQWpDLEtBQTZDLEtBQTNFLEVBQWtGO01BQzlFaEMsSUFBSSxJQUFJLElBQVI7O01BQ0EsSUFBSSxDQUFDK0IsU0FBTCxFQUFnQjtRQUNaWCxZQUFZLElBQUksQ0FBaEI7TUFDSDtJQUNKO0VBQ0o7O0VBRURqQyxpQkFBaUIsQ0FBQ1UsTUFBRCxFQUFTUixpQkFBVCxFQUE0QkMsaUJBQTVCLENBQWpCO0VBRUEsT0FBTztJQUFFVSxJQUFGO0lBQVFvQjtFQUFSLENBQVA7QUFDSCxDLENBRUQ7OztBQUNBLFNBQVNjLGdCQUFULENBQTBCM0MsSUFBMUIsRUFBOEM7RUFDMUMsTUFBTTBDLFFBQVEsR0FBRzFDLElBQUksQ0FBQ3FDLFNBQXRCLENBRDBDLENBRTFDOztFQUNBLElBQUksSUFBQUYsbUJBQUEsRUFBWW5DLElBQUksQ0FBQ0ksYUFBakIsQ0FBSixFQUFxQztJQUNqQztJQUNBO0lBQ0EsSUFBSXNDLFFBQVEsQ0FBQ3BCLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7TUFDdkIsT0FBT29CLFFBQVEsQ0FBQ0UsT0FBVCxDQUFpQkwsdUJBQWpCLEVBQWtDLEVBQWxDLENBQVA7SUFDSCxDQUZELE1BRU87TUFDSDtNQUNBLE9BQU8sRUFBUDtJQUNIO0VBQ0osQ0FURCxNQVNPO0lBQ0gsT0FBT0csUUFBUDtFQUNIO0FBQ0o7O0FBRU0sU0FBU0csb0JBQVQsQ0FBOEJ2QyxNQUE5QixFQUFzRHdDLEtBQXRELEVBQTBFQyxTQUExRSxFQUF1RztFQUMxRyxNQUFNbkMsV0FBVyxHQUFHRix5QkFBeUIsQ0FDekNKLE1BRHlDLEVBRXpDeUMsU0FBUyxDQUFDcEMsU0FGK0IsRUFHekNvQyxTQUFTLENBQUNuQyxXQUgrQixDQUF6QixDQUlsQkosTUFKRjtFQUtBLE1BQU13QyxZQUFZLEdBQUd0Qyx5QkFBeUIsQ0FDMUNKLE1BRDBDLEVBRTFDeUMsU0FBUyxDQUFDRSxVQUZnQyxFQUcxQ0YsU0FBUyxDQUFDQyxZQUhnQyxDQUF6QixDQUluQnhDLE1BSkY7RUFLQSxNQUFNMEMsYUFBYSxHQUFHdEMsV0FBVyxDQUFDdUMsVUFBWixDQUF1QkwsS0FBdkIsQ0FBdEI7RUFDQSxNQUFNTSxjQUFjLEdBQUdKLFlBQVksQ0FBQ0csVUFBYixDQUF3QkwsS0FBeEIsQ0FBdkI7RUFDQSxPQUFPQSxLQUFLLENBQUNPLFVBQU4sQ0FBaUJILGFBQWpCLEVBQWdDRSxjQUFoQyxDQUFQO0FBQ0gifQ==