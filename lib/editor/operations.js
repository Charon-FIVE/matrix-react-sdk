"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatRange = formatRange;
exports.formatRangeAsCode = formatRangeAsCode;
exports.formatRangeAsLink = formatRangeAsLink;
exports.formatRangeAsQuote = formatRangeAsQuote;
exports.rangeEndsAtEndOfLine = rangeEndsAtEndOfLine;
exports.rangeStartsAtBeginningOfLine = rangeStartsAtBeginningOfLine;
exports.replaceRangeAndAutoAdjustCaret = replaceRangeAndAutoAdjustCaret;
exports.replaceRangeAndExpandSelection = replaceRangeAndExpandSelection;
exports.replaceRangeAndMoveCaret = replaceRangeAndMoveCaret;
exports.selectRangeOfWordAtCaret = selectRangeOfWordAtCaret;
exports.toggleInlineFormat = toggleInlineFormat;

var _parts = require("./parts");

var _MessageComposerFormatBar = require("../components/views/rooms/MessageComposerFormatBar");

var _deserialize = require("./deserialize");

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Some common queries and transformations on the editor model
 */

/**
 * Formats a given range with a given action
 * @param {Range} range the range that should be formatted
 * @param {Formatting} action the action that should be performed on the range
 */
function formatRange(range, action) {
  // If the selection was empty we select the current word instead
  if (range.wasInitializedEmpty()) {
    selectRangeOfWordAtCaret(range);
  } else {
    // Remove whitespace or new lines in our selection
    range.trim();
  } // Edge case when just selecting whitespace or new line.
  // There should be no reason to format whitespace, so we can just return.


  if (range.length === 0) {
    return;
  }

  switch (action) {
    case _MessageComposerFormatBar.Formatting.Bold:
      toggleInlineFormat(range, "**");
      break;

    case _MessageComposerFormatBar.Formatting.Italics:
      toggleInlineFormat(range, "_");
      break;

    case _MessageComposerFormatBar.Formatting.Strikethrough:
      toggleInlineFormat(range, "<del>", "</del>");
      break;

    case _MessageComposerFormatBar.Formatting.Code:
      formatRangeAsCode(range);
      break;

    case _MessageComposerFormatBar.Formatting.Quote:
      formatRangeAsQuote(range);
      break;

    case _MessageComposerFormatBar.Formatting.InsertLink:
      formatRangeAsLink(range);
      break;
  }
}

function replaceRangeAndExpandSelection(range, newParts) {
  const {
    model
  } = range;
  model.transform(() => {
    const oldLen = range.length;
    const addedLen = range.replace(newParts);
    const firstOffset = range.start.asOffset(model);
    const lastOffset = firstOffset.add(oldLen + addedLen);
    return model.startRange(firstOffset.asPosition(model), lastOffset.asPosition(model));
  });
}

function replaceRangeAndMoveCaret(range, newParts) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let atNodeEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const {
    model
  } = range;
  model.transform(() => {
    const oldLen = range.length;
    const addedLen = range.replace(newParts);
    const firstOffset = range.start.asOffset(model);
    const lastOffset = firstOffset.add(oldLen + addedLen + offset, atNodeEnd);
    return lastOffset.asPosition(model);
  });
}
/**
 * Replaces a range with formatting or removes existing formatting and
 * positions the cursor with respect to the prefix and suffix length.
 * @param {Range} range the previous value
 * @param {Part[]} newParts the new value
 * @param {boolean} rangeHasFormatting the new value
 * @param {number} prefixLength the length of the formatting prefix
 * @param {number} suffixLength the length of the formatting suffix, defaults to prefix length
 */


function replaceRangeAndAutoAdjustCaret(range, newParts) {
  let rangeHasFormatting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let prefixLength = arguments.length > 3 ? arguments[3] : undefined;
  let suffixLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : prefixLength;
  const {
    model
  } = range;
  const lastStartingPosition = range.getLastStartingPosition();
  const relativeOffset = lastStartingPosition.offset - range.start.offset;
  const distanceFromEnd = range.length - relativeOffset; // Handle edge case where the caret is located within the suffix or prefix

  if (rangeHasFormatting) {
    if (relativeOffset < prefixLength) {
      // Was the caret at the left format string?
      replaceRangeAndMoveCaret(range, newParts, -(range.length - 2 * suffixLength));
      return;
    }

    if (distanceFromEnd < suffixLength) {
      // Was the caret at the right format string?
      replaceRangeAndMoveCaret(range, newParts, 0, true);
      return;
    }
  } // Calculate new position with respect to the previous position


  model.transform(() => {
    const offsetDirection = Math.sign(range.replace(newParts)); // Compensates for shrinkage or expansion

    const atEnd = distanceFromEnd === suffixLength;
    return lastStartingPosition.asOffset(model).add(offsetDirection * prefixLength, atEnd).asPosition(model);
  });
}

const isFormattable = (_index, offset, part) => {
  return part.text[offset] !== " " && part.type === _parts.Type.Plain;
};

function selectRangeOfWordAtCaret(range) {
  // Select right side of word
  range.expandForwardsWhile(isFormattable); // Select left side of word

  range.expandBackwardsWhile(isFormattable); // Trim possibly selected new lines

  range.trim();
}

function rangeStartsAtBeginningOfLine(range) {
  const {
    model
  } = range;
  const startsWithPartial = range.start.offset !== 0;
  const isFirstPart = range.start.index === 0;
  const previousIsNewline = !isFirstPart && model.parts[range.start.index - 1].type === _parts.Type.Newline;
  return !startsWithPartial && (isFirstPart || previousIsNewline);
}

function rangeEndsAtEndOfLine(range) {
  const {
    model
  } = range;
  const lastPart = model.parts[range.end.index];
  const endsWithPartial = range.end.offset !== lastPart.text.length;
  const isLastPart = range.end.index === model.parts.length - 1;
  const nextIsNewline = !isLastPart && model.parts[range.end.index + 1].type === _parts.Type.Newline;
  return !endsWithPartial && (isLastPart || nextIsNewline);
}

function formatRangeAsQuote(range) {
  const {
    model,
    parts
  } = range;
  const {
    partCreator
  } = model;

  for (let i = 0; i < parts.length; ++i) {
    const part = parts[i];

    if (part.type === _parts.Type.Newline) {
      parts.splice(i + 1, 0, partCreator.plain("> "));
    }
  }

  parts.unshift(partCreator.plain("> "));

  if (!rangeStartsAtBeginningOfLine(range)) {
    parts.unshift(partCreator.newline());
  }

  if (!rangeEndsAtEndOfLine(range)) {
    parts.push(partCreator.newline());
  }

  parts.push(partCreator.newline());
  replaceRangeAndExpandSelection(range, parts);
}

function formatRangeAsCode(range) {
  const {
    model,
    parts
  } = range;
  const {
    partCreator
  } = model;
  const hasBlockFormatting = range.length > 0 && range.text.startsWith("```") && range.text.endsWith("```") && range.text.includes('\n');
  const needsBlockFormatting = parts.some(p => p.type === _parts.Type.Newline);

  if (hasBlockFormatting) {
    parts.shift();
    parts.pop();

    if (parts[0]?.text === "\n" && parts[parts.length - 1]?.text === "\n") {
      parts.shift();
      parts.pop();
    }
  } else if (needsBlockFormatting) {
    parts.unshift(partCreator.plain("```"), partCreator.newline());

    if (!rangeStartsAtBeginningOfLine(range)) {
      parts.unshift(partCreator.newline());
    }

    parts.push(partCreator.newline(), partCreator.plain("```"));

    if (!rangeEndsAtEndOfLine(range)) {
      parts.push(partCreator.newline());
    }
  } else {
    const fenceLen = (0, _deserialize.longestBacktickSequence)(range.text);
    const hasInlineFormatting = range.text.startsWith("`") && range.text.endsWith("`"); //if it's already formatted untoggle based on fenceLen which returns the max. num of backtick within a text else increase the fence backticks with a factor of 1.

    toggleInlineFormat(range, "`".repeat(hasInlineFormatting ? fenceLen : fenceLen + 1));
    return;
  }

  replaceRangeAndExpandSelection(range, parts);
}

function formatRangeAsLink(range, text) {
  const {
    model
  } = range;
  const {
    partCreator
  } = model;
  const linkRegex = /\[(.*?)]\(.*?\)/g;
  const isFormattedAsLink = linkRegex.test(range.text);

  if (isFormattedAsLink) {
    const linkDescription = range.text.replace(linkRegex, "$1");
    const newParts = [partCreator.plain(linkDescription)];
    replaceRangeAndMoveCaret(range, newParts, 0);
  } else {
    // We set offset to -1 here so that the caret lands between the brackets
    replaceRangeAndMoveCaret(range, [partCreator.plain("[" + range.text + "]" + "(" + (text ?? "") + ")")], -1);
  }
} // parts helper methods


const isBlank = part => !part.text || !/\S/.test(part.text);

const isNL = part => part.type === _parts.Type.Newline;

function toggleInlineFormat(range, prefix) {
  let suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;
  const {
    model,
    parts
  } = range;
  const {
    partCreator
  } = model; // compute paragraph [start, end] indexes

  const paragraphIndexes = [];
  let startIndex = 0; // start at i=2 because we look at i and up to two parts behind to detect paragraph breaks at their end

  for (let i = 2; i < parts.length; i++) {
    // paragraph breaks can be denoted in a multitude of ways,
    // - 2 newline parts in sequence
    // - newline part, plain(<empty or just spaces>), newline part
    // bump startIndex onto the first non-blank after the paragraph ending
    if (isBlank(parts[i - 2]) && isNL(parts[i - 1]) && !isNL(parts[i]) && !isBlank(parts[i])) {
      startIndex = i;
    } // if at a paragraph break, store the indexes of the paragraph


    if (isNL(parts[i - 1]) && isNL(parts[i])) {
      paragraphIndexes.push([startIndex, i - 1]);
      startIndex = i + 1;
    } else if (isNL(parts[i - 2]) && isBlank(parts[i - 1]) && isNL(parts[i])) {
      paragraphIndexes.push([startIndex, i - 2]);
      startIndex = i + 1;
    }
  }

  const lastNonEmptyPart = parts.map(isBlank).lastIndexOf(false); // If we have not yet included the final paragraph then add it now

  if (startIndex <= lastNonEmptyPart) {
    paragraphIndexes.push([startIndex, lastNonEmptyPart + 1]);
  } // keep track of how many things we have inserted as an offset:=0


  let offset = 0;
  paragraphIndexes.forEach(_ref => {
    let [startIdx, endIdx] = _ref;
    // for each paragraph apply the same rule
    const base = startIdx + offset;
    const index = endIdx + offset;
    const isFormatted = index - base > 0 && parts[base].text.startsWith(prefix) && parts[index - 1].text.endsWith(suffix);

    if (isFormatted) {
      // remove prefix and suffix formatting string
      const partWithoutPrefix = parts[base].serialize();
      partWithoutPrefix.text = partWithoutPrefix.text.slice(prefix.length);
      parts[base] = partCreator.deserializePart(partWithoutPrefix);
      const partWithoutSuffix = parts[index - 1].serialize();
      const suffixPartText = partWithoutSuffix.text;
      partWithoutSuffix.text = suffixPartText.substring(0, suffixPartText.length - suffix.length);
      parts[index - 1] = partCreator.deserializePart(partWithoutSuffix);
    } else {
      parts.splice(index, 0, partCreator.plain(suffix)); // splice in the later one first to not change offset

      parts.splice(base, 0, partCreator.plain(prefix));
      offset += 2; // offset index to account for the two items we just spliced in
    }
  }); // If the user didn't select something initially, we want to just restore
  // the caret position instead of making a new selection.

  if (range.wasInitializedEmpty() && prefix === suffix) {
    // Check if we need to add a offset for a toggle or untoggle
    const hasFormatting = range.text.startsWith(prefix) && range.text.endsWith(suffix);
    replaceRangeAndAutoAdjustCaret(range, parts, hasFormatting, prefix.length);
  } else {
    replaceRangeAndExpandSelection(range, parts);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmb3JtYXRSYW5nZSIsInJhbmdlIiwiYWN0aW9uIiwid2FzSW5pdGlhbGl6ZWRFbXB0eSIsInNlbGVjdFJhbmdlT2ZXb3JkQXRDYXJldCIsInRyaW0iLCJsZW5ndGgiLCJGb3JtYXR0aW5nIiwiQm9sZCIsInRvZ2dsZUlubGluZUZvcm1hdCIsIkl0YWxpY3MiLCJTdHJpa2V0aHJvdWdoIiwiQ29kZSIsImZvcm1hdFJhbmdlQXNDb2RlIiwiUXVvdGUiLCJmb3JtYXRSYW5nZUFzUXVvdGUiLCJJbnNlcnRMaW5rIiwiZm9ybWF0UmFuZ2VBc0xpbmsiLCJyZXBsYWNlUmFuZ2VBbmRFeHBhbmRTZWxlY3Rpb24iLCJuZXdQYXJ0cyIsIm1vZGVsIiwidHJhbnNmb3JtIiwib2xkTGVuIiwiYWRkZWRMZW4iLCJyZXBsYWNlIiwiZmlyc3RPZmZzZXQiLCJzdGFydCIsImFzT2Zmc2V0IiwibGFzdE9mZnNldCIsImFkZCIsInN0YXJ0UmFuZ2UiLCJhc1Bvc2l0aW9uIiwicmVwbGFjZVJhbmdlQW5kTW92ZUNhcmV0Iiwib2Zmc2V0IiwiYXROb2RlRW5kIiwicmVwbGFjZVJhbmdlQW5kQXV0b0FkanVzdENhcmV0IiwicmFuZ2VIYXNGb3JtYXR0aW5nIiwicHJlZml4TGVuZ3RoIiwic3VmZml4TGVuZ3RoIiwibGFzdFN0YXJ0aW5nUG9zaXRpb24iLCJnZXRMYXN0U3RhcnRpbmdQb3NpdGlvbiIsInJlbGF0aXZlT2Zmc2V0IiwiZGlzdGFuY2VGcm9tRW5kIiwib2Zmc2V0RGlyZWN0aW9uIiwiTWF0aCIsInNpZ24iLCJhdEVuZCIsImlzRm9ybWF0dGFibGUiLCJfaW5kZXgiLCJwYXJ0IiwidGV4dCIsInR5cGUiLCJUeXBlIiwiUGxhaW4iLCJleHBhbmRGb3J3YXJkc1doaWxlIiwiZXhwYW5kQmFja3dhcmRzV2hpbGUiLCJyYW5nZVN0YXJ0c0F0QmVnaW5uaW5nT2ZMaW5lIiwic3RhcnRzV2l0aFBhcnRpYWwiLCJpc0ZpcnN0UGFydCIsImluZGV4IiwicHJldmlvdXNJc05ld2xpbmUiLCJwYXJ0cyIsIk5ld2xpbmUiLCJyYW5nZUVuZHNBdEVuZE9mTGluZSIsImxhc3RQYXJ0IiwiZW5kIiwiZW5kc1dpdGhQYXJ0aWFsIiwiaXNMYXN0UGFydCIsIm5leHRJc05ld2xpbmUiLCJwYXJ0Q3JlYXRvciIsImkiLCJzcGxpY2UiLCJwbGFpbiIsInVuc2hpZnQiLCJuZXdsaW5lIiwicHVzaCIsImhhc0Jsb2NrRm9ybWF0dGluZyIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImluY2x1ZGVzIiwibmVlZHNCbG9ja0Zvcm1hdHRpbmciLCJzb21lIiwicCIsInNoaWZ0IiwicG9wIiwiZmVuY2VMZW4iLCJsb25nZXN0QmFja3RpY2tTZXF1ZW5jZSIsImhhc0lubGluZUZvcm1hdHRpbmciLCJyZXBlYXQiLCJsaW5rUmVnZXgiLCJpc0Zvcm1hdHRlZEFzTGluayIsInRlc3QiLCJsaW5rRGVzY3JpcHRpb24iLCJpc0JsYW5rIiwiaXNOTCIsInByZWZpeCIsInN1ZmZpeCIsInBhcmFncmFwaEluZGV4ZXMiLCJzdGFydEluZGV4IiwibGFzdE5vbkVtcHR5UGFydCIsIm1hcCIsImxhc3RJbmRleE9mIiwiZm9yRWFjaCIsInN0YXJ0SWR4IiwiZW5kSWR4IiwiYmFzZSIsImlzRm9ybWF0dGVkIiwicGFydFdpdGhvdXRQcmVmaXgiLCJzZXJpYWxpemUiLCJzbGljZSIsImRlc2VyaWFsaXplUGFydCIsInBhcnRXaXRob3V0U3VmZml4Iiwic3VmZml4UGFydFRleHQiLCJzdWJzdHJpbmciLCJoYXNGb3JtYXR0aW5nIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2VkaXRvci9vcGVyYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSYW5nZSBmcm9tIFwiLi9yYW5nZVwiO1xuaW1wb3J0IHsgUGFydCwgVHlwZSB9IGZyb20gXCIuL3BhcnRzXCI7XG5pbXBvcnQgeyBGb3JtYXR0aW5nIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvdmlld3Mvcm9vbXMvTWVzc2FnZUNvbXBvc2VyRm9ybWF0QmFyXCI7XG5pbXBvcnQgeyBsb25nZXN0QmFja3RpY2tTZXF1ZW5jZSB9IGZyb20gJy4vZGVzZXJpYWxpemUnO1xuXG4vKipcbiAqIFNvbWUgY29tbW9uIHF1ZXJpZXMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgZWRpdG9yIG1vZGVsXG4gKi9cblxuLyoqXG4gKiBGb3JtYXRzIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIGdpdmVuIGFjdGlvblxuICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgdGhlIHJhbmdlIHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtGb3JtYXR0aW5nfSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IHNob3VsZCBiZSBwZXJmb3JtZWQgb24gdGhlIHJhbmdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSYW5nZShyYW5nZTogUmFuZ2UsIGFjdGlvbjogRm9ybWF0dGluZyk6IHZvaWQge1xuICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gd2FzIGVtcHR5IHdlIHNlbGVjdCB0aGUgY3VycmVudCB3b3JkIGluc3RlYWRcbiAgICBpZiAocmFuZ2Uud2FzSW5pdGlhbGl6ZWRFbXB0eSgpKSB7XG4gICAgICAgIHNlbGVjdFJhbmdlT2ZXb3JkQXRDYXJldChyYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2Ugb3IgbmV3IGxpbmVzIGluIG91ciBzZWxlY3Rpb25cbiAgICAgICAgcmFuZ2UudHJpbSgpO1xuICAgIH1cblxuICAgIC8vIEVkZ2UgY2FzZSB3aGVuIGp1c3Qgc2VsZWN0aW5nIHdoaXRlc3BhY2Ugb3IgbmV3IGxpbmUuXG4gICAgLy8gVGhlcmUgc2hvdWxkIGJlIG5vIHJlYXNvbiB0byBmb3JtYXQgd2hpdGVzcGFjZSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuLlxuICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgRm9ybWF0dGluZy5Cb2xkOlxuICAgICAgICAgICAgdG9nZ2xlSW5saW5lRm9ybWF0KHJhbmdlLCBcIioqXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9ybWF0dGluZy5JdGFsaWNzOlxuICAgICAgICAgICAgdG9nZ2xlSW5saW5lRm9ybWF0KHJhbmdlLCBcIl9cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb3JtYXR0aW5nLlN0cmlrZXRocm91Z2g6XG4gICAgICAgICAgICB0b2dnbGVJbmxpbmVGb3JtYXQocmFuZ2UsIFwiPGRlbD5cIiwgXCI8L2RlbD5cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb3JtYXR0aW5nLkNvZGU6XG4gICAgICAgICAgICBmb3JtYXRSYW5nZUFzQ29kZShyYW5nZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb3JtYXR0aW5nLlF1b3RlOlxuICAgICAgICAgICAgZm9ybWF0UmFuZ2VBc1F1b3RlKHJhbmdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvcm1hdHRpbmcuSW5zZXJ0TGluazpcbiAgICAgICAgICAgIGZvcm1hdFJhbmdlQXNMaW5rKHJhbmdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VSYW5nZUFuZEV4cGFuZFNlbGVjdGlvbihyYW5nZTogUmFuZ2UsIG5ld1BhcnRzOiBQYXJ0W10pOiB2b2lkIHtcbiAgICBjb25zdCB7IG1vZGVsIH0gPSByYW5nZTtcbiAgICBtb2RlbC50cmFuc2Zvcm0oKCkgPT4ge1xuICAgICAgICBjb25zdCBvbGRMZW4gPSByYW5nZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFkZGVkTGVuID0gcmFuZ2UucmVwbGFjZShuZXdQYXJ0cyk7XG4gICAgICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnQuYXNPZmZzZXQobW9kZWwpO1xuICAgICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gZmlyc3RPZmZzZXQuYWRkKG9sZExlbiArIGFkZGVkTGVuKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsLnN0YXJ0UmFuZ2UoZmlyc3RPZmZzZXQuYXNQb3NpdGlvbihtb2RlbCksIGxhc3RPZmZzZXQuYXNQb3NpdGlvbihtb2RlbCkpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVJhbmdlQW5kTW92ZUNhcmV0KHJhbmdlOiBSYW5nZSwgbmV3UGFydHM6IFBhcnRbXSwgb2Zmc2V0ID0gMCwgYXROb2RlRW5kID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCB7IG1vZGVsIH0gPSByYW5nZTtcbiAgICBtb2RlbC50cmFuc2Zvcm0oKCkgPT4ge1xuICAgICAgICBjb25zdCBvbGRMZW4gPSByYW5nZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFkZGVkTGVuID0gcmFuZ2UucmVwbGFjZShuZXdQYXJ0cyk7XG4gICAgICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnQuYXNPZmZzZXQobW9kZWwpO1xuICAgICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gZmlyc3RPZmZzZXQuYWRkKG9sZExlbiArIGFkZGVkTGVuICsgb2Zmc2V0LCBhdE5vZGVFbmQpO1xuICAgICAgICByZXR1cm4gbGFzdE9mZnNldC5hc1Bvc2l0aW9uKG1vZGVsKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhIHJhbmdlIHdpdGggZm9ybWF0dGluZyBvciByZW1vdmVzIGV4aXN0aW5nIGZvcm1hdHRpbmcgYW5kXG4gKiBwb3NpdGlvbnMgdGhlIGN1cnNvciB3aXRoIHJlc3BlY3QgdG8gdGhlIHByZWZpeCBhbmQgc3VmZml4IGxlbmd0aC5cbiAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIHRoZSBwcmV2aW91cyB2YWx1ZVxuICogQHBhcmFtIHtQYXJ0W119IG5ld1BhcnRzIHRoZSBuZXcgdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmFuZ2VIYXNGb3JtYXR0aW5nIHRoZSBuZXcgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVmaXhMZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgZm9ybWF0dGluZyBwcmVmaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWZmaXhMZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgZm9ybWF0dGluZyBzdWZmaXgsIGRlZmF1bHRzIHRvIHByZWZpeCBsZW5ndGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VSYW5nZUFuZEF1dG9BZGp1c3RDYXJldChcbiAgICByYW5nZTogUmFuZ2UsXG4gICAgbmV3UGFydHM6IFBhcnRbXSxcbiAgICByYW5nZUhhc0Zvcm1hdHRpbmcgPSBmYWxzZSxcbiAgICBwcmVmaXhMZW5ndGg6IG51bWJlcixcbiAgICBzdWZmaXhMZW5ndGggPSBwcmVmaXhMZW5ndGgsXG4pOiB2b2lkIHtcbiAgICBjb25zdCB7IG1vZGVsIH0gPSByYW5nZTtcbiAgICBjb25zdCBsYXN0U3RhcnRpbmdQb3NpdGlvbiA9IHJhbmdlLmdldExhc3RTdGFydGluZ1Bvc2l0aW9uKCk7XG4gICAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSBsYXN0U3RhcnRpbmdQb3NpdGlvbi5vZmZzZXQgLSByYW5nZS5zdGFydC5vZmZzZXQ7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tRW5kID0gcmFuZ2UubGVuZ3RoIC0gcmVsYXRpdmVPZmZzZXQ7XG4gICAgLy8gSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSB0aGUgY2FyZXQgaXMgbG9jYXRlZCB3aXRoaW4gdGhlIHN1ZmZpeCBvciBwcmVmaXhcbiAgICBpZiAocmFuZ2VIYXNGb3JtYXR0aW5nKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZU9mZnNldCA8IHByZWZpeExlbmd0aCkgeyAvLyBXYXMgdGhlIGNhcmV0IGF0IHRoZSBsZWZ0IGZvcm1hdCBzdHJpbmc/XG4gICAgICAgICAgICByZXBsYWNlUmFuZ2VBbmRNb3ZlQ2FyZXQocmFuZ2UsIG5ld1BhcnRzLCAtKHJhbmdlLmxlbmd0aCAtIDIgKiBzdWZmaXhMZW5ndGgpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzdGFuY2VGcm9tRW5kIDwgc3VmZml4TGVuZ3RoKSB7IC8vIFdhcyB0aGUgY2FyZXQgYXQgdGhlIHJpZ2h0IGZvcm1hdCBzdHJpbmc/XG4gICAgICAgICAgICByZXBsYWNlUmFuZ2VBbmRNb3ZlQ2FyZXQocmFuZ2UsIG5ld1BhcnRzLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgbmV3IHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgcHJldmlvdXMgcG9zaXRpb25cbiAgICBtb2RlbC50cmFuc2Zvcm0oKCkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXREaXJlY3Rpb24gPSBNYXRoLnNpZ24ocmFuZ2UucmVwbGFjZShuZXdQYXJ0cykpOyAvLyBDb21wZW5zYXRlcyBmb3Igc2hyaW5rYWdlIG9yIGV4cGFuc2lvblxuICAgICAgICBjb25zdCBhdEVuZCA9IGRpc3RhbmNlRnJvbUVuZCA9PT0gc3VmZml4TGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGFzdFN0YXJ0aW5nUG9zaXRpb24uYXNPZmZzZXQobW9kZWwpLmFkZChvZmZzZXREaXJlY3Rpb24gKiBwcmVmaXhMZW5ndGgsIGF0RW5kKS5hc1Bvc2l0aW9uKG1vZGVsKTtcbiAgICB9KTtcbn1cblxuY29uc3QgaXNGb3JtYXR0YWJsZSA9IChfaW5kZXg6IG51bWJlciwgb2Zmc2V0OiBudW1iZXIsIHBhcnQ6IFBhcnQpID0+IHtcbiAgICByZXR1cm4gcGFydC50ZXh0W29mZnNldF0gIT09IFwiIFwiICYmIHBhcnQudHlwZSA9PT0gVHlwZS5QbGFpbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RSYW5nZU9mV29yZEF0Q2FyZXQocmFuZ2U6IFJhbmdlKTogdm9pZCB7XG4gICAgLy8gU2VsZWN0IHJpZ2h0IHNpZGUgb2Ygd29yZFxuICAgIHJhbmdlLmV4cGFuZEZvcndhcmRzV2hpbGUoaXNGb3JtYXR0YWJsZSk7XG4gICAgLy8gU2VsZWN0IGxlZnQgc2lkZSBvZiB3b3JkXG4gICAgcmFuZ2UuZXhwYW5kQmFja3dhcmRzV2hpbGUoaXNGb3JtYXR0YWJsZSk7XG4gICAgLy8gVHJpbSBwb3NzaWJseSBzZWxlY3RlZCBuZXcgbGluZXNcbiAgICByYW5nZS50cmltKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZVN0YXJ0c0F0QmVnaW5uaW5nT2ZMaW5lKHJhbmdlOiBSYW5nZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgbW9kZWwgfSA9IHJhbmdlO1xuICAgIGNvbnN0IHN0YXJ0c1dpdGhQYXJ0aWFsID0gcmFuZ2Uuc3RhcnQub2Zmc2V0ICE9PSAwO1xuICAgIGNvbnN0IGlzRmlyc3RQYXJ0ID0gcmFuZ2Uuc3RhcnQuaW5kZXggPT09IDA7XG4gICAgY29uc3QgcHJldmlvdXNJc05ld2xpbmUgPSAhaXNGaXJzdFBhcnQgJiYgbW9kZWwucGFydHNbcmFuZ2Uuc3RhcnQuaW5kZXggLSAxXS50eXBlID09PSBUeXBlLk5ld2xpbmU7XG4gICAgcmV0dXJuICFzdGFydHNXaXRoUGFydGlhbCAmJiAoaXNGaXJzdFBhcnQgfHwgcHJldmlvdXNJc05ld2xpbmUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VFbmRzQXRFbmRPZkxpbmUocmFuZ2U6IFJhbmdlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBtb2RlbCB9ID0gcmFuZ2U7XG4gICAgY29uc3QgbGFzdFBhcnQgPSBtb2RlbC5wYXJ0c1tyYW5nZS5lbmQuaW5kZXhdO1xuICAgIGNvbnN0IGVuZHNXaXRoUGFydGlhbCA9IHJhbmdlLmVuZC5vZmZzZXQgIT09IGxhc3RQYXJ0LnRleHQubGVuZ3RoO1xuICAgIGNvbnN0IGlzTGFzdFBhcnQgPSByYW5nZS5lbmQuaW5kZXggPT09IG1vZGVsLnBhcnRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgbmV4dElzTmV3bGluZSA9ICFpc0xhc3RQYXJ0ICYmIG1vZGVsLnBhcnRzW3JhbmdlLmVuZC5pbmRleCArIDFdLnR5cGUgPT09IFR5cGUuTmV3bGluZTtcbiAgICByZXR1cm4gIWVuZHNXaXRoUGFydGlhbCAmJiAoaXNMYXN0UGFydCB8fCBuZXh0SXNOZXdsaW5lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJhbmdlQXNRdW90ZShyYW5nZTogUmFuZ2UpOiB2b2lkIHtcbiAgICBjb25zdCB7IG1vZGVsLCBwYXJ0cyB9ID0gcmFuZ2U7XG4gICAgY29uc3QgeyBwYXJ0Q3JlYXRvciB9ID0gbW9kZWw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFR5cGUuTmV3bGluZSkge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCAwLCBwYXJ0Q3JlYXRvci5wbGFpbihcIj4gXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJ0cy51bnNoaWZ0KHBhcnRDcmVhdG9yLnBsYWluKFwiPiBcIikpO1xuICAgIGlmICghcmFuZ2VTdGFydHNBdEJlZ2lubmluZ09mTGluZShyYW5nZSkpIHtcbiAgICAgICAgcGFydHMudW5zaGlmdChwYXJ0Q3JlYXRvci5uZXdsaW5lKCkpO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlRW5kc0F0RW5kT2ZMaW5lKHJhbmdlKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhcnRDcmVhdG9yLm5ld2xpbmUoKSk7XG4gICAgfVxuICAgIHBhcnRzLnB1c2gocGFydENyZWF0b3IubmV3bGluZSgpKTtcbiAgICByZXBsYWNlUmFuZ2VBbmRFeHBhbmRTZWxlY3Rpb24ocmFuZ2UsIHBhcnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJhbmdlQXNDb2RlKHJhbmdlOiBSYW5nZSk6IHZvaWQge1xuICAgIGNvbnN0IHsgbW9kZWwsIHBhcnRzIH0gPSByYW5nZTtcbiAgICBjb25zdCB7IHBhcnRDcmVhdG9yIH0gPSBtb2RlbDtcblxuICAgIGNvbnN0IGhhc0Jsb2NrRm9ybWF0dGluZyA9IChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAmJiByYW5nZS50ZXh0LnN0YXJ0c1dpdGgoXCJgYGBcIilcbiAgICAgICAgJiYgcmFuZ2UudGV4dC5lbmRzV2l0aChcImBgYFwiKVxuICAgICAgICAmJiByYW5nZS50ZXh0LmluY2x1ZGVzKCdcXG4nKTtcblxuICAgIGNvbnN0IG5lZWRzQmxvY2tGb3JtYXR0aW5nID0gcGFydHMuc29tZShwID0+IHAudHlwZSA9PT0gVHlwZS5OZXdsaW5lKTtcblxuICAgIGlmIChoYXNCbG9ja0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIGlmIChwYXJ0c1swXT8udGV4dCA9PT0gXCJcXG5cIiAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXT8udGV4dCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuZWVkc0Jsb2NrRm9ybWF0dGluZykge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KHBhcnRDcmVhdG9yLnBsYWluKFwiYGBgXCIpLCBwYXJ0Q3JlYXRvci5uZXdsaW5lKCkpO1xuICAgICAgICBpZiAoIXJhbmdlU3RhcnRzQXRCZWdpbm5pbmdPZkxpbmUocmFuZ2UpKSB7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KHBhcnRDcmVhdG9yLm5ld2xpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICAgIHBhcnRDcmVhdG9yLm5ld2xpbmUoKSxcbiAgICAgICAgICAgIHBhcnRDcmVhdG9yLnBsYWluKFwiYGBgXCIpKTtcbiAgICAgICAgaWYgKCFyYW5nZUVuZHNBdEVuZE9mTGluZShyYW5nZSkpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydENyZWF0b3IubmV3bGluZSgpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZlbmNlTGVuID0gbG9uZ2VzdEJhY2t0aWNrU2VxdWVuY2UocmFuZ2UudGV4dCk7XG4gICAgICAgIGNvbnN0IGhhc0lubGluZUZvcm1hdHRpbmcgPSByYW5nZS50ZXh0LnN0YXJ0c1dpdGgoXCJgXCIpICYmIHJhbmdlLnRleHQuZW5kc1dpdGgoXCJgXCIpO1xuICAgICAgICAvL2lmIGl0J3MgYWxyZWFkeSBmb3JtYXR0ZWQgdW50b2dnbGUgYmFzZWQgb24gZmVuY2VMZW4gd2hpY2ggcmV0dXJucyB0aGUgbWF4LiBudW0gb2YgYmFja3RpY2sgd2l0aGluIGEgdGV4dCBlbHNlIGluY3JlYXNlIHRoZSBmZW5jZSBiYWNrdGlja3Mgd2l0aCBhIGZhY3RvciBvZiAxLlxuICAgICAgICB0b2dnbGVJbmxpbmVGb3JtYXQocmFuZ2UsIFwiYFwiLnJlcGVhdChoYXNJbmxpbmVGb3JtYXR0aW5nID8gZmVuY2VMZW4gOiBmZW5jZUxlbiArIDEpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcGxhY2VSYW5nZUFuZEV4cGFuZFNlbGVjdGlvbihyYW5nZSwgcGFydHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmFuZ2VBc0xpbmsocmFuZ2U6IFJhbmdlLCB0ZXh0Pzogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBtb2RlbCB9ID0gcmFuZ2U7XG4gICAgY29uc3QgeyBwYXJ0Q3JlYXRvciB9ID0gbW9kZWw7XG4gICAgY29uc3QgbGlua1JlZ2V4ID0gL1xcWyguKj8pXVxcKC4qP1xcKS9nO1xuICAgIGNvbnN0IGlzRm9ybWF0dGVkQXNMaW5rID0gbGlua1JlZ2V4LnRlc3QocmFuZ2UudGV4dCk7XG4gICAgaWYgKGlzRm9ybWF0dGVkQXNMaW5rKSB7XG4gICAgICAgIGNvbnN0IGxpbmtEZXNjcmlwdGlvbiA9IHJhbmdlLnRleHQucmVwbGFjZShsaW5rUmVnZXgsIFwiJDFcIik7XG4gICAgICAgIGNvbnN0IG5ld1BhcnRzID0gW3BhcnRDcmVhdG9yLnBsYWluKGxpbmtEZXNjcmlwdGlvbildO1xuICAgICAgICByZXBsYWNlUmFuZ2VBbmRNb3ZlQ2FyZXQocmFuZ2UsIG5ld1BhcnRzLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzZXQgb2Zmc2V0IHRvIC0xIGhlcmUgc28gdGhhdCB0aGUgY2FyZXQgbGFuZHMgYmV0d2VlbiB0aGUgYnJhY2tldHNcbiAgICAgICAgcmVwbGFjZVJhbmdlQW5kTW92ZUNhcmV0KHJhbmdlLCBbcGFydENyZWF0b3IucGxhaW4oXCJbXCIgKyByYW5nZS50ZXh0ICsgXCJdXCIgKyBcIihcIiArICh0ZXh0ID8/IFwiXCIpICsgXCIpXCIpXSwgLTEpO1xuICAgIH1cbn1cblxuLy8gcGFydHMgaGVscGVyIG1ldGhvZHNcbmNvbnN0IGlzQmxhbmsgPSBwYXJ0ID0+ICFwYXJ0LnRleHQgfHwgIS9cXFMvLnRlc3QocGFydC50ZXh0KTtcbmNvbnN0IGlzTkwgPSBwYXJ0ID0+IHBhcnQudHlwZSA9PT0gVHlwZS5OZXdsaW5lO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlSW5saW5lRm9ybWF0KHJhbmdlOiBSYW5nZSwgcHJlZml4OiBzdHJpbmcsIHN1ZmZpeCA9IHByZWZpeCk6IHZvaWQge1xuICAgIGNvbnN0IHsgbW9kZWwsIHBhcnRzIH0gPSByYW5nZTtcbiAgICBjb25zdCB7IHBhcnRDcmVhdG9yIH0gPSBtb2RlbDtcblxuICAgIC8vIGNvbXB1dGUgcGFyYWdyYXBoIFtzdGFydCwgZW5kXSBpbmRleGVzXG4gICAgY29uc3QgcGFyYWdyYXBoSW5kZXhlcyA9IFtdO1xuICAgIGxldCBzdGFydEluZGV4ID0gMDtcblxuICAgIC8vIHN0YXJ0IGF0IGk9MiBiZWNhdXNlIHdlIGxvb2sgYXQgaSBhbmQgdXAgdG8gdHdvIHBhcnRzIGJlaGluZCB0byBkZXRlY3QgcGFyYWdyYXBoIGJyZWFrcyBhdCB0aGVpciBlbmRcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHBhcmFncmFwaCBicmVha3MgY2FuIGJlIGRlbm90ZWQgaW4gYSBtdWx0aXR1ZGUgb2Ygd2F5cyxcbiAgICAgICAgLy8gLSAyIG5ld2xpbmUgcGFydHMgaW4gc2VxdWVuY2VcbiAgICAgICAgLy8gLSBuZXdsaW5lIHBhcnQsIHBsYWluKDxlbXB0eSBvciBqdXN0IHNwYWNlcz4pLCBuZXdsaW5lIHBhcnRcblxuICAgICAgICAvLyBidW1wIHN0YXJ0SW5kZXggb250byB0aGUgZmlyc3Qgbm9uLWJsYW5rIGFmdGVyIHRoZSBwYXJhZ3JhcGggZW5kaW5nXG4gICAgICAgIGlmIChpc0JsYW5rKHBhcnRzW2kgLSAyXSkgJiYgaXNOTChwYXJ0c1tpIC0gMV0pICYmICFpc05MKHBhcnRzW2ldKSAmJiAhaXNCbGFuayhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgYSBwYXJhZ3JhcGggYnJlYWssIHN0b3JlIHRoZSBpbmRleGVzIG9mIHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgaWYgKGlzTkwocGFydHNbaSAtIDFdKSAmJiBpc05MKHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgcGFyYWdyYXBoSW5kZXhlcy5wdXNoKFtzdGFydEluZGV4LCBpIC0gMV0pO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTkwocGFydHNbaSAtIDJdKSAmJiBpc0JsYW5rKHBhcnRzW2kgLSAxXSkgJiYgaXNOTChwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgIHBhcmFncmFwaEluZGV4ZXMucHVzaChbc3RhcnRJbmRleCwgaSAtIDJdKTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxhc3ROb25FbXB0eVBhcnQgPSBwYXJ0cy5tYXAoaXNCbGFuaykubGFzdEluZGV4T2YoZmFsc2UpO1xuICAgIC8vIElmIHdlIGhhdmUgbm90IHlldCBpbmNsdWRlZCB0aGUgZmluYWwgcGFyYWdyYXBoIHRoZW4gYWRkIGl0IG5vd1xuICAgIGlmIChzdGFydEluZGV4IDw9IGxhc3ROb25FbXB0eVBhcnQpIHtcbiAgICAgICAgcGFyYWdyYXBoSW5kZXhlcy5wdXNoKFtzdGFydEluZGV4LCBsYXN0Tm9uRW1wdHlQYXJ0ICsgMV0pO1xuICAgIH1cblxuICAgIC8vIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGhpbmdzIHdlIGhhdmUgaW5zZXJ0ZWQgYXMgYW4gb2Zmc2V0Oj0wXG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgcGFyYWdyYXBoSW5kZXhlcy5mb3JFYWNoKChbc3RhcnRJZHgsIGVuZElkeF0pID0+IHtcbiAgICAgICAgLy8gZm9yIGVhY2ggcGFyYWdyYXBoIGFwcGx5IHRoZSBzYW1lIHJ1bGVcbiAgICAgICAgY29uc3QgYmFzZSA9IHN0YXJ0SWR4ICsgb2Zmc2V0O1xuICAgICAgICBjb25zdCBpbmRleCA9IGVuZElkeCArIG9mZnNldDtcblxuICAgICAgICBjb25zdCBpc0Zvcm1hdHRlZCA9IChpbmRleCAtIGJhc2UgPiAwKSAmJlxuICAgICAgICAgICAgcGFydHNbYmFzZV0udGV4dC5zdGFydHNXaXRoKHByZWZpeCkgJiZcbiAgICAgICAgICAgIHBhcnRzW2luZGV4IC0gMV0udGV4dC5lbmRzV2l0aChzdWZmaXgpO1xuXG4gICAgICAgIGlmIChpc0Zvcm1hdHRlZCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHByZWZpeCBhbmQgc3VmZml4IGZvcm1hdHRpbmcgc3RyaW5nXG4gICAgICAgICAgICBjb25zdCBwYXJ0V2l0aG91dFByZWZpeCA9IHBhcnRzW2Jhc2VdLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgcGFydFdpdGhvdXRQcmVmaXgudGV4dCA9IHBhcnRXaXRob3V0UHJlZml4LnRleHQuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBwYXJ0c1tiYXNlXSA9IHBhcnRDcmVhdG9yLmRlc2VyaWFsaXplUGFydChwYXJ0V2l0aG91dFByZWZpeCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcnRXaXRob3V0U3VmZml4ID0gcGFydHNbaW5kZXggLSAxXS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1ZmZpeFBhcnRUZXh0ID0gcGFydFdpdGhvdXRTdWZmaXgudGV4dDtcbiAgICAgICAgICAgIHBhcnRXaXRob3V0U3VmZml4LnRleHQgPSBzdWZmaXhQYXJ0VGV4dC5zdWJzdHJpbmcoMCwgc3VmZml4UGFydFRleHQubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBwYXJ0c1tpbmRleCAtIDFdID0gcGFydENyZWF0b3IuZGVzZXJpYWxpemVQYXJ0KHBhcnRXaXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpbmRleCwgMCwgcGFydENyZWF0b3IucGxhaW4oc3VmZml4KSk7IC8vIHNwbGljZSBpbiB0aGUgbGF0ZXIgb25lIGZpcnN0IHRvIG5vdCBjaGFuZ2Ugb2Zmc2V0XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoYmFzZSwgMCwgcGFydENyZWF0b3IucGxhaW4ocHJlZml4KSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjsgLy8gb2Zmc2V0IGluZGV4IHRvIGFjY291bnQgZm9yIHRoZSB0d28gaXRlbXMgd2UganVzdCBzcGxpY2VkIGluXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSB1c2VyIGRpZG4ndCBzZWxlY3Qgc29tZXRoaW5nIGluaXRpYWxseSwgd2Ugd2FudCB0byBqdXN0IHJlc3RvcmVcbiAgICAvLyB0aGUgY2FyZXQgcG9zaXRpb24gaW5zdGVhZCBvZiBtYWtpbmcgYSBuZXcgc2VsZWN0aW9uLlxuICAgIGlmIChyYW5nZS53YXNJbml0aWFsaXplZEVtcHR5KCkgJiYgcHJlZml4ID09PSBzdWZmaXgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBvZmZzZXQgZm9yIGEgdG9nZ2xlIG9yIHVudG9nZ2xlXG4gICAgICAgIGNvbnN0IGhhc0Zvcm1hdHRpbmcgPSByYW5nZS50ZXh0LnN0YXJ0c1dpdGgocHJlZml4KSAmJiByYW5nZS50ZXh0LmVuZHNXaXRoKHN1ZmZpeCk7XG4gICAgICAgIHJlcGxhY2VSYW5nZUFuZEF1dG9BZGp1c3RDYXJldChyYW5nZSwgcGFydHMsIGhhc0Zvcm1hdHRpbmcsIHByZWZpeC5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZUFuZEV4cGFuZFNlbGVjdGlvbihyYW5nZSwgcGFydHMpO1xuICAgIH1cbn1c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