"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLineAndNodePosition = getLineAndNodePosition;
exports.setCaretPosition = setCaretPosition;
exports.setSelection = setSelection;

var _render = require("./render");

var _range = _interopRequireDefault(require("./range"));

var _parts = require("./parts");

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function setSelection(editor, model, selection) {
  if (selection instanceof _range.default) {
    setDocumentRangeSelection(editor, model, selection);
  } else {
    setCaretPosition(editor, model, selection);
  }
}

function setDocumentRangeSelection(editor, model, range) {
  const sel = document.getSelection();
  sel.removeAllRanges();
  const selectionRange = document.createRange();
  const start = getNodeAndOffsetForPosition(editor, model, range.start);
  selectionRange.setStart(start.node, start.offset);
  const end = getNodeAndOffsetForPosition(editor, model, range.end);
  selectionRange.setEnd(end.node, end.offset);
  sel.addRange(selectionRange);
}

function setCaretPosition(editor, model, caretPosition) {
  if (model.isEmpty) return; // selection can't possibly be wrong, so avoid a reflow

  const range = document.createRange();
  const {
    node,
    offset
  } = getNodeAndOffsetForPosition(editor, model, caretPosition);
  range.setStart(node, offset);
  range.collapse(true);
  const sel = document.getSelection();

  if (sel.rangeCount === 1) {
    const existingRange = sel.getRangeAt(0);

    if (existingRange.startContainer === range.startContainer && existingRange.startOffset === range.startOffset && existingRange.collapsed === range.collapsed) {
      // If the selection matches, it's important to leave it alone.
      // Recreating the selection state in at least Chrome can cause
      // strange side effects, like touch bar flickering on every key.
      // See https://github.com/vector-im/element-web/issues/9299
      return;
    }
  }

  sel.removeAllRanges();
  sel.addRange(range);
}

function getNodeAndOffsetForPosition(editor, model, position) {
  const {
    offset,
    lineIndex,
    nodeIndex
  } = getLineAndNodePosition(model, position);
  const lineNode = editor.childNodes[lineIndex];
  let focusNode; // empty line with just a <br>

  if (nodeIndex === -1) {
    focusNode = lineNode;
  } else {
    focusNode = lineNode.childNodes[nodeIndex]; // make sure we have a text node

    if (focusNode.nodeType === Node.ELEMENT_NODE && focusNode.firstChild) {
      focusNode = focusNode.firstChild;
    }
  }

  return {
    node: focusNode,
    offset
  };
}

function getLineAndNodePosition(model, caretPosition) {
  const {
    parts
  } = model;
  const partIndex = caretPosition.index;
  const lineResult = findNodeInLineForPart(parts, partIndex);
  const {
    lineIndex
  } = lineResult;
  let {
    nodeIndex
  } = lineResult;
  let {
    offset
  } = caretPosition; // we're at an empty line between a newline part
  // and another newline part or end/start of parts.
  // set offset to 0 so it gets set to the <br> inside the line container

  if (nodeIndex === -1) {
    offset = 0;
  } else {
    // move caret out of uneditable part (into caret node, or empty line br) if needed
    ({
      nodeIndex,
      offset
    } = moveOutOfUnselectablePart(parts, partIndex, nodeIndex, offset));
  }

  return {
    lineIndex,
    nodeIndex,
    offset
  };
}

function findNodeInLineForPart(parts, partIndex) {
  let lineIndex = 0;
  let nodeIndex = -1;
  let prevPart = null; // go through to parts up till (and including) the index
  // to find newline parts

  for (let i = 0; i <= partIndex; ++i) {
    const part = parts[i];

    if (part.type === _parts.Type.Newline) {
      lineIndex += 1;
      nodeIndex = -1;
      prevPart = null;
    } else {
      nodeIndex += 1;

      if ((0, _render.needsCaretNodeBefore)(part, prevPart)) {
        nodeIndex += 1;
      } // only jump over caret node if we're not at our destination node already,
      // as we'll assume in moveOutOfUnselectablePart that nodeIndex
      // refers to the node  corresponding to the part,
      // and not an adjacent caret node


      if (i < partIndex) {
        const nextPart = parts[i + 1];
        const isLastOfLine = !nextPart || nextPart.type === _parts.Type.Newline;

        if ((0, _render.needsCaretNodeAfter)(part, isLastOfLine)) {
          nodeIndex += 1;
        }
      }

      prevPart = part;
    }
  }

  return {
    lineIndex,
    nodeIndex
  };
}

function moveOutOfUnselectablePart(parts, partIndex, nodeIndex, offset) {
  // move caret before or after unselectable part
  const part = parts[partIndex];

  if (part && !part.acceptsCaret) {
    if (offset === 0) {
      nodeIndex -= 1;
      const prevPart = parts[partIndex - 1]; // if the previous node is a caret node, it's empty
      // so the offset can stay at 0
      // only when it's not, we need to set the offset
      // at the end of the node

      if (!(0, _render.needsCaretNodeBefore)(part, prevPart)) {
        offset = prevPart.text.length;
      }
    } else {
      nodeIndex += 1;
      offset = 0;
    }
  }

  return {
    nodeIndex,
    offset
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzZXRTZWxlY3Rpb24iLCJlZGl0b3IiLCJtb2RlbCIsInNlbGVjdGlvbiIsIlJhbmdlIiwic2V0RG9jdW1lbnRSYW5nZVNlbGVjdGlvbiIsInNldENhcmV0UG9zaXRpb24iLCJyYW5nZSIsInNlbCIsImRvY3VtZW50IiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwic2VsZWN0aW9uUmFuZ2UiLCJjcmVhdGVSYW5nZSIsInN0YXJ0IiwiZ2V0Tm9kZUFuZE9mZnNldEZvclBvc2l0aW9uIiwic2V0U3RhcnQiLCJub2RlIiwib2Zmc2V0IiwiZW5kIiwic2V0RW5kIiwiYWRkUmFuZ2UiLCJjYXJldFBvc2l0aW9uIiwiaXNFbXB0eSIsImNvbGxhcHNlIiwicmFuZ2VDb3VudCIsImV4aXN0aW5nUmFuZ2UiLCJnZXRSYW5nZUF0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImNvbGxhcHNlZCIsInBvc2l0aW9uIiwibGluZUluZGV4Iiwibm9kZUluZGV4IiwiZ2V0TGluZUFuZE5vZGVQb3NpdGlvbiIsImxpbmVOb2RlIiwiY2hpbGROb2RlcyIsImZvY3VzTm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImZpcnN0Q2hpbGQiLCJwYXJ0cyIsInBhcnRJbmRleCIsImluZGV4IiwibGluZVJlc3VsdCIsImZpbmROb2RlSW5MaW5lRm9yUGFydCIsIm1vdmVPdXRPZlVuc2VsZWN0YWJsZVBhcnQiLCJwcmV2UGFydCIsImkiLCJwYXJ0IiwidHlwZSIsIlR5cGUiLCJOZXdsaW5lIiwibmVlZHNDYXJldE5vZGVCZWZvcmUiLCJuZXh0UGFydCIsImlzTGFzdE9mTGluZSIsIm5lZWRzQ2FyZXROb2RlQWZ0ZXIiLCJhY2NlcHRzQ2FyZXQiLCJ0ZXh0IiwibGVuZ3RoIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2VkaXRvci9jYXJldC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgTmV3IFZlY3RvciBMdGRcbkNvcHlyaWdodCAyMDE5IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgbmVlZHNDYXJldE5vZGVCZWZvcmUsIG5lZWRzQ2FyZXROb2RlQWZ0ZXIgfSBmcm9tIFwiLi9yZW5kZXJcIjtcbmltcG9ydCBSYW5nZSBmcm9tIFwiLi9yYW5nZVwiO1xuaW1wb3J0IEVkaXRvck1vZGVsIGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgRG9jdW1lbnRQb3NpdGlvbiwgeyBJUG9zaXRpb24gfSBmcm9tIFwiLi9wb3NpdGlvblwiO1xuaW1wb3J0IHsgUGFydCwgVHlwZSB9IGZyb20gXCIuL3BhcnRzXCI7XG5cbmV4cG9ydCB0eXBlIENhcmV0ID0gUmFuZ2UgfCBEb2N1bWVudFBvc2l0aW9uO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGVkaXRvcjogSFRNTERpdkVsZW1lbnQsIG1vZGVsOiBFZGl0b3JNb2RlbCwgc2VsZWN0aW9uOiBSYW5nZSB8IElQb3NpdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgICBzZXREb2N1bWVudFJhbmdlU2VsZWN0aW9uKGVkaXRvciwgbW9kZWwsIHNlbGVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIG1vZGVsLCBzZWxlY3Rpb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0RG9jdW1lbnRSYW5nZVNlbGVjdGlvbihlZGl0b3I6IEhUTUxEaXZFbGVtZW50LCBtb2RlbDogRWRpdG9yTW9kZWwsIHJhbmdlOiBSYW5nZSkge1xuICAgIGNvbnN0IHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXROb2RlQW5kT2Zmc2V0Rm9yUG9zaXRpb24oZWRpdG9yLCBtb2RlbCwgcmFuZ2Uuc3RhcnQpO1xuICAgIHNlbGVjdGlvblJhbmdlLnNldFN0YXJ0KHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgY29uc3QgZW5kID0gZ2V0Tm9kZUFuZE9mZnNldEZvclBvc2l0aW9uKGVkaXRvciwgbW9kZWwsIHJhbmdlLmVuZCk7XG4gICAgc2VsZWN0aW9uUmFuZ2Uuc2V0RW5kKGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICBzZWwuYWRkUmFuZ2Uoc2VsZWN0aW9uUmFuZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3I6IEhUTUxEaXZFbGVtZW50LCBtb2RlbDogRWRpdG9yTW9kZWwsIGNhcmV0UG9zaXRpb246IElQb3NpdGlvbikge1xuICAgIGlmIChtb2RlbC5pc0VtcHR5KSByZXR1cm47IC8vIHNlbGVjdGlvbiBjYW4ndCBwb3NzaWJseSBiZSB3cm9uZywgc28gYXZvaWQgYSByZWZsb3dcblxuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBjb25zdCB7IG5vZGUsIG9mZnNldCB9ID0gZ2V0Tm9kZUFuZE9mZnNldEZvclBvc2l0aW9uKGVkaXRvciwgbW9kZWwsIGNhcmV0UG9zaXRpb24pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG5cbiAgICBjb25zdCBzZWwgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsLnJhbmdlQ291bnQgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBleGlzdGluZ1JhbmdlLnN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5zdGFydENvbnRhaW5lciAmJlxuICAgICAgICAgICAgZXhpc3RpbmdSYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2Uuc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nUmFuZ2UuY29sbGFwc2VkID09PSByYW5nZS5jb2xsYXBzZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIG1hdGNoZXMsIGl0J3MgaW1wb3J0YW50IHRvIGxlYXZlIGl0IGFsb25lLlxuICAgICAgICAgICAgLy8gUmVjcmVhdGluZyB0aGUgc2VsZWN0aW9uIHN0YXRlIGluIGF0IGxlYXN0IENocm9tZSBjYW4gY2F1c2VcbiAgICAgICAgICAgIC8vIHN0cmFuZ2Ugc2lkZSBlZmZlY3RzLCBsaWtlIHRvdWNoIGJhciBmbGlja2VyaW5nIG9uIGV2ZXJ5IGtleS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL2VsZW1lbnQtd2ViL2lzc3Vlcy85Mjk5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVBbmRPZmZzZXRGb3JQb3NpdGlvbihlZGl0b3I6IEhUTUxEaXZFbGVtZW50LCBtb2RlbDogRWRpdG9yTW9kZWwsIHBvc2l0aW9uOiBJUG9zaXRpb24pIHtcbiAgICBjb25zdCB7IG9mZnNldCwgbGluZUluZGV4LCBub2RlSW5kZXggfSA9IGdldExpbmVBbmROb2RlUG9zaXRpb24obW9kZWwsIHBvc2l0aW9uKTtcbiAgICBjb25zdCBsaW5lTm9kZSA9IGVkaXRvci5jaGlsZE5vZGVzW2xpbmVJbmRleF07XG5cbiAgICBsZXQgZm9jdXNOb2RlO1xuICAgIC8vIGVtcHR5IGxpbmUgd2l0aCBqdXN0IGEgPGJyPlxuICAgIGlmIChub2RlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGZvY3VzTm9kZSA9IGxpbmVOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzTm9kZSA9IGxpbmVOb2RlLmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKGZvY3VzTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGU6IGZvY3VzTm9kZSwgb2Zmc2V0IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lQW5kTm9kZVBvc2l0aW9uKG1vZGVsOiBFZGl0b3JNb2RlbCwgY2FyZXRQb3NpdGlvbjogSVBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBwYXJ0cyB9ID0gbW9kZWw7XG4gICAgY29uc3QgcGFydEluZGV4ID0gY2FyZXRQb3NpdGlvbi5pbmRleDtcbiAgICBjb25zdCBsaW5lUmVzdWx0ID0gZmluZE5vZGVJbkxpbmVGb3JQYXJ0KHBhcnRzLCBwYXJ0SW5kZXgpO1xuICAgIGNvbnN0IHsgbGluZUluZGV4IH0gPSBsaW5lUmVzdWx0O1xuICAgIGxldCB7IG5vZGVJbmRleCB9ID0gbGluZVJlc3VsdDtcbiAgICBsZXQgeyBvZmZzZXQgfSA9IGNhcmV0UG9zaXRpb247XG4gICAgLy8gd2UncmUgYXQgYW4gZW1wdHkgbGluZSBiZXR3ZWVuIGEgbmV3bGluZSBwYXJ0XG4gICAgLy8gYW5kIGFub3RoZXIgbmV3bGluZSBwYXJ0IG9yIGVuZC9zdGFydCBvZiBwYXJ0cy5cbiAgICAvLyBzZXQgb2Zmc2V0IHRvIDAgc28gaXQgZ2V0cyBzZXQgdG8gdGhlIDxicj4gaW5zaWRlIHRoZSBsaW5lIGNvbnRhaW5lclxuICAgIGlmIChub2RlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSBjYXJldCBvdXQgb2YgdW5lZGl0YWJsZSBwYXJ0IChpbnRvIGNhcmV0IG5vZGUsIG9yIGVtcHR5IGxpbmUgYnIpIGlmIG5lZWRlZFxuICAgICAgICAoeyBub2RlSW5kZXgsIG9mZnNldCB9ID0gbW92ZU91dE9mVW5zZWxlY3RhYmxlUGFydChwYXJ0cywgcGFydEluZGV4LCBub2RlSW5kZXgsIG9mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4geyBsaW5lSW5kZXgsIG5vZGVJbmRleCwgb2Zmc2V0IH07XG59XG5cbmZ1bmN0aW9uIGZpbmROb2RlSW5MaW5lRm9yUGFydChwYXJ0czogUGFydFtdLCBwYXJ0SW5kZXg6IG51bWJlcikge1xuICAgIGxldCBsaW5lSW5kZXggPSAwO1xuICAgIGxldCBub2RlSW5kZXggPSAtMTtcblxuICAgIGxldCBwcmV2UGFydCA9IG51bGw7XG4gICAgLy8gZ28gdGhyb3VnaCB0byBwYXJ0cyB1cCB0aWxsIChhbmQgaW5jbHVkaW5nKSB0aGUgaW5kZXhcbiAgICAvLyB0byBmaW5kIG5ld2xpbmUgcGFydHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXJ0SW5kZXg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFR5cGUuTmV3bGluZSkge1xuICAgICAgICAgICAgbGluZUluZGV4ICs9IDE7XG4gICAgICAgICAgICBub2RlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHByZXZQYXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKG5lZWRzQ2FyZXROb2RlQmVmb3JlKHBhcnQsIHByZXZQYXJ0KSkge1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBqdW1wIG92ZXIgY2FyZXQgbm9kZSBpZiB3ZSdyZSBub3QgYXQgb3VyIGRlc3RpbmF0aW9uIG5vZGUgYWxyZWFkeSxcbiAgICAgICAgICAgIC8vIGFzIHdlJ2xsIGFzc3VtZSBpbiBtb3ZlT3V0T2ZVbnNlbGVjdGFibGVQYXJ0IHRoYXQgbm9kZUluZGV4XG4gICAgICAgICAgICAvLyByZWZlcnMgdG8gdGhlIG5vZGUgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBhcnQsXG4gICAgICAgICAgICAvLyBhbmQgbm90IGFuIGFkamFjZW50IGNhcmV0IG5vZGVcbiAgICAgICAgICAgIGlmIChpIDwgcGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNMYXN0T2ZMaW5lID0gIW5leHRQYXJ0IHx8IG5leHRQYXJ0LnR5cGUgPT09IFR5cGUuTmV3bGluZTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZHNDYXJldE5vZGVBZnRlcihwYXJ0LCBpc0xhc3RPZkxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQYXJ0ID0gcGFydDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGxpbmVJbmRleCwgbm9kZUluZGV4IH07XG59XG5cbmZ1bmN0aW9uIG1vdmVPdXRPZlVuc2VsZWN0YWJsZVBhcnQocGFydHM6IFBhcnRbXSwgcGFydEluZGV4OiBudW1iZXIsIG5vZGVJbmRleDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlcikge1xuICAgIC8vIG1vdmUgY2FyZXQgYmVmb3JlIG9yIGFmdGVyIHVuc2VsZWN0YWJsZSBwYXJ0XG4gICAgY29uc3QgcGFydCA9IHBhcnRzW3BhcnRJbmRleF07XG4gICAgaWYgKHBhcnQgJiYgIXBhcnQuYWNjZXB0c0NhcmV0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIG5vZGVJbmRleCAtPSAxO1xuICAgICAgICAgICAgY29uc3QgcHJldlBhcnQgPSBwYXJ0c1twYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBub2RlIGlzIGEgY2FyZXQgbm9kZSwgaXQncyBlbXB0eVxuICAgICAgICAgICAgLy8gc28gdGhlIG9mZnNldCBjYW4gc3RheSBhdCAwXG4gICAgICAgICAgICAvLyBvbmx5IHdoZW4gaXQncyBub3QsIHdlIG5lZWQgdG8gc2V0IHRoZSBvZmZzZXRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGVcbiAgICAgICAgICAgIGlmICghbmVlZHNDYXJldE5vZGVCZWZvcmUocGFydCwgcHJldlBhcnQpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJldlBhcnQudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlSW5kZXggKz0gMTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZUluZGV4LCBvZmZzZXQgfTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBQ0E7O0FBR0E7O0FBckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVU8sU0FBU0EsWUFBVCxDQUFzQkMsTUFBdEIsRUFBOENDLEtBQTlDLEVBQWtFQyxTQUFsRSxFQUFnRztFQUNuRyxJQUFJQSxTQUFTLFlBQVlDLGNBQXpCLEVBQWdDO0lBQzVCQyx5QkFBeUIsQ0FBQ0osTUFBRCxFQUFTQyxLQUFULEVBQWdCQyxTQUFoQixDQUF6QjtFQUNILENBRkQsTUFFTztJQUNIRyxnQkFBZ0IsQ0FBQ0wsTUFBRCxFQUFTQyxLQUFULEVBQWdCQyxTQUFoQixDQUFoQjtFQUNIO0FBQ0o7O0FBRUQsU0FBU0UseUJBQVQsQ0FBbUNKLE1BQW5DLEVBQTJEQyxLQUEzRCxFQUErRUssS0FBL0UsRUFBNkY7RUFDekYsTUFBTUMsR0FBRyxHQUFHQyxRQUFRLENBQUNDLFlBQVQsRUFBWjtFQUNBRixHQUFHLENBQUNHLGVBQUo7RUFDQSxNQUFNQyxjQUFjLEdBQUdILFFBQVEsQ0FBQ0ksV0FBVCxFQUF2QjtFQUNBLE1BQU1DLEtBQUssR0FBR0MsMkJBQTJCLENBQUNkLE1BQUQsRUFBU0MsS0FBVCxFQUFnQkssS0FBSyxDQUFDTyxLQUF0QixDQUF6QztFQUNBRixjQUFjLENBQUNJLFFBQWYsQ0FBd0JGLEtBQUssQ0FBQ0csSUFBOUIsRUFBb0NILEtBQUssQ0FBQ0ksTUFBMUM7RUFDQSxNQUFNQyxHQUFHLEdBQUdKLDJCQUEyQixDQUFDZCxNQUFELEVBQVNDLEtBQVQsRUFBZ0JLLEtBQUssQ0FBQ1ksR0FBdEIsQ0FBdkM7RUFDQVAsY0FBYyxDQUFDUSxNQUFmLENBQXNCRCxHQUFHLENBQUNGLElB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