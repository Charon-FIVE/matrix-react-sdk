"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDisplayAliasForAliasSet = getDisplayAliasForAliasSet;
exports.getDisplayAliasForRoom = getDisplayAliasForRoom;
exports.guessAndSetDMRoom = guessAndSetDMRoom;
exports.setDMRoom = setDMRoom;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _event = require("matrix-js-sdk/src/@types/event");

var _MatrixClientPeg = require("./MatrixClientPeg");

var _Alias = _interopRequireDefault(require("./customisations/Alias"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Given a room object, return the alias we should use for it,
 * if any. This could be the canonical alias if one exists, otherwise
 * an alias selected arbitrarily but deterministically from the list
 * of aliases. Otherwise return null;
 *
 * @param {Object} room The room object
 * @returns {string} A display alias for the given room
 */
function getDisplayAliasForRoom(room) {
  return getDisplayAliasForAliasSet(room.getCanonicalAlias(), room.getAltAliases());
} // The various display alias getters should all feed through this one path so
// there's a single place to change the logic.


function getDisplayAliasForAliasSet(canonicalAlias, altAliases) {
  if (_Alias.default.getDisplayAliasForAliasSet) {
    return _Alias.default.getDisplayAliasForAliasSet(canonicalAlias, altAliases);
  }

  return canonicalAlias || altAliases?.[0];
}

function guessAndSetDMRoom(room, isDirect) {
  let newTarget;

  if (isDirect) {
    const guessedUserId = guessDMRoomTargetId(room, _MatrixClientPeg.MatrixClientPeg.get().getUserId());
    newTarget = guessedUserId;
  } else {
    newTarget = null;
  }

  return setDMRoom(room.roomId, newTarget);
}
/**
 * Marks or unmarks the given room as being as a DM room.
 * @param {string} roomId The ID of the room to modify
 * @param {string} userId The user ID of the desired DM
 room target user or null to un-mark
 this room as a DM room
 * @returns {object} A promise
 */


async function setDMRoom(roomId, userId) {
  if (_MatrixClientPeg.MatrixClientPeg.get().isGuest()) return;

  const mDirectEvent = _MatrixClientPeg.MatrixClientPeg.get().getAccountData(_event.EventType.Direct);

  let dmRoomMap = {};
  if (mDirectEvent !== undefined) dmRoomMap = _objectSpread({}, mDirectEvent.getContent()); // copy as we will mutate
  // remove it from the lists of any others users
  // (it can only be a DM room for one person)

  for (const thisUserId of Object.keys(dmRoomMap)) {
    const roomList = dmRoomMap[thisUserId];

    if (thisUserId != userId) {
      const indexOfRoom = roomList.indexOf(roomId);

      if (indexOfRoom > -1) {
        roomList.splice(indexOfRoom, 1);
      }
    }
  } // now add it, if it's not already there


  if (userId) {
    const roomList = dmRoomMap[userId] || [];

    if (roomList.indexOf(roomId) == -1) {
      roomList.push(roomId);
    }

    dmRoomMap[userId] = roomList;
  }

  await _MatrixClientPeg.MatrixClientPeg.get().setAccountData(_event.EventType.Direct, dmRoomMap);
}
/**
 * Given a room, estimate which of its members is likely to
 * be the target if the room were a DM room and return that user.
 *
 * @param {Object} room Target room
 * @param {string} myUserId User ID of the current user
 * @returns {string} User ID of the user that the room is probably a DM with
 */


function guessDMRoomTargetId(room, myUserId) {
  let oldestTs;
  let oldestUser; // Pick the joined user who's been here longest (and isn't us),

  for (const user of room.getJoinedMembers()) {
    if (user.userId == myUserId) continue;

    if (oldestTs === undefined || user.events.member && user.events.member.getTs() < oldestTs) {
      oldestUser = user;
      oldestTs = user.events.member.getTs();
    }
  }

  if (oldestUser) return oldestUser.userId; // if there are no joined members other than us, use the oldest member

  for (const user of room.currentState.getMembers()) {
    if (user.userId == myUserId) continue;

    if (oldestTs === undefined || user.events.member && user.events.member.getTs() < oldestTs) {
      oldestUser = user;
      oldestTs = user.events.member.getTs();
    }
  }

  if (oldestUser === undefined) return myUserId;
  return oldestUser.userId;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXREaXNwbGF5QWxpYXNGb3JSb29tIiwicm9vbSIsImdldERpc3BsYXlBbGlhc0ZvckFsaWFzU2V0IiwiZ2V0Q2Fub25pY2FsQWxpYXMiLCJnZXRBbHRBbGlhc2VzIiwiY2Fub25pY2FsQWxpYXMiLCJhbHRBbGlhc2VzIiwiQWxpYXNDdXN0b21pc2F0aW9ucyIsImd1ZXNzQW5kU2V0RE1Sb29tIiwiaXNEaXJlY3QiLCJuZXdUYXJnZXQiLCJndWVzc2VkVXNlcklkIiwiZ3Vlc3NETVJvb21UYXJnZXRJZCIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsImdldFVzZXJJZCIsInNldERNUm9vbSIsInJvb21JZCIsInVzZXJJZCIsImlzR3Vlc3QiLCJtRGlyZWN0RXZlbnQiLCJnZXRBY2NvdW50RGF0YSIsIkV2ZW50VHlwZSIsIkRpcmVjdCIsImRtUm9vbU1hcCIsInVuZGVmaW5lZCIsImdldENvbnRlbnQiLCJ0aGlzVXNlcklkIiwiT2JqZWN0Iiwia2V5cyIsInJvb21MaXN0IiwiaW5kZXhPZlJvb20iLCJpbmRleE9mIiwic3BsaWNlIiwicHVzaCIsInNldEFjY291bnREYXRhIiwibXlVc2VySWQiLCJvbGRlc3RUcyIsIm9sZGVzdFVzZXIiLCJ1c2VyIiwiZ2V0Sm9pbmVkTWVtYmVycyIsImV2ZW50cyIsIm1lbWJlciIsImdldFRzIiwiY3VycmVudFN0YXRlIiwiZ2V0TWVtYmVycyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9Sb29tcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTUgLSAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgUm9vbSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbVwiO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL0B0eXBlcy9ldmVudFwiO1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuL01hdHJpeENsaWVudFBlZyc7XG5pbXBvcnQgQWxpYXNDdXN0b21pc2F0aW9ucyBmcm9tICcuL2N1c3RvbWlzYXRpb25zL0FsaWFzJztcblxuLyoqXG4gKiBHaXZlbiBhIHJvb20gb2JqZWN0LCByZXR1cm4gdGhlIGFsaWFzIHdlIHNob3VsZCB1c2UgZm9yIGl0LFxuICogaWYgYW55LiBUaGlzIGNvdWxkIGJlIHRoZSBjYW5vbmljYWwgYWxpYXMgaWYgb25lIGV4aXN0cywgb3RoZXJ3aXNlXG4gKiBhbiBhbGlhcyBzZWxlY3RlZCBhcmJpdHJhcmlseSBidXQgZGV0ZXJtaW5pc3RpY2FsbHkgZnJvbSB0aGUgbGlzdFxuICogb2YgYWxpYXNlcy4gT3RoZXJ3aXNlIHJldHVybiBudWxsO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByb29tIFRoZSByb29tIG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ30gQSBkaXNwbGF5IGFsaWFzIGZvciB0aGUgZ2l2ZW4gcm9vbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheUFsaWFzRm9yUm9vbShyb29tOiBSb29tKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0RGlzcGxheUFsaWFzRm9yQWxpYXNTZXQoXG4gICAgICAgIHJvb20uZ2V0Q2Fub25pY2FsQWxpYXMoKSwgcm9vbS5nZXRBbHRBbGlhc2VzKCksXG4gICAgKTtcbn1cblxuLy8gVGhlIHZhcmlvdXMgZGlzcGxheSBhbGlhcyBnZXR0ZXJzIHNob3VsZCBhbGwgZmVlZCB0aHJvdWdoIHRoaXMgb25lIHBhdGggc29cbi8vIHRoZXJlJ3MgYSBzaW5nbGUgcGxhY2UgdG8gY2hhbmdlIHRoZSBsb2dpYy5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5QWxpYXNGb3JBbGlhc1NldChjYW5vbmljYWxBbGlhczogc3RyaW5nLCBhbHRBbGlhc2VzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgaWYgKEFsaWFzQ3VzdG9taXNhdGlvbnMuZ2V0RGlzcGxheUFsaWFzRm9yQWxpYXNTZXQpIHtcbiAgICAgICAgcmV0dXJuIEFsaWFzQ3VzdG9taXNhdGlvbnMuZ2V0RGlzcGxheUFsaWFzRm9yQWxpYXNTZXQoY2Fub25pY2FsQWxpYXMsIGFsdEFsaWFzZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2Fub25pY2FsQWxpYXMgfHwgYWx0QWxpYXNlcz8uWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3Vlc3NBbmRTZXRETVJvb20ocm9vbTogUm9vbSwgaXNEaXJlY3Q6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgbmV3VGFyZ2V0O1xuICAgIGlmIChpc0RpcmVjdCkge1xuICAgICAgICBjb25zdCBndWVzc2VkVXNlcklkID0gZ3Vlc3NETVJvb21UYXJnZXRJZChcbiAgICAgICAgICAgIHJvb20sIE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRVc2VySWQoKSxcbiAgICAgICAgKTtcbiAgICAgICAgbmV3VGFyZ2V0ID0gZ3Vlc3NlZFVzZXJJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdUYXJnZXQgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRETVJvb20ocm9vbS5yb29tSWQsIG5ld1RhcmdldCk7XG59XG5cbi8qKlxuICogTWFya3Mgb3IgdW5tYXJrcyB0aGUgZ2l2ZW4gcm9vbSBhcyBiZWluZyBhcyBhIERNIHJvb20uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbUlkIFRoZSBJRCBvZiB0aGUgcm9vbSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIGRlc2lyZWQgRE1cbiByb29tIHRhcmdldCB1c2VyIG9yIG51bGwgdG8gdW4tbWFya1xuIHRoaXMgcm9vbSBhcyBhIERNIHJvb21cbiAqIEByZXR1cm5zIHtvYmplY3R9IEEgcHJvbWlzZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0RE1Sb29tKHJvb21JZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChNYXRyaXhDbGllbnRQZWcuZ2V0KCkuaXNHdWVzdCgpKSByZXR1cm47XG5cbiAgICBjb25zdCBtRGlyZWN0RXZlbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0QWNjb3VudERhdGEoRXZlbnRUeXBlLkRpcmVjdCk7XG4gICAgbGV0IGRtUm9vbU1hcCA9IHt9O1xuXG4gICAgaWYgKG1EaXJlY3RFdmVudCAhPT0gdW5kZWZpbmVkKSBkbVJvb21NYXAgPSB7IC4uLm1EaXJlY3RFdmVudC5nZXRDb250ZW50KCkgfTsgLy8gY29weSBhcyB3ZSB3aWxsIG11dGF0ZVxuXG4gICAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RzIG9mIGFueSBvdGhlcnMgdXNlcnNcbiAgICAvLyAoaXQgY2FuIG9ubHkgYmUgYSBETSByb29tIGZvciBvbmUgcGVyc29uKVxuICAgIGZvciAoY29uc3QgdGhpc1VzZXJJZCBvZiBPYmplY3Qua2V5cyhkbVJvb21NYXApKSB7XG4gICAgICAgIGNvbnN0IHJvb21MaXN0ID0gZG1Sb29tTWFwW3RoaXNVc2VySWRdO1xuXG4gICAgICAgIGlmICh0aGlzVXNlcklkICE9IHVzZXJJZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhPZlJvb20gPSByb29tTGlzdC5pbmRleE9mKHJvb21JZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZlJvb20gPiAtMSkge1xuICAgICAgICAgICAgICAgIHJvb21MaXN0LnNwbGljZShpbmRleE9mUm9vbSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgYWRkIGl0LCBpZiBpdCdzIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgICBjb25zdCByb29tTGlzdCA9IGRtUm9vbU1hcFt1c2VySWRdIHx8IFtdO1xuICAgICAgICBpZiAocm9vbUxpc3QuaW5kZXhPZihyb29tSWQpID09IC0xKSB7XG4gICAgICAgICAgICByb29tTGlzdC5wdXNoKHJvb21JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZG1Sb29tTWFwW3VzZXJJZF0gPSByb29tTGlzdDtcbiAgICB9XG5cbiAgICBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuc2V0QWNjb3VudERhdGEoRXZlbnRUeXBlLkRpcmVjdCwgZG1Sb29tTWFwKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHJvb20sIGVzdGltYXRlIHdoaWNoIG9mIGl0cyBtZW1iZXJzIGlzIGxpa2VseSB0b1xuICogYmUgdGhlIHRhcmdldCBpZiB0aGUgcm9vbSB3ZXJlIGEgRE0gcm9vbSBhbmQgcmV0dXJuIHRoYXQgdXNlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcm9vbSBUYXJnZXQgcm9vbVxuICogQHBhcmFtIHtzdHJpbmd9IG15VXNlcklkIFVzZXIgSUQgb2YgdGhlIGN1cnJlbnQgdXNlclxuICogQHJldHVybnMge3N0cmluZ30gVXNlciBJRCBvZiB0aGUgdXNlciB0aGF0IHRoZSByb29tIGlzIHByb2JhYmx5IGEgRE0gd2l0aFxuICovXG5mdW5jdGlvbiBndWVzc0RNUm9vbVRhcmdldElkKHJvb206IFJvb20sIG15VXNlcklkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCBvbGRlc3RUcztcbiAgICBsZXQgb2xkZXN0VXNlcjtcblxuICAgIC8vIFBpY2sgdGhlIGpvaW5lZCB1c2VyIHdobydzIGJlZW4gaGVyZSBsb25nZXN0IChhbmQgaXNuJ3QgdXMpLFxuICAgIGZvciAoY29uc3QgdXNlciBvZiByb29tLmdldEpvaW5lZE1lbWJlcnMoKSkge1xuICAgICAgICBpZiAodXNlci51c2VySWQgPT0gbXlVc2VySWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChvbGRlc3RUcyA9PT0gdW5kZWZpbmVkIHx8ICh1c2VyLmV2ZW50cy5tZW1iZXIgJiYgdXNlci5ldmVudHMubWVtYmVyLmdldFRzKCkgPCBvbGRlc3RUcykpIHtcbiAgICAgICAgICAgIG9sZGVzdFVzZXIgPSB1c2VyO1xuICAgICAgICAgICAgb2xkZXN0VHMgPSB1c2VyLmV2ZW50cy5tZW1iZXIuZ2V0VHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkZXN0VXNlcikgcmV0dXJuIG9sZGVzdFVzZXIudXNlcklkO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIGpvaW5lZCBtZW1iZXJzIG90aGVyIHRoYW4gdXMsIHVzZSB0aGUgb2xkZXN0IG1lbWJlclxuICAgIGZvciAoY29uc3QgdXNlciBvZiByb29tLmN1cnJlbnRTdGF0ZS5nZXRNZW1iZXJzKCkpIHtcbiAgICAgICAgaWYgKHVzZXIudXNlcklkID09IG15VXNlcklkKSBjb250aW51ZTtcblxuICAgICAgICBpZiAob2xkZXN0VHMgPT09IHVuZGVmaW5lZCB8fCAodXNlci5ldmVudHMubWVtYmVyICYmIHVzZXIuZXZlbnRzLm1lbWJlci5nZXRUcygpIDwgb2xkZXN0VHMpKSB7XG4gICAgICAgICAgICBvbGRlc3RVc2VyID0gdXNlcjtcbiAgICAgICAgICAgIG9sZGVzdFRzID0gdXNlci5ldmVudHMubWVtYmVyLmdldFRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2xkZXN0VXNlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbXlVc2VySWQ7XG4gICAgcmV0dXJuIG9sZGVzdFVzZXIudXNlcklkO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQWlCQTs7QUFFQTs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0Esc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQW9EO0VBQ3ZELE9BQU9DLDBCQUEwQixDQUM3QkQsSUFBSSxDQUFDRSxpQkFBTCxFQUQ2QixFQUNIRixJQUFJLENBQUNHLGFBQUwsRUFERyxDQUFqQztBQUdILEMsQ0FFRDtBQUNBOzs7QUFDTyxTQUFTRiwwQkFBVCxDQUFvQ0csY0FBcEMsRUFBNERDLFVBQTVELEVBQTBGO0VBQzdGLElBQUlDLGNBQUEsQ0FBb0JMLDBCQUF4QixFQUFvRDtJQUNoRCxPQUFPSyxjQUFBLENBQW9CTCwwQkFBcEIsQ0FBK0NHLGNBQS9DLEVBQStEQyxVQUEvRCxDQUFQO0VBQ0g7O0VBQ0QsT0FBT0QsY0FBYyxJQUFJQyxVQUFVLEdBQUcsQ0FBSCxDQUFuQztBQUNIOztBQUVNLFNBQVNFLGlCQUFULENBQTJCUCxJQUEzQixFQUF1Q1EsUUFBdkMsRUFBeUU7RUFDNUUsSUFBSUMsU0FBSjs7RUFDQSxJQUFJRCxRQUFKLEVBQWM7SUFDVixNQUFNRSxhQUFhLEdBQUdDLG1CQUFtQixDQUNyQ1gsSUFEcUMsRUFDL0JZLGdDQUFBLENBQWdCQyxHQUFoQixHQUFzQkMsU0FBdEIsRUFEK0IsQ0FBekM7SUFHQUwsU0FBUyxHQUFHQyxhQUFaO0VBQ0gsQ0FMRCxNQUtPO0lBQ0hELFNBQVMsR0FBRyxJQUFaO0VBQ0g7O0VBRUQsT0FBT00sU0FBUyxDQUFD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