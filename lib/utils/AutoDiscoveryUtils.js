"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _autodiscovery = require("matrix-js-sdk/src/autodiscovery");

var _logger = require("matrix-js-sdk/src/logger");

var _languageHandler = require("../languageHandler");

var _TypeUtils = require("./TypeUtils");

var _SdkConfig = _interopRequireDefault(require("../SdkConfig"));

var _ValidatedServerConfig = require("./ValidatedServerConfig");

/*
Copyright 2019-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const LIVELINESS_DISCOVERY_ERRORS = [_autodiscovery.AutoDiscovery.ERROR_INVALID_HOMESERVER, _autodiscovery.AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER];

class AutoDiscoveryUtils {
  /**
   * Checks if a given error or error message is considered an error
   * relating to the liveliness of the server. Must be an error returned
   * from this AutoDiscoveryUtils class.
   * @param {string | Error} error The error to check
   * @returns {boolean} True if the error is a liveliness error.
   */
  static isLivelinessError(error) {
    if (!error) return false;
    return !!LIVELINESS_DISCOVERY_ERRORS.find(e => typeof error === "string" ? e === error : e === error.message);
  }
  /**
   * Gets the common state for auth components (login, registration, forgot
   * password) for a given validation error.
   * @param {Error} err The error encountered.
   * @param {string} pageName The page for which the error should be customized to. See
   * implementation for known values.
   * @returns {*} The state for the component, given the error.
   */


  static authComponentStateForError(err) {
    let pageName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "login";

    if (!err) {
      return {
        serverIsAlive: true,
        serverErrorIsFatal: false,
        serverDeadError: null
      };
    }

    let title = (0, _languageHandler._t)("Cannot reach homeserver");
    let body = (0, _languageHandler._t)("Ensure you have a stable internet connection, or get in touch with the server admin");

    if (!AutoDiscoveryUtils.isLivelinessError(err)) {
      const brand = _SdkConfig.default.get().brand;

      title = (0, _languageHandler._t)("Your %(brand)s is misconfigured", {
        brand
      });
      body = (0, _languageHandler._t)("Ask your %(brand)s admin to check <a>your config</a> for incorrect or duplicate entries.", {
        brand
      }, {
        a: sub => {
          return /*#__PURE__*/_react.default.createElement("a", {
            href: "https://github.com/vector-im/element-web/blob/master/docs/config.md",
            target: "_blank",
            rel: "noreferrer noopener"
          }, sub);
        }
      });
    }

    let isFatalError = true;
    const errorMessage = typeof err === "string" ? err : err.message;

    if (errorMessage === _autodiscovery.AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER) {
      isFatalError = false;
      title = (0, _languageHandler._t)("Cannot reach identity server"); // It's annoying having a ladder for the third word in the same sentence, but our translations
      // don't make this easy to avoid.

      if (pageName === "register") {
        body = (0, _languageHandler._t)("You can register, but some features will be unavailable until the identity server is " + "back online. If you keep seeing this warning, check your configuration or contact a server " + "admin.");
      } else if (pageName === "reset_password") {
        body = (0, _languageHandler._t)("You can reset your password, but some features will be unavailable until the identity " + "server is back online. If you keep seeing this warning, check your configuration or contact " + "a server admin.");
      } else {
        body = (0, _languageHandler._t)("You can log in, but some features will be unavailable until the identity server is " + "back online. If you keep seeing this warning, check your configuration or contact a server " + "admin.");
      }
    }

    return {
      serverIsAlive: false,
      serverErrorIsFatal: isFatalError,
      serverDeadError: /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("strong", null, title), /*#__PURE__*/_react.default.createElement("div", null, body))
    };
  }
  /**
   * Validates a server configuration, using a pair of URLs as input.
   * @param {string} homeserverUrl The homeserver URL.
   * @param {string} identityUrl The identity server URL.
   * @param {boolean} syntaxOnly If true, errors relating to liveliness of the servers will
   * not be raised.
   * @returns {Promise<ValidatedServerConfig>} Resolves to the validated configuration.
   */


  static async validateServerConfigWithStaticUrls(homeserverUrl, identityUrl) {
    let syntaxOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!homeserverUrl) {
      throw (0, _languageHandler.newTranslatableError)((0, _languageHandler._td)("No homeserver URL provided"));
    }

    const wellknownConfig = {
      "m.homeserver": {
        base_url: homeserverUrl
      }
    };

    if (identityUrl) {
      wellknownConfig['m.identity_server'] = {
        base_url: identityUrl
      };
    }

    const result = await _autodiscovery.AutoDiscovery.fromDiscoveryConfig(wellknownConfig);
    const url = new URL(homeserverUrl);
    const serverName = url.hostname;
    return AutoDiscoveryUtils.buildValidatedConfigFromDiscovery(serverName, result, syntaxOnly, true);
  }
  /**
   * Validates a server configuration, using a homeserver domain name as input.
   * @param {string} serverName The homeserver domain name (eg: "matrix.org") to validate.
   * @returns {Promise<ValidatedServerConfig>} Resolves to the validated configuration.
   */


  static async validateServerName(serverName) {
    const result = await _autodiscovery.AutoDiscovery.findClientConfig(serverName);
    return AutoDiscoveryUtils.buildValidatedConfigFromDiscovery(serverName, result);
  }
  /**
   * Validates a server configuration, using a pre-calculated AutoDiscovery result as
   * input.
   * @param {string} serverName The domain name the AutoDiscovery result is for.
   * @param {*} discoveryResult The AutoDiscovery result.
   * @param {boolean} syntaxOnly If true, errors relating to liveliness of the servers will not be raised.
   * @param {boolean} isSynthetic If true, then the discoveryResult was synthesised locally.
   * @returns {Promise<ValidatedServerConfig>} Resolves to the validated configuration.
   */


  static buildValidatedConfigFromDiscovery(serverName, discoveryResult) {
    let syntaxOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let isSynthetic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (!discoveryResult || !discoveryResult["m.homeserver"]) {
      // This shouldn't happen without major misconfiguration, so we'll log a bit of information
      // in the log so we can find this bit of codee but otherwise tell teh user "it broke".
      _logger.logger.error("Ended up in a state of not knowing which homeserver to connect to.");

      throw (0, _languageHandler.newTranslatableError)((0, _languageHandler._td)("Unexpected error resolving homeserver configuration"));
    }

    const hsResult = discoveryResult['m.homeserver'];
    const isResult = discoveryResult['m.identity_server'];

    const defaultConfig = _SdkConfig.default.get("validated_server_config"); // Validate the identity server first because an invalid identity server causes
    // an invalid homeserver, which may not be picked up correctly.
    // Note: In the cases where we rely on the default IS from the config (namely
    // lack of identity server provided by the discovery method), we intentionally do not
    // validate it. This has already been validated and this helps some off-the-grid usage
    // of Element.


    let preferredIdentityUrl = defaultConfig && defaultConfig['isUrl'];

    if (isResult && isResult.state === _autodiscovery.AutoDiscovery.SUCCESS) {
      preferredIdentityUrl = isResult["base_url"];
    } else if (isResult && isResult.state !== _autodiscovery.AutoDiscovery.PROMPT) {
      _logger.logger.error("Error determining preferred identity server URL:", isResult);

      if (isResult.state === _autodiscovery.AutoDiscovery.FAIL_ERROR) {
        if (_autodiscovery.AutoDiscovery.ALL_ERRORS.indexOf(isResult.error) !== -1) {
          throw (0, _languageHandler.newTranslatableError)(isResult.error);
        }

        throw (0, _languageHandler.newTranslatableError)((0, _languageHandler._td)("Unexpected error resolving identity server configuration"));
      } // else the error is not related to syntax - continue anyways.
      // rewrite homeserver error since we don't care about problems


      hsResult.error = _autodiscovery.AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER; // Also use the user's supplied identity server if provided

      if (isResult["base_url"]) preferredIdentityUrl = isResult["base_url"];
    }

    if (hsResult.state !== _autodiscovery.AutoDiscovery.SUCCESS) {
      _logger.logger.error("Error processing homeserver config:", hsResult);

      if (!syntaxOnly || !AutoDiscoveryUtils.isLivelinessError(hsResult.error)) {
        if (_autodiscovery.AutoDiscovery.ALL_ERRORS.indexOf(hsResult.error) !== -1) {
          throw (0, _languageHandler.newTranslatableError)(hsResult.error);
        }

        throw (0, _languageHandler.newTranslatableError)((0, _languageHandler._td)("Unexpected error resolving homeserver configuration"));
      } // else the error is not related to syntax - continue anyways.

    }

    const preferredHomeserverUrl = hsResult["base_url"];
    let preferredHomeserverName = serverName ? serverName : hsResult["server_name"];
    const url = new URL(preferredHomeserverUrl);
    if (!preferredHomeserverName) preferredHomeserverName = url.hostname; // It should have been set by now, so check it

    if (!preferredHomeserverName) {
      _logger.logger.error("Failed to parse homeserver name from homeserver URL");

      throw (0, _languageHandler.newTranslatableError)((0, _languageHandler._td)("Unexpected error resolving homeserver configuration"));
    }

    return (0, _TypeUtils.makeType)(_ValidatedServerConfig.ValidatedServerConfig, {
      hsUrl: preferredHomeserverUrl,
      hsName: preferredHomeserverName,
      hsNameIsDifferent: url.hostname !== preferredHomeserverName,
      isUrl: preferredIdentityUrl,
      isDefault: false,
      warning: hsResult.error,
      isNameResolvable: !isSynthetic
    });
  }

}

exports.default = AutoDiscoveryUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJMSVZFTElORVNTX0RJU0NPVkVSWV9FUlJPUlMiLCJBdXRvRGlzY292ZXJ5IiwiRVJST1JfSU5WQUxJRF9IT01FU0VSVkVSIiwiRVJST1JfSU5WQUxJRF9JREVOVElUWV9TRVJWRVIiLCJBdXRvRGlzY292ZXJ5VXRpbHMiLCJpc0xpdmVsaW5lc3NFcnJvciIsImVycm9yIiwiZmluZCIsImUiLCJtZXNzYWdlIiwiYXV0aENvbXBvbmVudFN0YXRlRm9yRXJyb3IiLCJlcnIiLCJwYWdlTmFtZSIsInNlcnZlcklzQWxpdmUiLCJzZXJ2ZXJFcnJvcklzRmF0YWwiLCJzZXJ2ZXJEZWFkRXJyb3IiLCJ0aXRsZSIsIl90IiwiYm9keSIsImJyYW5kIiwiU2RrQ29uZmlnIiwiZ2V0IiwiYSIsInN1YiIsImlzRmF0YWxFcnJvciIsImVycm9yTWVzc2FnZSIsInZhbGlkYXRlU2VydmVyQ29uZmlnV2l0aFN0YXRpY1VybHMiLCJob21lc2VydmVyVXJsIiwiaWRlbnRpdHlVcmwiLCJzeW50YXhPbmx5IiwibmV3VHJhbnNsYXRhYmxlRXJyb3IiLCJfdGQiLCJ3ZWxsa25vd25Db25maWciLCJiYXNlX3VybCIsInJlc3VsdCIsImZyb21EaXNjb3ZlcnlDb25maWciLCJ1cmwiLCJVUkwiLCJzZXJ2ZXJOYW1lIiwiaG9zdG5hbWUiLCJidWlsZFZhbGlkYXRlZENvbmZpZ0Zyb21EaXNjb3ZlcnkiLCJ2YWxpZGF0ZVNlcnZlck5hbWUiLCJmaW5kQ2xpZW50Q29uZmlnIiwiZGlzY292ZXJ5UmVzdWx0IiwiaXNTeW50aGV0aWMiLCJsb2dnZXIiLCJoc1Jlc3VsdCIsImlzUmVzdWx0IiwiZGVmYXVsdENvbmZpZyIsInByZWZlcnJlZElkZW50aXR5VXJsIiwic3RhdGUiLCJTVUNDRVNTIiwiUFJPTVBUIiwiRkFJTF9FUlJPUiIsIkFMTF9FUlJPUlMiLCJpbmRleE9mIiwicHJlZmVycmVkSG9tZXNlcnZlclVybCIsInByZWZlcnJlZEhvbWVzZXJ2ZXJOYW1lIiwibWFrZVR5cGUiLCJWYWxpZGF0ZWRTZXJ2ZXJDb25maWciLCJoc1VybCIsImhzTmFtZSIsImhzTmFtZUlzRGlmZmVyZW50IiwiaXNVcmwiLCJpc0RlZmF1bHQiLCJ3YXJuaW5nIiwiaXNOYW1lUmVzb2x2YWJsZSJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9BdXRvRGlzY292ZXJ5VXRpbHMudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOS0yMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEF1dG9EaXNjb3ZlcnkgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvYXV0b2Rpc2NvdmVyeVwiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuXG5pbXBvcnQgeyBfdCwgX3RkLCBuZXdUcmFuc2xhdGFibGVFcnJvciB9IGZyb20gXCIuLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCB7IG1ha2VUeXBlIH0gZnJvbSBcIi4vVHlwZVV0aWxzXCI7XG5pbXBvcnQgU2RrQ29uZmlnIGZyb20gJy4uL1Nka0NvbmZpZyc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRTZXJ2ZXJDb25maWcgfSBmcm9tICcuL1ZhbGlkYXRlZFNlcnZlckNvbmZpZyc7XG5cbmNvbnN0IExJVkVMSU5FU1NfRElTQ09WRVJZX0VSUk9SUzogc3RyaW5nW10gPSBbXG4gICAgQXV0b0Rpc2NvdmVyeS5FUlJPUl9JTlZBTElEX0hPTUVTRVJWRVIsXG4gICAgQXV0b0Rpc2NvdmVyeS5FUlJPUl9JTlZBTElEX0lERU5USVRZX1NFUlZFUixcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF1dGhDb21wb25lbnRTdGF0ZSB7XG4gICAgc2VydmVySXNBbGl2ZTogYm9vbGVhbjtcbiAgICBzZXJ2ZXJFcnJvcklzRmF0YWw6IGJvb2xlYW47XG4gICAgc2VydmVyRGVhZEVycm9yPzogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvRGlzY292ZXJ5VXRpbHMge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIGVycm9yIG9yIGVycm9yIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCBhbiBlcnJvclxuICAgICAqIHJlbGF0aW5nIHRvIHRoZSBsaXZlbGluZXNzIG9mIHRoZSBzZXJ2ZXIuIE11c3QgYmUgYW4gZXJyb3IgcmV0dXJuZWRcbiAgICAgKiBmcm9tIHRoaXMgQXV0b0Rpc2NvdmVyeVV0aWxzIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgRXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIGxpdmVsaW5lc3MgZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGlzTGl2ZWxpbmVzc0Vycm9yKGVycm9yOiBzdHJpbmcgfCBFcnJvcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIWVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhIUxJVkVMSU5FU1NfRElTQ09WRVJZX0VSUk9SUy5maW5kKGUgPT4gdHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiID8gZSA9PT0gZXJyb3IgOiBlID09PSBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb21tb24gc3RhdGUgZm9yIGF1dGggY29tcG9uZW50cyAobG9naW4sIHJlZ2lzdHJhdGlvbiwgZm9yZ290XG4gICAgICogcGFzc3dvcmQpIGZvciBhIGdpdmVuIHZhbGlkYXRpb24gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciBlbmNvdW50ZXJlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFnZU5hbWUgVGhlIHBhZ2UgZm9yIHdoaWNoIHRoZSBlcnJvciBzaG91bGQgYmUgY3VzdG9taXplZCB0by4gU2VlXG4gICAgICogaW1wbGVtZW50YXRpb24gZm9yIGtub3duIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHN0YXRlIGZvciB0aGUgY29tcG9uZW50LCBnaXZlbiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGF1dGhDb21wb25lbnRTdGF0ZUZvckVycm9yKGVycjogc3RyaW5nIHwgRXJyb3IgfCBudWxsLCBwYWdlTmFtZSA9IFwibG9naW5cIik6IElBdXRoQ29tcG9uZW50U3RhdGUge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJJc0FsaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlcnZlckVycm9ySXNGYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VydmVyRGVhZEVycm9yOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGl0bGUgPSBfdChcIkNhbm5vdCByZWFjaCBob21lc2VydmVyXCIpO1xuICAgICAgICBsZXQgYm9keTogUmVhY3ROb2RlID0gX3QoXCJFbnN1cmUgeW91IGhhdmUgYSBzdGFibGUgaW50ZXJuZXQgY29ubmVjdGlvbiwgb3IgZ2V0IGluIHRvdWNoIHdpdGggdGhlIHNlcnZlciBhZG1pblwiKTtcbiAgICAgICAgaWYgKCFBdXRvRGlzY292ZXJ5VXRpbHMuaXNMaXZlbGluZXNzRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgY29uc3QgYnJhbmQgPSBTZGtDb25maWcuZ2V0KCkuYnJhbmQ7XG4gICAgICAgICAgICB0aXRsZSA9IF90KFwiWW91ciAlKGJyYW5kKXMgaXMgbWlzY29uZmlndXJlZFwiLCB7IGJyYW5kIH0pO1xuICAgICAgICAgICAgYm9keSA9IF90KFxuICAgICAgICAgICAgICAgIFwiQXNrIHlvdXIgJShicmFuZClzIGFkbWluIHRvIGNoZWNrIDxhPnlvdXIgY29uZmlnPC9hPiBmb3IgaW5jb3JyZWN0IG9yIGR1cGxpY2F0ZSBlbnRyaWVzLlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGE6IChzdWIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL2VsZW1lbnQtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29uZmlnLm1kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbD1cIm5vcmVmZXJyZXIgbm9vcGVuZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPnsgc3ViIH08L2E+O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzRmF0YWxFcnJvciA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09IFwic3RyaW5nXCIgPyBlcnIgOiBlcnIubWVzc2FnZTtcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSA9PT0gQXV0b0Rpc2NvdmVyeS5FUlJPUl9JTlZBTElEX0lERU5USVRZX1NFUlZFUikge1xuICAgICAgICAgICAgaXNGYXRhbEVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aXRsZSA9IF90KFwiQ2Fubm90IHJlYWNoIGlkZW50aXR5IHNlcnZlclwiKTtcblxuICAgICAgICAgICAgLy8gSXQncyBhbm5veWluZyBoYXZpbmcgYSBsYWRkZXIgZm9yIHRoZSB0aGlyZCB3b3JkIGluIHRoZSBzYW1lIHNlbnRlbmNlLCBidXQgb3VyIHRyYW5zbGF0aW9uc1xuICAgICAgICAgICAgLy8gZG9uJ3QgbWFrZSB0aGlzIGVhc3kgdG8gYXZvaWQuXG4gICAgICAgICAgICBpZiAocGFnZU5hbWUgPT09IFwicmVnaXN0ZXJcIikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBfdChcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgY2FuIHJlZ2lzdGVyLCBidXQgc29tZSBmZWF0dXJlcyB3aWxsIGJlIHVuYXZhaWxhYmxlIHVudGlsIHRoZSBpZGVudGl0eSBzZXJ2ZXIgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImJhY2sgb25saW5lLiBJZiB5b3Uga2VlcCBzZWVpbmcgdGhpcyB3YXJuaW5nLCBjaGVjayB5b3VyIGNvbmZpZ3VyYXRpb24gb3IgY29udGFjdCBhIHNlcnZlciBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYWRtaW4uXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFnZU5hbWUgPT09IFwicmVzZXRfcGFzc3dvcmRcIikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBfdChcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgY2FuIHJlc2V0IHlvdXIgcGFzc3dvcmQsIGJ1dCBzb21lIGZlYXR1cmVzIHdpbGwgYmUgdW5hdmFpbGFibGUgdW50aWwgdGhlIGlkZW50aXR5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2ZXIgaXMgYmFjayBvbmxpbmUuIElmIHlvdSBrZWVwIHNlZWluZyB0aGlzIHdhcm5pbmcsIGNoZWNrIHlvdXIgY29uZmlndXJhdGlvbiBvciBjb250YWN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhIHNlcnZlciBhZG1pbi5cIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gX3QoXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IGNhbiBsb2cgaW4sIGJ1dCBzb21lIGZlYXR1cmVzIHdpbGwgYmUgdW5hdmFpbGFibGUgdW50aWwgdGhlIGlkZW50aXR5IHNlcnZlciBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYmFjayBvbmxpbmUuIElmIHlvdSBrZWVwIHNlZWluZyB0aGlzIHdhcm5pbmcsIGNoZWNrIHlvdXIgY29uZmlndXJhdGlvbiBvciBjb250YWN0IGEgc2VydmVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhZG1pbi5cIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlcnZlcklzQWxpdmU6IGZhbHNlLFxuICAgICAgICAgICAgc2VydmVyRXJyb3JJc0ZhdGFsOiBpc0ZhdGFsRXJyb3IsXG4gICAgICAgICAgICBzZXJ2ZXJEZWFkRXJyb3I6IChcbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPnsgdGl0bGUgfTwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2PnsgYm9keSB9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhIHNlcnZlciBjb25maWd1cmF0aW9uLCB1c2luZyBhIHBhaXIgb2YgVVJMcyBhcyBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaG9tZXNlcnZlclVybCBUaGUgaG9tZXNlcnZlciBVUkwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aXR5VXJsIFRoZSBpZGVudGl0eSBzZXJ2ZXIgVVJMLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ludGF4T25seSBJZiB0cnVlLCBlcnJvcnMgcmVsYXRpbmcgdG8gbGl2ZWxpbmVzcyBvZiB0aGUgc2VydmVycyB3aWxsXG4gICAgICogbm90IGJlIHJhaXNlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWYWxpZGF0ZWRTZXJ2ZXJDb25maWc+fSBSZXNvbHZlcyB0byB0aGUgdmFsaWRhdGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHZhbGlkYXRlU2VydmVyQ29uZmlnV2l0aFN0YXRpY1VybHMoXG4gICAgICAgIGhvbWVzZXJ2ZXJVcmw6IHN0cmluZyxcbiAgICAgICAgaWRlbnRpdHlVcmw/OiBzdHJpbmcsXG4gICAgICAgIHN5bnRheE9ubHkgPSBmYWxzZSxcbiAgICApOiBQcm9taXNlPFZhbGlkYXRlZFNlcnZlckNvbmZpZz4ge1xuICAgICAgICBpZiAoIWhvbWVzZXJ2ZXJVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ld1RyYW5zbGF0YWJsZUVycm9yKF90ZChcIk5vIGhvbWVzZXJ2ZXIgVVJMIHByb3ZpZGVkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdlbGxrbm93bkNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwibS5ob21lc2VydmVyXCI6IHtcbiAgICAgICAgICAgICAgICBiYXNlX3VybDogaG9tZXNlcnZlclVybCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlkZW50aXR5VXJsKSB7XG4gICAgICAgICAgICB3ZWxsa25vd25Db25maWdbJ20uaWRlbnRpdHlfc2VydmVyJ10gPSB7XG4gICAgICAgICAgICAgICAgYmFzZV91cmw6IGlkZW50aXR5VXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEF1dG9EaXNjb3ZlcnkuZnJvbURpc2NvdmVyeUNvbmZpZyh3ZWxsa25vd25Db25maWcpO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaG9tZXNlcnZlclVybCk7XG4gICAgICAgIGNvbnN0IHNlcnZlck5hbWUgPSB1cmwuaG9zdG5hbWU7XG5cbiAgICAgICAgcmV0dXJuIEF1dG9EaXNjb3ZlcnlVdGlscy5idWlsZFZhbGlkYXRlZENvbmZpZ0Zyb21EaXNjb3Zlcnkoc2VydmVyTmFtZSwgcmVzdWx0LCBzeW50YXhPbmx5LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYSBzZXJ2ZXIgY29uZmlndXJhdGlvbiwgdXNpbmcgYSBob21lc2VydmVyIGRvbWFpbiBuYW1lIGFzIGlucHV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJOYW1lIFRoZSBob21lc2VydmVyIGRvbWFpbiBuYW1lIChlZzogXCJtYXRyaXgub3JnXCIpIHRvIHZhbGlkYXRlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZhbGlkYXRlZFNlcnZlckNvbmZpZz59IFJlc29sdmVzIHRvIHRoZSB2YWxpZGF0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgdmFsaWRhdGVTZXJ2ZXJOYW1lKHNlcnZlck5hbWU6IHN0cmluZyk6IFByb21pc2U8VmFsaWRhdGVkU2VydmVyQ29uZmlnPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEF1dG9EaXNjb3ZlcnkuZmluZENsaWVudENvbmZpZyhzZXJ2ZXJOYW1lKTtcbiAgICAgICAgcmV0dXJuIEF1dG9EaXNjb3ZlcnlVdGlscy5idWlsZFZhbGlkYXRlZENvbmZpZ0Zyb21EaXNjb3Zlcnkoc2VydmVyTmFtZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYSBzZXJ2ZXIgY29uZmlndXJhdGlvbiwgdXNpbmcgYSBwcmUtY2FsY3VsYXRlZCBBdXRvRGlzY292ZXJ5IHJlc3VsdCBhc1xuICAgICAqIGlucHV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJOYW1lIFRoZSBkb21haW4gbmFtZSB0aGUgQXV0b0Rpc2NvdmVyeSByZXN1bHQgaXMgZm9yLlxuICAgICAqIEBwYXJhbSB7Kn0gZGlzY292ZXJ5UmVzdWx0IFRoZSBBdXRvRGlzY292ZXJ5IHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN5bnRheE9ubHkgSWYgdHJ1ZSwgZXJyb3JzIHJlbGF0aW5nIHRvIGxpdmVsaW5lc3Mgb2YgdGhlIHNlcnZlcnMgd2lsbCBub3QgYmUgcmFpc2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTeW50aGV0aWMgSWYgdHJ1ZSwgdGhlbiB0aGUgZGlzY292ZXJ5UmVzdWx0IHdhcyBzeW50aGVzaXNlZCBsb2NhbGx5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZhbGlkYXRlZFNlcnZlckNvbmZpZz59IFJlc29sdmVzIHRvIHRoZSB2YWxpZGF0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRWYWxpZGF0ZWRDb25maWdGcm9tRGlzY292ZXJ5KFxuICAgICAgICBzZXJ2ZXJOYW1lOiBzdHJpbmcsIGRpc2NvdmVyeVJlc3VsdCwgc3ludGF4T25seT1mYWxzZSwgaXNTeW50aGV0aWM9ZmFsc2UpOiBWYWxpZGF0ZWRTZXJ2ZXJDb25maWcge1xuICAgICAgICBpZiAoIWRpc2NvdmVyeVJlc3VsdCB8fCAhZGlzY292ZXJ5UmVzdWx0W1wibS5ob21lc2VydmVyXCJdKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gd2l0aG91dCBtYWpvciBtaXNjb25maWd1cmF0aW9uLCBzbyB3ZSdsbCBsb2cgYSBiaXQgb2YgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGluIHRoZSBsb2cgc28gd2UgY2FuIGZpbmQgdGhpcyBiaXQgb2YgY29kZWUgYnV0IG90aGVyd2lzZSB0ZWxsIHRlaCB1c2VyIFwiaXQgYnJva2VcIi5cbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVuZGVkIHVwIGluIGEgc3RhdGUgb2Ygbm90IGtub3dpbmcgd2hpY2ggaG9tZXNlcnZlciB0byBjb25uZWN0IHRvLlwiKTtcbiAgICAgICAgICAgIHRocm93IG5ld1RyYW5zbGF0YWJsZUVycm9yKF90ZChcIlVuZXhwZWN0ZWQgZXJyb3IgcmVzb2x2aW5nIGhvbWVzZXJ2ZXIgY29uZmlndXJhdGlvblwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoc1Jlc3VsdCA9IGRpc2NvdmVyeVJlc3VsdFsnbS5ob21lc2VydmVyJ107XG4gICAgICAgIGNvbnN0IGlzUmVzdWx0ID0gZGlzY292ZXJ5UmVzdWx0WydtLmlkZW50aXR5X3NlcnZlciddO1xuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBTZGtDb25maWcuZ2V0KFwidmFsaWRhdGVkX3NlcnZlcl9jb25maWdcIik7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGlkZW50aXR5IHNlcnZlciBmaXJzdCBiZWNhdXNlIGFuIGludmFsaWQgaWRlbnRpdHkgc2VydmVyIGNhdXNlc1xuICAgICAgICAvLyBhbiBpbnZhbGlkIGhvbWVzZXJ2ZXIsIHdoaWNoIG1heSBub3QgYmUgcGlja2VkIHVwIGNvcnJlY3RseS5cblxuICAgICAgICAvLyBOb3RlOiBJbiB0aGUgY2FzZXMgd2hlcmUgd2UgcmVseSBvbiB0aGUgZGVmYXVsdCBJUyBmcm9tIHRoZSBjb25maWcgKG5hbWVseVxuICAgICAgICAvLyBsYWNrIG9mIGlkZW50aXR5IHNlcnZlciBwcm92aWRlZCBieSB0aGUgZGlzY292ZXJ5IG1ldGhvZCksIHdlIGludGVudGlvbmFsbHkgZG8gbm90XG4gICAgICAgIC8vIHZhbGlkYXRlIGl0LiBUaGlzIGhhcyBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFuZCB0aGlzIGhlbHBzIHNvbWUgb2ZmLXRoZS1ncmlkIHVzYWdlXG4gICAgICAgIC8vIG9mIEVsZW1lbnQuXG4gICAgICAgIGxldCBwcmVmZXJyZWRJZGVudGl0eVVybCA9IGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1snaXNVcmwnXTtcbiAgICAgICAgaWYgKGlzUmVzdWx0ICYmIGlzUmVzdWx0LnN0YXRlID09PSBBdXRvRGlzY292ZXJ5LlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHByZWZlcnJlZElkZW50aXR5VXJsID0gaXNSZXN1bHRbXCJiYXNlX3VybFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Jlc3VsdCAmJiBpc1Jlc3VsdC5zdGF0ZSAhPT0gQXV0b0Rpc2NvdmVyeS5QUk9NUFQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGRldGVybWluaW5nIHByZWZlcnJlZCBpZGVudGl0eSBzZXJ2ZXIgVVJMOlwiLCBpc1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoaXNSZXN1bHQuc3RhdGUgPT09IEF1dG9EaXNjb3ZlcnkuRkFJTF9FUlJPUikge1xuICAgICAgICAgICAgICAgIGlmIChBdXRvRGlzY292ZXJ5LkFMTF9FUlJPUlMuaW5kZXhPZihpc1Jlc3VsdC5lcnJvcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ld1RyYW5zbGF0YWJsZUVycm9yKGlzUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3VHJhbnNsYXRhYmxlRXJyb3IoX3RkKFwiVW5leHBlY3RlZCBlcnJvciByZXNvbHZpbmcgaWRlbnRpdHkgc2VydmVyIGNvbmZpZ3VyYXRpb25cIikpO1xuICAgICAgICAgICAgfSAvLyBlbHNlIHRoZSBlcnJvciBpcyBub3QgcmVsYXRlZCB0byBzeW50YXggLSBjb250aW51ZSBhbnl3YXlzLlxuXG4gICAgICAgICAgICAvLyByZXdyaXRlIGhvbWVzZXJ2ZXIgZXJyb3Igc2luY2Ugd2UgZG9uJ3QgY2FyZSBhYm91dCBwcm9ibGVtc1xuICAgICAgICAgICAgaHNSZXN1bHQuZXJyb3IgPSBBdXRvRGlzY292ZXJ5LkVSUk9SX0lOVkFMSURfSURFTlRJVFlfU0VSVkVSO1xuXG4gICAgICAgICAgICAvLyBBbHNvIHVzZSB0aGUgdXNlcidzIHN1cHBsaWVkIGlkZW50aXR5IHNlcnZlciBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKGlzUmVzdWx0W1wiYmFzZV91cmxcIl0pIHByZWZlcnJlZElkZW50aXR5VXJsID0gaXNSZXN1bHRbXCJiYXNlX3VybFwiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoc1Jlc3VsdC5zdGF0ZSAhPT0gQXV0b0Rpc2NvdmVyeS5TVUNDRVNTKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIGhvbWVzZXJ2ZXIgY29uZmlnOlwiLCBoc1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoIXN5bnRheE9ubHkgfHwgIUF1dG9EaXNjb3ZlcnlVdGlscy5pc0xpdmVsaW5lc3NFcnJvcihoc1Jlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXV0b0Rpc2NvdmVyeS5BTExfRVJST1JTLmluZGV4T2YoaHNSZXN1bHQuZXJyb3IpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXdUcmFuc2xhdGFibGVFcnJvcihoc1Jlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ld1RyYW5zbGF0YWJsZUVycm9yKF90ZChcIlVuZXhwZWN0ZWQgZXJyb3IgcmVzb2x2aW5nIGhvbWVzZXJ2ZXIgY29uZmlndXJhdGlvblwiKSk7XG4gICAgICAgICAgICB9IC8vIGVsc2UgdGhlIGVycm9yIGlzIG5vdCByZWxhdGVkIHRvIHN5bnRheCAtIGNvbnRpbnVlIGFueXdheXMuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmVmZXJyZWRIb21lc2VydmVyVXJsID0gaHNSZXN1bHRbXCJiYXNlX3VybFwiXTtcbiAgICAgICAgbGV0IHByZWZlcnJlZEhvbWVzZXJ2ZXJOYW1lID0gc2VydmVyTmFtZSA/IHNlcnZlck5hbWUgOiBoc1Jlc3VsdFtcInNlcnZlcl9uYW1lXCJdO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocHJlZmVycmVkSG9tZXNlcnZlclVybCk7XG4gICAgICAgIGlmICghcHJlZmVycmVkSG9tZXNlcnZlck5hbWUpIHByZWZlcnJlZEhvbWVzZXJ2ZXJOYW1lID0gdXJsLmhvc3RuYW1lO1xuXG4gICAgICAgIC8vIEl0IHNob3VsZCBoYXZlIGJlZW4gc2V0IGJ5IG5vdywgc28gY2hlY2sgaXRcbiAgICAgICAgaWYgKCFwcmVmZXJyZWRIb21lc2VydmVyTmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGhvbWVzZXJ2ZXIgbmFtZSBmcm9tIGhvbWVzZXJ2ZXIgVVJMXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3VHJhbnNsYXRhYmxlRXJyb3IoX3RkKFwiVW5leHBlY3RlZCBlcnJvciByZXNvbHZpbmcgaG9tZXNlcnZlciBjb25maWd1cmF0aW9uXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYWtlVHlwZShWYWxpZGF0ZWRTZXJ2ZXJDb25maWcsIHtcbiAgICAgICAgICAgIGhzVXJsOiBwcmVmZXJyZWRIb21lc2VydmVyVXJsLFxuICAgICAgICAgICAgaHNOYW1lOiBwcmVmZXJyZWRIb21lc2VydmVyTmFtZSxcbiAgICAgICAgICAgIGhzTmFtZUlzRGlmZmVyZW50OiB1cmwuaG9zdG5hbWUgIT09IHByZWZlcnJlZEhvbWVzZXJ2ZXJOYW1lLFxuICAgICAgICAgICAgaXNVcmw6IHByZWZlcnJlZElkZW50aXR5VXJsLFxuICAgICAgICAgICAgaXNEZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHdhcm5pbmc6IGhzUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgaXNOYW1lUmVzb2x2YWJsZTogIWlzU3ludGhldGljLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUF2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0EsTUFBTUEsMkJBQXFDLEdBQUcsQ0FDMUNDLDRCQUFBLENBQWNDLHdCQUQ0QixFQUUxQ0QsNEJBQUEsQ0FBY0UsNkJBRjRCLENBQTlDOztBQVdlLE1BQU1DLGtCQUFOLENBQXlCO0VBQ3BDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQzRCLE9BQWpCQyxpQkFBaUIsQ0FBQ0MsS0FBRCxFQUFpQztJQUNyRCxJQUFJLENBQUNBLEtBQUwsRUFBWSxPQUFPLEtBQVA7SUFDWixPQUFPLENBQUMsQ0FBQ04sMkJBQTJCLENBQUNPLElBQTVCLENBQWlDQyxDQUFDLElBQUksT0FBT0YsS0FBUCxLQUFpQixRQUFqQixHQUE0QkUsQ0FBQyxLQUFLRixLQUFsQyxHQUEwQ0UsQ0FBQyxLQUFLRixLQUFLLENBQUNHLE9BQTVGLENBQVQ7RUFDSDtFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztFQUNxQyxPQUExQkMsMEJBQTBCLENBQUNDLEdBQUQsRUFBc0U7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