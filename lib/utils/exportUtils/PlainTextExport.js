"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _logger = require("matrix-js-sdk/src/logger");

var _Exporter = _interopRequireDefault(require("./Exporter"));

var _DateUtils = require("../../DateUtils");

var _languageHandler = require("../../languageHandler");

var _TextForEvent = require("../../TextForEvent");

var _EventTileFactory = require("../../events/EventTileFactory");

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class PlainTextExporter extends _Exporter.default {
  constructor(room, exportType, exportOptions, setProgressText) {
    super(room, exportType, exportOptions, setProgressText);
    (0, _defineProperty2.default)(this, "totalSize", void 0);
    (0, _defineProperty2.default)(this, "mediaOmitText", void 0);
    (0, _defineProperty2.default)(this, "textForReplyEvent", content => {
      const REPLY_REGEX = /> <(.*?)>(.*?)\n\n(.*)/s;
      const REPLY_SOURCE_MAX_LENGTH = 32;
      const match = REPLY_REGEX.exec(content.body); // if the reply format is invalid, then return the body

      if (!match) return content.body;
      let rplSource;
      const rplName = match[1];
      const rplText = match[3];
      rplSource = match[2].substring(1); // Get the first non-blank line from the source.

      const lines = rplSource.split('\n').filter(line => !/^\s*$/.test(line));

      if (lines.length > 0) {
        // Cut to a maximum length.
        rplSource = lines[0].substring(0, REPLY_SOURCE_MAX_LENGTH); // Ellipsis if needed.

        if (lines[0].length > REPLY_SOURCE_MAX_LENGTH) {
          rplSource = rplSource + "...";
        } // Wrap in formatting


        rplSource = ` "${rplSource}"`;
      } else {
        // Don't show a source because we couldn't format one.
        rplSource = "";
      }

      return `<${rplName}${rplSource}> ${rplText}`;
    });
    (0, _defineProperty2.default)(this, "plainTextForEvent", async mxEv => {
      const senderDisplayName = mxEv.sender && mxEv.sender.name ? mxEv.sender.name : mxEv.getSender();
      let mediaText = "";

      if (this.isAttachment(mxEv)) {
        if (this.exportOptions.attachmentsIncluded) {
          try {
            const blob = await this.getMediaBlob(mxEv);

            if (this.totalSize + blob.size > this.exportOptions.maxSize) {
              mediaText = ` (${this.mediaOmitText})`;
            } else {
              this.totalSize += blob.size;
              const filePath = this.getFilePath(mxEv);
              mediaText = " (" + (0, _languageHandler._t)("File Attached") + ")";
              this.addFile(filePath, blob);

              if (this.totalSize == this.exportOptions.maxSize) {
                this.exportOptions.attachmentsIncluded = false;
              }
            }
          } catch (error) {
            mediaText = " (" + (0, _languageHandler._t)("Error fetching file") + ")";

            _logger.logger.log("Error fetching file " + error);
          }
        } else mediaText = ` (${this.mediaOmitText})`;
      }

      if (this.isReply(mxEv)) return senderDisplayName + ": " + this.textForReplyEvent(mxEv.getContent()) + mediaText;else return (0, _TextForEvent.textForEvent)(mxEv) + mediaText;
    });
    this.totalSize = 0;
    this.mediaOmitText = !this.exportOptions.attachmentsIncluded ? (0, _languageHandler._t)("Media omitted") : (0, _languageHandler._t)("Media omitted - file size limit exceeded");
  }

  async createOutput(events) {
    let content = "";

    for (let i = 0; i < events.length; i++) {
      const event = events[i];
      this.updateProgress((0, _languageHandler._t)("Processing event %(number)s out of %(total)s", {
        number: i + 1,
        total: events.length
      }), false, true);
      if (this.cancelled) return this.cleanUp();
      if (!(0, _EventTileFactory.haveRendererForEvent)(event, false)) continue;
      const textForEvent = await this.plainTextForEvent(event);
      content += textForEvent && `${new Date(event.getTs()).toLocaleString()} - ${textForEvent}\n`;
    }

    return content;
  }

  async export() {
    this.updateProgress((0, _languageHandler._t)("Starting export process..."));
    this.updateProgress((0, _languageHandler._t)("Fetching events..."));
    const fetchStart = performance.now();
    const res = await this.getRequiredEvents();
    const fetchEnd = performance.now();

    _logger.logger.log(`Fetched ${res.length} events in ${(fetchEnd - fetchStart) / 1000}s`);

    this.updateProgress((0, _languageHandler._t)("Creating output..."));
    const text = await this.createOutput(res);

    if (this.files.length) {
      this.addFile("export.txt", new Blob([text]));
      await this.downloadZIP();
    } else {
      const fileName = `matrix-export-${(0, _DateUtils.formatFullDateNoDay)(new Date())}.txt`;
      this.downloadPlainText(fileName, text);
    }

    const exportEnd = performance.now();

    if (this.cancelled) {
      _logger.logger.info("Export cancelled successfully");
    } else {
      _logger.logger.info("Export successful!");

      _logger.logger.log(`Exported ${res.length} events in ${(exportEnd - fetchStart) / 1000} seconds`);
    }

    this.cleanUp();
  }

}

exports.default = PlainTextExporter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQbGFpblRleHRFeHBvcnRlciIsIkV4cG9ydGVyIiwiY29uc3RydWN0b3IiLCJyb29tIiwiZXhwb3J0VHlwZSIsImV4cG9ydE9wdGlvbnMiLCJzZXRQcm9ncmVzc1RleHQiLCJjb250ZW50IiwiUkVQTFlfUkVHRVgiLCJSRVBMWV9TT1VSQ0VfTUFYX0xFTkdUSCIsIm1hdGNoIiwiZXhlYyIsImJvZHkiLCJycGxTb3VyY2UiLCJycGxOYW1lIiwicnBsVGV4dCIsInN1YnN0cmluZyIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwidGVzdCIsImxlbmd0aCIsIm14RXYiLCJzZW5kZXJEaXNwbGF5TmFtZSIsInNlbmRlciIsIm5hbWUiLCJnZXRTZW5kZXIiLCJtZWRpYVRleHQiLCJpc0F0dGFjaG1lbnQiLCJhdHRhY2htZW50c0luY2x1ZGVkIiwiYmxvYiIsImdldE1lZGlhQmxvYiIsInRvdGFsU2l6ZSIsInNpemUiLCJtYXhTaXplIiwibWVkaWFPbWl0VGV4dCIsImZpbGVQYXRoIiwiZ2V0RmlsZVBhdGgiLCJfdCIsImFkZEZpbGUiLCJlcnJvciIsImxvZ2dlciIsImxvZyIsImlzUmVwbHkiLCJ0ZXh0Rm9yUmVwbHlFdmVudCIsImdldENvbnRlbnQiLCJ0ZXh0Rm9yRXZlbnQiLCJjcmVhdGVPdXRwdXQiLCJldmVudHMiLCJpIiwiZXZlbnQiLCJ1cGRhdGVQcm9ncmVzcyIsIm51bWJlciIsInRvdGFsIiwiY2FuY2VsbGVkIiwiY2xlYW5VcCIsImhhdmVSZW5kZXJlckZvckV2ZW50IiwicGxhaW5UZXh0Rm9yRXZlbnQiLCJEYXRlIiwiZ2V0VHMiLCJ0b0xvY2FsZVN0cmluZyIsImV4cG9ydCIsImZldGNoU3RhcnQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInJlcyIsImdldFJlcXVpcmVkRXZlbnRzIiwiZmV0Y2hFbmQiLCJ0ZXh0IiwiZmlsZXMiLCJCbG9iIiwiZG93bmxvYWRaSVAiLCJmaWxlTmFtZSIsImZvcm1hdEZ1bGxEYXRlTm9EYXkiLCJkb3dubG9hZFBsYWluVGV4dCIsImV4cG9ydEVuZCIsImluZm8iXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZXhwb3J0VXRpbHMvUGxhaW5UZXh0RXhwb3J0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IElDb250ZW50LCBNYXRyaXhFdmVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IEV4cG9ydGVyIGZyb20gXCIuL0V4cG9ydGVyXCI7XG5pbXBvcnQgeyBmb3JtYXRGdWxsRGF0ZU5vRGF5IH0gZnJvbSBcIi4uLy4uL0RhdGVVdGlsc1wiO1xuaW1wb3J0IHsgX3QgfSBmcm9tIFwiLi4vLi4vbGFuZ3VhZ2VIYW5kbGVyXCI7XG5pbXBvcnQgeyBFeHBvcnRUeXBlLCBJRXhwb3J0T3B0aW9ucyB9IGZyb20gXCIuL2V4cG9ydFV0aWxzXCI7XG5pbXBvcnQgeyB0ZXh0Rm9yRXZlbnQgfSBmcm9tIFwiLi4vLi4vVGV4dEZvckV2ZW50XCI7XG5pbXBvcnQgeyBoYXZlUmVuZGVyZXJGb3JFdmVudCB9IGZyb20gXCIuLi8uLi9ldmVudHMvRXZlbnRUaWxlRmFjdG9yeVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFpblRleHRFeHBvcnRlciBleHRlbmRzIEV4cG9ydGVyIHtcbiAgICBwcm90ZWN0ZWQgdG90YWxTaXplOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIG1lZGlhT21pdFRleHQ6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICByb29tOiBSb29tLFxuICAgICAgICBleHBvcnRUeXBlOiBFeHBvcnRUeXBlLFxuICAgICAgICBleHBvcnRPcHRpb25zOiBJRXhwb3J0T3B0aW9ucyxcbiAgICAgICAgc2V0UHJvZ3Jlc3NUZXh0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PixcbiAgICApIHtcbiAgICAgICAgc3VwZXIocm9vbSwgZXhwb3J0VHlwZSwgZXhwb3J0T3B0aW9ucywgc2V0UHJvZ3Jlc3NUZXh0KTtcbiAgICAgICAgdGhpcy50b3RhbFNpemUgPSAwO1xuICAgICAgICB0aGlzLm1lZGlhT21pdFRleHQgPSAhdGhpcy5leHBvcnRPcHRpb25zLmF0dGFjaG1lbnRzSW5jbHVkZWRcbiAgICAgICAgICAgID8gX3QoXCJNZWRpYSBvbWl0dGVkXCIpXG4gICAgICAgICAgICA6IF90KFwiTWVkaWEgb21pdHRlZCAtIGZpbGUgc2l6ZSBsaW1pdCBleGNlZWRlZFwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdGV4dEZvclJlcGx5RXZlbnQgPSAoY29udGVudDogSUNvbnRlbnQpID0+IHtcbiAgICAgICAgY29uc3QgUkVQTFlfUkVHRVggPSAvPiA8KC4qPyk+KC4qPylcXG5cXG4oLiopL3M7XG4gICAgICAgIGNvbnN0IFJFUExZX1NPVVJDRV9NQVhfTEVOR1RIID0gMzI7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBSRVBMWV9SRUdFWC5leGVjKGNvbnRlbnQuYm9keSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHJlcGx5IGZvcm1hdCBpcyBpbnZhbGlkLCB0aGVuIHJldHVybiB0aGUgYm9keVxuICAgICAgICBpZiAoIW1hdGNoKSByZXR1cm4gY29udGVudC5ib2R5O1xuXG4gICAgICAgIGxldCBycGxTb3VyY2U6IHN0cmluZztcbiAgICAgICAgY29uc3QgcnBsTmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICBjb25zdCBycGxUZXh0ID0gbWF0Y2hbM107XG5cbiAgICAgICAgcnBsU291cmNlID0gbWF0Y2hbMl0uc3Vic3RyaW5nKDEpO1xuICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IG5vbi1ibGFuayBsaW5lIGZyb20gdGhlIHNvdXJjZS5cbiAgICAgICAgY29uc3QgbGluZXMgPSBycGxTb3VyY2Uuc3BsaXQoJ1xcbicpLmZpbHRlcigobGluZSkgPT4gIS9eXFxzKiQvLnRlc3QobGluZSkpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ3V0IHRvIGEgbWF4aW11bSBsZW5ndGguXG4gICAgICAgICAgICBycGxTb3VyY2UgPSBsaW5lc1swXS5zdWJzdHJpbmcoMCwgUkVQTFlfU09VUkNFX01BWF9MRU5HVEgpO1xuICAgICAgICAgICAgLy8gRWxsaXBzaXMgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGxpbmVzWzBdLmxlbmd0aCA+IFJFUExZX1NPVVJDRV9NQVhfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgcnBsU291cmNlID0gcnBsU291cmNlICsgXCIuLi5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdyYXAgaW4gZm9ybWF0dGluZ1xuICAgICAgICAgICAgcnBsU291cmNlID0gYCBcIiR7cnBsU291cmNlfVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgYSBzb3VyY2UgYmVjYXVzZSB3ZSBjb3VsZG4ndCBmb3JtYXQgb25lLlxuICAgICAgICAgICAgcnBsU291cmNlID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgPCR7cnBsTmFtZX0ke3JwbFNvdXJjZX0+ICR7cnBsVGV4dH1gO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgcGxhaW5UZXh0Rm9yRXZlbnQgPSBhc3luYyAobXhFdjogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgc2VuZGVyRGlzcGxheU5hbWUgPSBteEV2LnNlbmRlciAmJiBteEV2LnNlbmRlci5uYW1lID8gbXhFdi5zZW5kZXIubmFtZSA6IG14RXYuZ2V0U2VuZGVyKCk7XG4gICAgICAgIGxldCBtZWRpYVRleHQgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaG1lbnQobXhFdikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cG9ydE9wdGlvbnMuYXR0YWNobWVudHNJbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB0aGlzLmdldE1lZGlhQmxvYihteEV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG90YWxTaXplICsgYmxvYi5zaXplID4gdGhpcy5leHBvcnRPcHRpb25zLm1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhVGV4dCA9IGAgKCR7dGhpcy5tZWRpYU9taXRUZXh0fSlgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbFNpemUgKz0gYmxvYi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSB0aGlzLmdldEZpbGVQYXRoKG14RXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFUZXh0ID0gXCIgKFwiICsgX3QoXCJGaWxlIEF0dGFjaGVkXCIpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZVBhdGgsIGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG90YWxTaXplID09IHRoaXMuZXhwb3J0T3B0aW9ucy5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvcnRPcHRpb25zLmF0dGFjaG1lbnRzSW5jbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhVGV4dCA9IFwiIChcIiArIF90KFwiRXJyb3IgZmV0Y2hpbmcgZmlsZVwiKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiRXJyb3IgZmV0Y2hpbmcgZmlsZSBcIiArIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgbWVkaWFUZXh0ID0gYCAoJHt0aGlzLm1lZGlhT21pdFRleHR9KWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZXBseShteEV2KSkgcmV0dXJuIHNlbmRlckRpc3BsYXlOYW1lICsgXCI6IFwiICsgdGhpcy50ZXh0Rm9yUmVwbHlFdmVudChteEV2LmdldENvbnRlbnQoKSkgKyBtZWRpYVRleHQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIHRleHRGb3JFdmVudChteEV2KSArIG1lZGlhVGV4dDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIGFzeW5jIGNyZWF0ZU91dHB1dChldmVudHM6IE1hdHJpeEV2ZW50W10pIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKF90KFwiUHJvY2Vzc2luZyBldmVudCAlKG51bWJlcilzIG91dCBvZiAlKHRvdGFsKXNcIiwge1xuICAgICAgICAgICAgICAgIG51bWJlcjogaSArIDEsXG4gICAgICAgICAgICAgICAgdG90YWw6IGV2ZW50cy5sZW5ndGgsXG4gICAgICAgICAgICB9KSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSByZXR1cm4gdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICBpZiAoIWhhdmVSZW5kZXJlckZvckV2ZW50KGV2ZW50LCBmYWxzZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdGV4dEZvckV2ZW50ID0gYXdhaXQgdGhpcy5wbGFpblRleHRGb3JFdmVudChldmVudCk7XG4gICAgICAgICAgICBjb250ZW50ICs9IHRleHRGb3JFdmVudCAmJiBgJHtuZXcgRGF0ZShldmVudC5nZXRUcygpKS50b0xvY2FsZVN0cmluZygpfSAtICR7dGV4dEZvckV2ZW50fVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGV4cG9ydCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyhfdChcIlN0YXJ0aW5nIGV4cG9ydCBwcm9jZXNzLi4uXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyhfdChcIkZldGNoaW5nIGV2ZW50cy4uLlwiKSk7XG5cbiAgICAgICAgY29uc3QgZmV0Y2hTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldFJlcXVpcmVkRXZlbnRzKCk7XG4gICAgICAgIGNvbnN0IGZldGNoRW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhgRmV0Y2hlZCAke3Jlcy5sZW5ndGh9IGV2ZW50cyBpbiAkeyhmZXRjaEVuZCAtIGZldGNoU3RhcnQpLzEwMDB9c2ApO1xuXG4gICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MoX3QoXCJDcmVhdGluZyBvdXRwdXQuLi5cIikpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5jcmVhdGVPdXRwdXQocmVzKTtcblxuICAgICAgICBpZiAodGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsZShcImV4cG9ydC50eHRcIiwgbmV3IEJsb2IoW3RleHRdKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRvd25sb2FkWklQKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGBtYXRyaXgtZXhwb3J0LSR7Zm9ybWF0RnVsbERhdGVOb0RheShuZXcgRGF0ZSgpKX0udHh0YDtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRQbGFpblRleHQoZmlsZU5hbWUsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwb3J0RW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIkV4cG9ydCBjYW5jZWxsZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJFeHBvcnQgc3VjY2Vzc2Z1bCFcIik7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBFeHBvcnRlZCAke3Jlcy5sZW5ndGh9IGV2ZW50cyBpbiAkeyhleHBvcnRFbmQgLSBmZXRjaFN0YXJ0KS8xMDAwfSBzZWNvbmRzYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICB9XG59XG5cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFrQkE7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNlLE1BQU1BLGlCQUFOLFNBQWdDQyxpQkFBaEMsQ0FBeUM7RUFJcERDLFdBQVcsQ0FDUEMsSUFETyxFQUVQQyxVQUZPLEVBR1BDLGFBSE8sRUFJUEMsZUFKTyxFQUtUO0lBQ0UsTUFBTUgsSUFBTixFQUFZQyxVQUFaLEVBQXdCQyxhQUF4QixFQUF1Q0MsZUFBdkM7SUFERjtJQUFBO0lBQUEseURBUTBCQyxPQUFELElBQXVCO01BQzlDLE1BQU1DLFdBQVcsR0FBRyx5QkFBcEI7TUFDQSxNQUFNQyx1QkFBdUIsR0FBRyxFQUFoQztNQUVBLE1BQU1DLEtBQUssR0FBR0YsV0FBVyxDQUFDRyxJQUFaLENBQWlCSixPQUFPLENBQUNLLElBQXpCLENBQWQsQ0FKOEMsQ0FNOUM7O01BQ0EsSUFBSSxDQUFDRixLQUFMLEVBQVksT0FBT0gsT0FBTyxDQUFDSyxJQUFmO01BRVosSUFBSUMsU0FBSjtNQUNBLE1BQU1DLE9BQU8sR0FBR0osS0FBSyxDQUFDLENBQUQsQ0FBckI7TUFDQSxNQUFNSyxPQUFPLEdBQUdMLEtBQUssQ0FBQyxDQUFELENBQXJCO01BRUFHLFNBQVMsR0FBR0gsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTTSxTQUFULENBQW1CLENBQW5CLENBQVosQ0FiOEMsQ0FjOUM7O01BQ0EsTUFBTUMsS0FBSyxHQUFHSixTQUFTLENBQUNLLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JDLE1BQXRCLENBQThCQyxJ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