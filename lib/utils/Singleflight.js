"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Singleflight = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _maps = require("./maps");

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Inspired by https://pkg.go.dev/golang.org/x/sync/singleflight
const keyMap = new _maps.EnhancedMap();
/**
 * Access class to get a singleflight context. Singleflights execute a
 * function exactly once, unless instructed to forget about a result.
 *
 * Typically this is used to de-duplicate an action, such as a save button
 * being pressed, without having to track state internally for an operation
 * already being in progress. This doesn't expose a flag which can be used
 * to disable a button, however it would be capable of returning a Promise
 * from the first call.
 *
 * The result of the function call is cached indefinitely, just in case a
 * second call comes through late. There are various functions named "forget"
 * to have the cache be cleared of a result.
 *
 * Singleflights in our use case are tied to an instance of something, combined
 * with a string key to differentiate between multiple possible actions. This
 * means that a "save" key will be scoped to the instance which defined it and
 * not leak between other instances. This is done to avoid having to concatenate
 * variables to strings to essentially namespace the field, for most cases.
 */

class Singleflight {
  constructor() {}
  /**
   * A void marker to help with returning a value in a singleflight context.
   * If your code doesn't return anything, return this instead.
   */


  /**
   * Acquire a singleflight context.
   * @param {Object} instance An instance to associate the context with. Can be any object.
   * @param {string} key A string key relevant to that instance to namespace under.
   * @returns {SingleflightContext} Returns the context to execute the function.
   */
  static for(instance, key) {
    if (!instance || !key) throw new Error("An instance and key must be supplied");
    return new SingleflightContext(instance, key);
  }
  /**
   * Forgets all results for a given instance.
   * @param {Object} instance The instance to forget about.
   */


  static forgetAllFor(instance) {
    keyMap.delete(instance);
  }
  /**
   * Forgets all cached results for all instances. Intended for use by tests.
   */


  static forgetAll() {
    for (const k of keyMap.keys()) {
      keyMap.remove(k);
    }
  }

}

exports.Singleflight = Singleflight;
(0, _defineProperty2.default)(Singleflight, "Void", Symbol("void"));

class SingleflightContext {
  constructor(instance, key) {
    this.instance = instance;
    this.key = key;
  }
  /**
   * Forget this particular instance and key combination, discarding the result.
   */


  forget() {
    const map = keyMap.get(this.instance);
    if (!map) return;
    map.remove(this.key);
    if (!map.size) keyMap.remove(this.instance);
  }
  /**
   * Execute a function. If a result is already known, that will be returned instead
   * of executing the provided function. However, if no result is known then the function
   * will be called, with its return value cached. The function must return a value
   * other than `undefined` - take a look at Singleflight.Void if you don't have a return
   * to make.
   *
   * Note that this technically allows the caller to provide a different function each time:
   * this is largely considered a bad idea and should not be done. Singleflights work off the
   * premise that something needs to happen once, so duplicate executions will be ignored.
   *
   * For ideal performance and behaviour, functions which return promises are preferred. If
   * a function is not returning a promise, it should return as soon as possible to avoid a
   * second call potentially racing it. The promise returned by this function will be that
   * of the first execution of the function, even on duplicate calls.
   * @param {Function} fn The function to execute.
   * @returns The recorded value.
   */


  do(fn) {
    const map = keyMap.getOrCreate(this.instance, new _maps.EnhancedMap()); // We have to manually getOrCreate() because we need to execute the fn

    let val = map.get(this.key);

    if (val === undefined) {
      val = fn();
      map.set(this.key, val);
    }

    return val;
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJrZXlNYXAiLCJFbmhhbmNlZE1hcCIsIlNpbmdsZWZsaWdodCIsImNvbnN0cnVjdG9yIiwiZm9yIiwiaW5zdGFuY2UiLCJrZXkiLCJFcnJvciIsIlNpbmdsZWZsaWdodENvbnRleHQiLCJmb3JnZXRBbGxGb3IiLCJkZWxldGUiLCJmb3JnZXRBbGwiLCJrIiwia2V5cyIsInJlbW92ZSIsIlN5bWJvbCIsImZvcmdldCIsIm1hcCIsImdldCIsInNpemUiLCJkbyIsImZuIiwiZ2V0T3JDcmVhdGUiLCJ2YWwiLCJ1bmRlZmluZWQiLCJzZXQiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvU2luZ2xlZmxpZ2h0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IEVuaGFuY2VkTWFwIH0gZnJvbSBcIi4vbWFwc1wiO1xuXG4vLyBJbnNwaXJlZCBieSBodHRwczovL3BrZy5nby5kZXYvZ29sYW5nLm9yZy94L3N5bmMvc2luZ2xlZmxpZ2h0XG5cbmNvbnN0IGtleU1hcCA9IG5ldyBFbmhhbmNlZE1hcDxPYmplY3QsIEVuaGFuY2VkTWFwPHN0cmluZywgdW5rbm93bj4+KCk7XG5cbi8qKlxuICogQWNjZXNzIGNsYXNzIHRvIGdldCBhIHNpbmdsZWZsaWdodCBjb250ZXh0LiBTaW5nbGVmbGlnaHRzIGV4ZWN1dGUgYVxuICogZnVuY3Rpb24gZXhhY3RseSBvbmNlLCB1bmxlc3MgaW5zdHJ1Y3RlZCB0byBmb3JnZXQgYWJvdXQgYSByZXN1bHQuXG4gKlxuICogVHlwaWNhbGx5IHRoaXMgaXMgdXNlZCB0byBkZS1kdXBsaWNhdGUgYW4gYWN0aW9uLCBzdWNoIGFzIGEgc2F2ZSBidXR0b25cbiAqIGJlaW5nIHByZXNzZWQsIHdpdGhvdXQgaGF2aW5nIHRvIHRyYWNrIHN0YXRlIGludGVybmFsbHkgZm9yIGFuIG9wZXJhdGlvblxuICogYWxyZWFkeSBiZWluZyBpbiBwcm9ncmVzcy4gVGhpcyBkb2Vzbid0IGV4cG9zZSBhIGZsYWcgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHRvIGRpc2FibGUgYSBidXR0b24sIGhvd2V2ZXIgaXQgd291bGQgYmUgY2FwYWJsZSBvZiByZXR1cm5pbmcgYSBQcm9taXNlXG4gKiBmcm9tIHRoZSBmaXJzdCBjYWxsLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgaXMgY2FjaGVkIGluZGVmaW5pdGVseSwganVzdCBpbiBjYXNlIGFcbiAqIHNlY29uZCBjYWxsIGNvbWVzIHRocm91Z2ggbGF0ZS4gVGhlcmUgYXJlIHZhcmlvdXMgZnVuY3Rpb25zIG5hbWVkIFwiZm9yZ2V0XCJcbiAqIHRvIGhhdmUgdGhlIGNhY2hlIGJlIGNsZWFyZWQgb2YgYSByZXN1bHQuXG4gKlxuICogU2luZ2xlZmxpZ2h0cyBpbiBvdXIgdXNlIGNhc2UgYXJlIHRpZWQgdG8gYW4gaW5zdGFuY2Ugb2Ygc29tZXRoaW5nLCBjb21iaW5lZFxuICogd2l0aCBhIHN0cmluZyBrZXkgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG11bHRpcGxlIHBvc3NpYmxlIGFjdGlvbnMuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYSBcInNhdmVcIiBrZXkgd2lsbCBiZSBzY29wZWQgdG8gdGhlIGluc3RhbmNlIHdoaWNoIGRlZmluZWQgaXQgYW5kXG4gKiBub3QgbGVhayBiZXR3ZWVuIG90aGVyIGluc3RhbmNlcy4gVGhpcyBpcyBkb25lIHRvIGF2b2lkIGhhdmluZyB0byBjb25jYXRlbmF0ZVxuICogdmFyaWFibGVzIHRvIHN0cmluZ3MgdG8gZXNzZW50aWFsbHkgbmFtZXNwYWNlIHRoZSBmaWVsZCwgZm9yIG1vc3QgY2FzZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW5nbGVmbGlnaHQge1xuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSB2b2lkIG1hcmtlciB0byBoZWxwIHdpdGggcmV0dXJuaW5nIGEgdmFsdWUgaW4gYSBzaW5nbGVmbGlnaHQgY29udGV4dC5cbiAgICAgKiBJZiB5b3VyIGNvZGUgZG9lc24ndCByZXR1cm4gYW55dGhpbmcsIHJldHVybiB0aGlzIGluc3RlYWQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBWb2lkID0gU3ltYm9sKFwidm9pZFwiKTtcblxuICAgIC8qKlxuICAgICAqIEFjcXVpcmUgYSBzaW5nbGVmbGlnaHQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2UgQW4gaW5zdGFuY2UgdG8gYXNzb2NpYXRlIHRoZSBjb250ZXh0IHdpdGguIENhbiBiZSBhbnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQSBzdHJpbmcga2V5IHJlbGV2YW50IHRvIHRoYXQgaW5zdGFuY2UgdG8gbmFtZXNwYWNlIHVuZGVyLlxuICAgICAqIEByZXR1cm5zIHtTaW5nbGVmbGlnaHRDb250ZXh0fSBSZXR1cm5zIHRoZSBjb250ZXh0IHRvIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZm9yKGluc3RhbmNlOiBPYmplY3QsIGtleTogc3RyaW5nKTogU2luZ2xlZmxpZ2h0Q29udGV4dCB7XG4gICAgICAgIGlmICghaW5zdGFuY2UgfHwgIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiQW4gaW5zdGFuY2UgYW5kIGtleSBtdXN0IGJlIHN1cHBsaWVkXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNpbmdsZWZsaWdodENvbnRleHQoaW5zdGFuY2UsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yZ2V0cyBhbGwgcmVzdWx0cyBmb3IgYSBnaXZlbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIGZvcmdldCBhYm91dC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZvcmdldEFsbEZvcihpbnN0YW5jZTogT2JqZWN0KSB7XG4gICAgICAgIGtleU1hcC5kZWxldGUoaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmdldHMgYWxsIGNhY2hlZCByZXN1bHRzIGZvciBhbGwgaW5zdGFuY2VzLiBJbnRlbmRlZCBmb3IgdXNlIGJ5IHRlc3RzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZm9yZ2V0QWxsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5TWFwLmtleXMoKSkge1xuICAgICAgICAgICAga2V5TWFwLnJlbW92ZShrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2luZ2xlZmxpZ2h0Q29udGV4dCB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5zdGFuY2U6IE9iamVjdCwgcHJpdmF0ZSBrZXk6IHN0cmluZykge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmdldCB0aGlzIHBhcnRpY3VsYXIgaW5zdGFuY2UgYW5kIGtleSBjb21iaW5hdGlvbiwgZGlzY2FyZGluZyB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHB1YmxpYyBmb3JnZXQoKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IGtleU1hcC5nZXQodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgICAgIG1hcC5yZW1vdmUodGhpcy5rZXkpO1xuICAgICAgICBpZiAoIW1hcC5zaXplKSBrZXlNYXAucmVtb3ZlKHRoaXMuaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBmdW5jdGlvbi4gSWYgYSByZXN1bHQgaXMgYWxyZWFkeSBrbm93biwgdGhhdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWRcbiAgICAgKiBvZiBleGVjdXRpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBIb3dldmVyLCBpZiBubyByZXN1bHQgaXMga25vd24gdGhlbiB0aGUgZnVuY3Rpb25cbiAgICAgKiB3aWxsIGJlIGNhbGxlZCwgd2l0aCBpdHMgcmV0dXJuIHZhbHVlIGNhY2hlZC4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdmFsdWVcbiAgICAgKiBvdGhlciB0aGFuIGB1bmRlZmluZWRgIC0gdGFrZSBhIGxvb2sgYXQgU2luZ2xlZmxpZ2h0LlZvaWQgaWYgeW91IGRvbid0IGhhdmUgYSByZXR1cm5cbiAgICAgKiB0byBtYWtlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgdGVjaG5pY2FsbHkgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcHJvdmlkZSBhIGRpZmZlcmVudCBmdW5jdGlvbiBlYWNoIHRpbWU6XG4gICAgICogdGhpcyBpcyBsYXJnZWx5IGNvbnNpZGVyZWQgYSBiYWQgaWRlYSBhbmQgc2hvdWxkIG5vdCBiZSBkb25lLiBTaW5nbGVmbGlnaHRzIHdvcmsgb2ZmIHRoZVxuICAgICAqIHByZW1pc2UgdGhhdCBzb21ldGhpbmcgbmVlZHMgdG8gaGFwcGVuIG9uY2UsIHNvIGR1cGxpY2F0ZSBleGVjdXRpb25zIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEZvciBpZGVhbCBwZXJmb3JtYW5jZSBhbmQgYmVoYXZpb3VyLCBmdW5jdGlvbnMgd2hpY2ggcmV0dXJuIHByb21pc2VzIGFyZSBwcmVmZXJyZWQuIElmXG4gICAgICogYSBmdW5jdGlvbiBpcyBub3QgcmV0dXJuaW5nIGEgcHJvbWlzZSwgaXQgc2hvdWxkIHJldHVybiBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIGF2b2lkIGFcbiAgICAgKiBzZWNvbmQgY2FsbCBwb3RlbnRpYWxseSByYWNpbmcgaXQuIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSB0aGF0XG4gICAgICogb2YgdGhlIGZpcnN0IGV4ZWN1dGlvbiBvZiB0aGUgZnVuY3Rpb24sIGV2ZW4gb24gZHVwbGljYXRlIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEByZXR1cm5zIFRoZSByZWNvcmRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZG88VD4oZm46ICgpID0+IFQpOiBUIHtcbiAgICAgICAgY29uc3QgbWFwID0ga2V5TWFwLmdldE9yQ3JlYXRlKHRoaXMuaW5zdGFuY2UsIG5ldyBFbmhhbmNlZE1hcDxzdHJpbmcsIHVua25vd24+KCkpO1xuXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgZ2V0T3JDcmVhdGUoKSBiZWNhdXNlIHdlIG5lZWQgdG8gZXhlY3V0ZSB0aGUgZm5cbiAgICAgICAgbGV0IHZhbCA9IDxUPm1hcC5nZXQodGhpcy5rZXkpO1xuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbCA9IGZuKCk7XG4gICAgICAgICAgICBtYXAuc2V0KHRoaXMua2V5LCB2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