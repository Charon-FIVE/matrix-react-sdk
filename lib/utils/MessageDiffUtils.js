"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editBodyDiffToHtml = editBodyDiffToHtml;

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _diffMatchPatch = require("diff-match-patch");

var _diffDom = require("diff-dom");

var _logger = require("matrix-js-sdk/src/logger");

var _HtmlUtils = require("../HtmlUtils");

/*
Copyright 2019 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const decodeEntities = function () {
  let textarea = null;
  return function (str) {
    if (!textarea) {
      textarea = document.createElement("textarea");
    }

    textarea.innerHTML = str;
    return textarea.value;
  };
}();

function textToHtml(text) {
  const container = document.createElement("div");
  container.textContent = text;
  return container.innerHTML;
}

function getSanitizedHtmlBody(content) {
  const opts = {
    stripReplyFallback: true,
    returnString: true
  };

  if (content.format === "org.matrix.custom.html") {
    return (0, _HtmlUtils.bodyToHtml)(content, null, opts);
  } else {
    // convert the string to something that can be safely
    // embedded in an html document, e.g. use html entities where needed
    // This is also needed so that DiffDOM wouldn't interpret something
    // as a tag when somebody types e.g. "</sarcasm>"
    // as opposed to bodyToHtml, here we also render
    // text messages with dangerouslySetInnerHTML, to unify
    // the code paths and because we need html to show differences
    return textToHtml((0, _HtmlUtils.bodyToHtml)(content, null, opts));
  }
}

function wrapInsertion(child) {
  const wrapper = document.createElement((0, _HtmlUtils.checkBlockNode)(child) ? "div" : "span");
  wrapper.className = "mx_EditHistoryMessage_insertion";
  wrapper.appendChild(child);
  return wrapper;
}

function wrapDeletion(child) {
  const wrapper = document.createElement((0, _HtmlUtils.checkBlockNode)(child) ? "div" : "span");
  wrapper.className = "mx_EditHistoryMessage_deletion";
  wrapper.appendChild(child);
  return wrapper;
}

function findRefNodes(root, route) {
  let isAddition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let refNode = root;
  let refParentNode;
  const end = isAddition ? route.length - 1 : route.length;

  for (let i = 0; i < end; ++i) {
    refParentNode = refNode;
    refNode = refNode.childNodes[route[i]];
  }

  return {
    refNode,
    refParentNode
  };
}

function diffTreeToDOM(desc) {
  if (desc.nodeName === "#text") {
    return stringAsTextNode(desc.data);
  } else {
    const node = document.createElement(desc.nodeName);

    if (desc.attributes) {
      for (const [key, value] of Object.entries(desc.attributes)) {
        node.setAttribute(key, value);
      }
    }

    if (desc.childNodes) {
      for (const childDesc of desc.childNodes) {
        node.appendChild(diffTreeToDOM(childDesc));
      }
    }

    return node;
  }
}

function insertBefore(parent, nextSibling, child) {
  if (nextSibling) {
    parent.insertBefore(child, nextSibling);
  } else {
    parent.appendChild(child);
  }
}

function isRouteOfNextSibling(route1, route2) {
  // routes are arrays with indices,
  // to be interpreted as a path in the dom tree
  // ensure same parent
  for (let i = 0; i < route1.length - 1; ++i) {
    if (route1[i] !== route2[i]) {
      return false;
    }
  } // the route2 is only affected by the diff of route1
  // inserting an element if the index at the level of the
  // last element of route1 being larger
  // (e.g. coming behind route1 at that level)


  const lastD1Idx = route1.length - 1;
  return route2[lastD1Idx] >= route1[lastD1Idx];
}

function adjustRoutes(diff, remainingDiffs) {
  if (diff.action === "removeTextElement" || diff.action === "removeElement") {
    // as removed text is not removed from the html, but marked as deleted,
    // we need to readjust indices that assume the current node has been removed.
    const advance = 1;

    for (const rd of remainingDiffs) {
      if (isRouteOfNextSibling(diff.route, rd.route)) {
        rd.route[diff.route.length - 1] += advance;
      }
    }
  }
}

function stringAsTextNode(string) {
  return document.createTextNode(decodeEntities(string));
}

function renderDifferenceInDOM(originalRootNode, diff, diffMathPatch) {
  const {
    refNode,
    refParentNode
  } = findRefNodes(originalRootNode, diff.route);

  switch (diff.action) {
    case "replaceElement":
      {
        const container = document.createElement("span");
        const delNode = wrapDeletion(diffTreeToDOM(diff.oldValue));
        const insNode = wrapInsertion(diffTreeToDOM(diff.newValue));
        container.appendChild(delNode);
        container.appendChild(insNode);
        refNode.parentNode.replaceChild(container, refNode);
        break;
      }

    case "removeTextElement":
      {
        const delNode = wrapDeletion(stringAsTextNode(diff.value));
        refNode.parentNode.replaceChild(delNode, refNode);
        break;
      }

    case "removeElement":
      {
        const delNode = wrapDeletion(diffTreeToDOM(diff.element));
        refNode.parentNode.replaceChild(delNode, refNode);
        break;
      }

    case "modifyTextElement":
      {
        const textDiffs = diffMathPatch.diff_main(diff.oldValue, diff.newValue);
        diffMathPatch.diff_cleanupSemantic(textDiffs);
        const container = document.createElement("span");

        for (const [modifier, text] of textDiffs) {
          let textDiffNode = stringAsTextNode(text);

          if (modifier < 0) {
            textDiffNode = wrapDeletion(textDiffNode);
          } else if (modifier > 0) {
            textDiffNode = wrapInsertion(textDiffNode);
          }

          container.appendChild(textDiffNode);
        }

        refNode.parentNode.replaceChild(container, refNode);
        break;
      }

    case "addElement":
      {
        const insNode = wrapInsertion(diffTreeToDOM(diff.element));
        insertBefore(refParentNode, refNode, insNode);
        break;
      }

    case "addTextElement":
      {
        // XXX: sometimes diffDOM says insert a newline when there shouldn't be one
        // but we must insert the node anyway so that we don't break the route child IDs.
        // See https://github.com/fiduswriter/diffDOM/issues/100
        const insNode = wrapInsertion(stringAsTextNode(diff.value !== "\n" ? diff.value : ""));
        insertBefore(refParentNode, refNode, insNode);
        break;
      }
    // e.g. when changing a the href of a link,
    // show the link with old href as removed and with the new href as added

    case "removeAttribute":
    case "addAttribute":
    case "modifyAttribute":
      {
        const delNode = wrapDeletion(refNode.cloneNode(true));
        const updatedNode = refNode.cloneNode(true);

        if (diff.action === "addAttribute" || diff.action === "modifyAttribute") {
          updatedNode.setAttribute(diff.name, diff.newValue);
        } else {
          updatedNode.removeAttribute(diff.name);
        }

        const insNode = wrapInsertion(updatedNode);
        const container = document.createElement((0, _HtmlUtils.checkBlockNode)(refNode) ? "div" : "span");
        container.appendChild(delNode);
        container.appendChild(insNode);
        refNode.parentNode.replaceChild(container, refNode);
        break;
      }

    default:
      // Should not happen (modifyComment, ???)
      _logger.logger.warn("MessageDiffUtils::editBodyDiffToHtml: diff action not supported atm", diff);

  }
}

function routeIsEqual(r1, r2) {
  return r1.length === r2.length && !r1.some((e, i) => e !== r2[i]);
} // workaround for https://github.com/fiduswriter/diffDOM/issues/90


function filterCancelingOutDiffs(originalDiffActions) {
  const diffActions = originalDiffActions.slice();

  for (let i = 0; i < diffActions.length; ++i) {
    const diff = diffActions[i];

    if (diff.action === "removeTextElement") {
      const nextDiff = diffActions[i + 1];
      const cancelsOut = nextDiff && nextDiff.action === "addTextElement" && nextDiff.text === diff.text && routeIsEqual(nextDiff.route, diff.route);

      if (cancelsOut) {
        diffActions.splice(i, 2);
      }
    }
  }

  return diffActions;
}
/**
 * Renders a message with the changes made in an edit shown visually.
 * @param {object} originalContent the content for the base message
 * @param {object} editContent the content for the edit message
 * @return {object} a react element similar to what `bodyToHtml` returns
 */


function editBodyDiffToHtml(originalContent, editContent) {
  // wrap the body in a div, DiffDOM needs a root element
  const originalBody = `<div>${getSanitizedHtmlBody(originalContent)}</div>`;
  const editBody = `<div>${getSanitizedHtmlBody(editContent)}</div>`;
  const dd = new _diffDom.DiffDOM(); // diffActions is an array of objects with at least a `action` and `route`
  // property. `action` tells us what the diff object changes, and `route` where.
  // `route` is a path on the DOM tree expressed as an array of indices.

  const originaldiffActions = dd.diff(originalBody, editBody); // work around https://github.com/fiduswriter/diffDOM/issues/90

  const diffActions = filterCancelingOutDiffs(originaldiffActions); // for diffing text fragments

  const diffMathPatch = new _diffMatchPatch.diff_match_patch(); // parse the base html message as a DOM tree, to which we'll apply the differences found.
  // fish out the div in which we wrapped the messages above with children[0].

  const originalRootNode = new DOMParser().parseFromString(originalBody, "text/html").body.children[0];

  for (let i = 0; i < diffActions.length; ++i) {
    const diff = diffActions[i];
    renderDifferenceInDOM(originalRootNode, diff, diffMathPatch); // DiffDOM assumes in subsequent diffs route path that
    // the action was applied (e.g. that a removeElement action removed the element).
    // This is not the case for us. We render differences in the DOM tree, and don't apply them.
    // So we need to adjust the routes of the remaining diffs to account for this.

    adjustRoutes(diff, diffActions.slice(i + 1));
  } // take the html out of the modified DOM tree again


  const safeBody = originalRootNode.innerHTML;
  const className = (0, _classnames.default)({
    'mx_EventTile_body': true,
    'markdown-body': true
  });
  return /*#__PURE__*/_react.default.createElement("span", {
    key: "body",
    className: className,
    dangerouslySetInnerHTML: {
      __html: safeBody
    },
    dir: "auto"
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWNvZGVFbnRpdGllcyIsInRleHRhcmVhIiwic3RyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwidmFsdWUiLCJ0ZXh0VG9IdG1sIiwidGV4dCIsImNvbnRhaW5lciIsInRleHRDb250ZW50IiwiZ2V0U2FuaXRpemVkSHRtbEJvZHkiLCJjb250ZW50Iiwib3B0cyIsInN0cmlwUmVwbHlGYWxsYmFjayIsInJldHVyblN0cmluZyIsImZvcm1hdCIsImJvZHlUb0h0bWwiLCJ3cmFwSW5zZXJ0aW9uIiwiY2hpbGQiLCJ3cmFwcGVyIiwiY2hlY2tCbG9ja05vZGUiLCJjbGFzc05hbWUiLCJhcHBlbmRDaGlsZCIsIndyYXBEZWxldGlvbiIsImZpbmRSZWZOb2RlcyIsInJvb3QiLCJyb3V0ZSIsImlzQWRkaXRpb24iLCJyZWZOb2RlIiwicmVmUGFyZW50Tm9kZSIsImVuZCIsImxlbmd0aCIsImkiLCJjaGlsZE5vZGVzIiwiZGlmZlRyZWVUb0RPTSIsImRlc2MiLCJub2RlTmFtZSIsInN0cmluZ0FzVGV4dE5vZGUiLCJkYXRhIiwibm9kZSIsImF0dHJpYnV0ZXMiLCJrZXkiLCJPYmplY3QiLCJlbnRyaWVzIiwic2V0QXR0cmlidXRlIiwiY2hpbGREZXNjIiwiaW5zZXJ0QmVmb3JlIiwicGFyZW50IiwibmV4dFNpYmxpbmciLCJpc1JvdXRlT2ZOZXh0U2libGluZyIsInJvdXRlMSIsInJvdXRlMiIsImxhc3REMUlkeCIsImFkanVzdFJvdXRlcyIsImRpZmYiLCJyZW1haW5pbmdEaWZmcyIsImFjdGlvbiIsImFkdmFuY2UiLCJyZCIsInN0cmluZyIsImNyZWF0ZVRleHROb2RlIiwicmVuZGVyRGlmZmVyZW5jZUluRE9NIiwib3JpZ2luYWxSb290Tm9kZSIsImRpZmZNYXRoUGF0Y2giLCJkZWxOb2RlIiwib2xkVmFsdWUiLCJpbnNOb2RlIiwibmV3VmFsdWUiLCJwYXJlbnROb2RlIiwicmVwbGFjZUNoaWxkIiwiZWxlbWVudCIsInRleHREaWZmcyIsImRpZmZfbWFpbiIsImRpZmZfY2xlYW51cFNlbWFudGljIiwibW9kaWZpZXIiLCJ0ZXh0RGlmZk5vZGUiLCJjbG9uZU5vZGUiLCJ1cGRhdGVkTm9kZSIsIm5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJsb2dnZXIiLCJ3YXJuIiwicm91dGVJc0VxdWFsIiwicjEiLCJyMiIsInNvbWUiLCJlIiwiZmlsdGVyQ2FuY2VsaW5nT3V0RGlmZnMiLCJvcmlnaW5hbERpZmZBY3Rpb25zIiwiZGlmZkFjdGlvbnMiLCJzbGljZSIsIm5leHREaWZmIiwiY2FuY2Vsc091dCIsInNwbGljZSIsImVkaXRCb2R5RGlmZlRvSHRtbCIsIm9yaWdpbmFsQ29udGVudCIsImVkaXRDb250ZW50Iiwib3JpZ2luYWxCb2R5IiwiZWRpdEJvZHkiLCJkZCIsIkRpZmZET00iLCJvcmlnaW5hbGRpZmZBY3Rpb25zIiwiRGlmZk1hdGNoUGF0Y2giLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwiY2hpbGRyZW4iLCJzYWZlQm9keSIsImNsYXNzTmFtZXMiLCJfX2h0bWwiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvTWVzc2FnZURpZmZVdGlscy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IC0gMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGRpZmZfbWF0Y2hfcGF0Y2ggYXMgRGlmZk1hdGNoUGF0Y2ggfSBmcm9tICdkaWZmLW1hdGNoLXBhdGNoJztcbmltcG9ydCB7IERpZmZET00sIElEaWZmIH0gZnJvbSBcImRpZmYtZG9tXCI7XG5pbXBvcnQgeyBJQ29udGVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvZXZlbnRcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcblxuaW1wb3J0IHsgYm9keVRvSHRtbCwgY2hlY2tCbG9ja05vZGUsIElPcHRzUmV0dXJuU3RyaW5nIH0gZnJvbSBcIi4uL0h0bWxVdGlsc1wiO1xuXG5jb25zdCBkZWNvZGVFbnRpdGllcyA9IChmdW5jdGlvbigpIHtcbiAgICBsZXQgdGV4dGFyZWEgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGV4dGFyZWEpIHtcbiAgICAgICAgICAgIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRleHRhcmVhLmlubmVySFRNTCA9IHN0cjtcbiAgICAgICAgcmV0dXJuIHRleHRhcmVhLnZhbHVlO1xuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiB0ZXh0VG9IdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xufVxuXG5mdW5jdGlvbiBnZXRTYW5pdGl6ZWRIdG1sQm9keShjb250ZW50OiBJQ29udGVudCk6IHN0cmluZyB7XG4gICAgY29uc3Qgb3B0czogSU9wdHNSZXR1cm5TdHJpbmcgPSB7XG4gICAgICAgIHN0cmlwUmVwbHlGYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgcmV0dXJuU3RyaW5nOiB0cnVlLFxuICAgIH07XG4gICAgaWYgKGNvbnRlbnQuZm9ybWF0ID09PSBcIm9yZy5tYXRyaXguY3VzdG9tLmh0bWxcIikge1xuICAgICAgICByZXR1cm4gYm9keVRvSHRtbChjb250ZW50LCBudWxsLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHNhZmVseVxuICAgICAgICAvLyBlbWJlZGRlZCBpbiBhbiBodG1sIGRvY3VtZW50LCBlLmcuIHVzZSBodG1sIGVudGl0aWVzIHdoZXJlIG5lZWRlZFxuICAgICAgICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIHNvIHRoYXQgRGlmZkRPTSB3b3VsZG4ndCBpbnRlcnByZXQgc29tZXRoaW5nXG4gICAgICAgIC8vIGFzIGEgdGFnIHdoZW4gc29tZWJvZHkgdHlwZXMgZS5nLiBcIjwvc2FyY2FzbT5cIlxuXG4gICAgICAgIC8vIGFzIG9wcG9zZWQgdG8gYm9keVRvSHRtbCwgaGVyZSB3ZSBhbHNvIHJlbmRlclxuICAgICAgICAvLyB0ZXh0IG1lc3NhZ2VzIHdpdGggZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIHRvIHVuaWZ5XG4gICAgICAgIC8vIHRoZSBjb2RlIHBhdGhzIGFuZCBiZWNhdXNlIHdlIG5lZWQgaHRtbCB0byBzaG93IGRpZmZlcmVuY2VzXG4gICAgICAgIHJldHVybiB0ZXh0VG9IdG1sKGJvZHlUb0h0bWwoY29udGVudCwgbnVsbCwgb3B0cykpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gd3JhcEluc2VydGlvbihjaGlsZDogTm9kZSk6IEhUTUxFbGVtZW50IHtcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGVja0Jsb2NrTm9kZShjaGlsZCkgPyBcImRpdlwiIDogXCJzcGFuXCIpO1xuICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJteF9FZGl0SGlzdG9yeU1lc3NhZ2VfaW5zZXJ0aW9uXCI7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmZ1bmN0aW9uIHdyYXBEZWxldGlvbihjaGlsZDogTm9kZSk6IEhUTUxFbGVtZW50IHtcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGVja0Jsb2NrTm9kZShjaGlsZCkgPyBcImRpdlwiIDogXCJzcGFuXCIpO1xuICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJteF9FZGl0SGlzdG9yeU1lc3NhZ2VfZGVsZXRpb25cIjtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZnVuY3Rpb24gZmluZFJlZk5vZGVzKHJvb3Q6IE5vZGUsIHJvdXRlOiBudW1iZXJbXSwgaXNBZGRpdGlvbiA9IGZhbHNlKSB7XG4gICAgbGV0IHJlZk5vZGUgPSByb290O1xuICAgIGxldCByZWZQYXJlbnROb2RlO1xuICAgIGNvbnN0IGVuZCA9IGlzQWRkaXRpb24gPyByb3V0ZS5sZW5ndGggLSAxIDogcm91dGUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgcmVmUGFyZW50Tm9kZSA9IHJlZk5vZGU7XG4gICAgICAgIHJlZk5vZGUgPSByZWZOb2RlLmNoaWxkTm9kZXNbcm91dGVbaV1dO1xuICAgIH1cbiAgICByZXR1cm4geyByZWZOb2RlLCByZWZQYXJlbnROb2RlIH07XG59XG5cbmZ1bmN0aW9uIGRpZmZUcmVlVG9ET00oZGVzYykge1xuICAgIGlmIChkZXNjLm5vZGVOYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ0FzVGV4dE5vZGUoZGVzYy5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZXNjLm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKGRlc2MuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVzYy5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGREZXNjIG9mIGRlc2MuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGlmZlRyZWVUb0RPTShjaGlsZERlc2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnQ6IE5vZGUsIG5leHRTaWJsaW5nOiBOb2RlIHwgbnVsbCwgY2hpbGQ6IE5vZGUpOiB2b2lkIHtcbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1JvdXRlT2ZOZXh0U2libGluZyhyb3V0ZTE6IG51bWJlcltdLCByb3V0ZTI6IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gcm91dGVzIGFyZSBhcnJheXMgd2l0aCBpbmRpY2VzLFxuICAgIC8vIHRvIGJlIGludGVycHJldGVkIGFzIGEgcGF0aCBpbiB0aGUgZG9tIHRyZWVcblxuICAgIC8vIGVuc3VyZSBzYW1lIHBhcmVudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUxLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBpZiAocm91dGUxW2ldICE9PSByb3V0ZTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgcm91dGUyIGlzIG9ubHkgYWZmZWN0ZWQgYnkgdGhlIGRpZmYgb2Ygcm91dGUxXG4gICAgLy8gaW5zZXJ0aW5nIGFuIGVsZW1lbnQgaWYgdGhlIGluZGV4IGF0IHRoZSBsZXZlbCBvZiB0aGVcbiAgICAvLyBsYXN0IGVsZW1lbnQgb2Ygcm91dGUxIGJlaW5nIGxhcmdlclxuICAgIC8vIChlLmcuIGNvbWluZyBiZWhpbmQgcm91dGUxIGF0IHRoYXQgbGV2ZWwpXG4gICAgY29uc3QgbGFzdEQxSWR4ID0gcm91dGUxLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHJvdXRlMltsYXN0RDFJZHhdID49IHJvdXRlMVtsYXN0RDFJZHhdO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RSb3V0ZXMoZGlmZjogSURpZmYsIHJlbWFpbmluZ0RpZmZzOiBJRGlmZltdKTogdm9pZCB7XG4gICAgaWYgKGRpZmYuYWN0aW9uID09PSBcInJlbW92ZVRleHRFbGVtZW50XCIgfHwgZGlmZi5hY3Rpb24gPT09IFwicmVtb3ZlRWxlbWVudFwiKSB7XG4gICAgICAgIC8vIGFzIHJlbW92ZWQgdGV4dCBpcyBub3QgcmVtb3ZlZCBmcm9tIHRoZSBodG1sLCBidXQgbWFya2VkIGFzIGRlbGV0ZWQsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVhZGp1c3QgaW5kaWNlcyB0aGF0IGFzc3VtZSB0aGUgY3VycmVudCBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgIGNvbnN0IGFkdmFuY2UgPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHJkIG9mIHJlbWFpbmluZ0RpZmZzKSB7XG4gICAgICAgICAgICBpZiAoaXNSb3V0ZU9mTmV4dFNpYmxpbmcoZGlmZi5yb3V0ZSwgcmQucm91dGUpKSB7XG4gICAgICAgICAgICAgICAgcmQucm91dGVbZGlmZi5yb3V0ZS5sZW5ndGggLSAxXSArPSBhZHZhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdBc1RleHROb2RlKHN0cmluZzogc3RyaW5nKTogVGV4dCB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRlY29kZUVudGl0aWVzKHN0cmluZykpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJEaWZmZXJlbmNlSW5ET00ob3JpZ2luYWxSb290Tm9kZTogTm9kZSwgZGlmZjogSURpZmYsIGRpZmZNYXRoUGF0Y2g6IERpZmZNYXRjaFBhdGNoKTogdm9pZCB7XG4gICAgY29uc3QgeyByZWZOb2RlLCByZWZQYXJlbnROb2RlIH0gPSBmaW5kUmVmTm9kZXMob3JpZ2luYWxSb290Tm9kZSwgZGlmZi5yb3V0ZSk7XG4gICAgc3dpdGNoIChkaWZmLmFjdGlvbikge1xuICAgICAgICBjYXNlIFwicmVwbGFjZUVsZW1lbnRcIjoge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBjb25zdCBkZWxOb2RlID0gd3JhcERlbGV0aW9uKGRpZmZUcmVlVG9ET00oZGlmZi5vbGRWYWx1ZSkpO1xuICAgICAgICAgICAgY29uc3QgaW5zTm9kZSA9IHdyYXBJbnNlcnRpb24oZGlmZlRyZWVUb0RPTShkaWZmLm5ld1ZhbHVlKSk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGVsTm9kZSk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5zTm9kZSk7XG4gICAgICAgICAgICByZWZOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNvbnRhaW5lciwgcmVmTm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVtb3ZlVGV4dEVsZW1lbnRcIjoge1xuICAgICAgICAgICAgY29uc3QgZGVsTm9kZSA9IHdyYXBEZWxldGlvbihzdHJpbmdBc1RleHROb2RlKGRpZmYudmFsdWUpKTtcbiAgICAgICAgICAgIHJlZk5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZGVsTm9kZSwgcmVmTm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVtb3ZlRWxlbWVudFwiOiB7XG4gICAgICAgICAgICBjb25zdCBkZWxOb2RlID0gd3JhcERlbGV0aW9uKGRpZmZUcmVlVG9ET00oZGlmZi5lbGVtZW50KSk7XG4gICAgICAgICAgICByZWZOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRlbE5vZGUsIHJlZk5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm1vZGlmeVRleHRFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHREaWZmcyA9IGRpZmZNYXRoUGF0Y2guZGlmZl9tYWluKGRpZmYub2xkVmFsdWUsIGRpZmYubmV3VmFsdWUpO1xuICAgICAgICAgICAgZGlmZk1hdGhQYXRjaC5kaWZmX2NsZWFudXBTZW1hbnRpYyh0ZXh0RGlmZnMpO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFttb2RpZmllciwgdGV4dF0gb2YgdGV4dERpZmZzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHREaWZmTm9kZTogTm9kZSA9IHN0cmluZ0FzVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGlmZk5vZGUgPSB3cmFwRGVsZXRpb24odGV4dERpZmZOb2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGlmaWVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGlmZk5vZGUgPSB3cmFwSW5zZXJ0aW9uKHRleHREaWZmTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0ZXh0RGlmZk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjb250YWluZXIsIHJlZk5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFkZEVsZW1lbnRcIjoge1xuICAgICAgICAgICAgY29uc3QgaW5zTm9kZSA9IHdyYXBJbnNlcnRpb24oZGlmZlRyZWVUb0RPTShkaWZmLmVsZW1lbnQpKTtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShyZWZQYXJlbnROb2RlLCByZWZOb2RlLCBpbnNOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhZGRUZXh0RWxlbWVudFwiOiB7XG4gICAgICAgICAgICAvLyBYWFg6IHNvbWV0aW1lcyBkaWZmRE9NIHNheXMgaW5zZXJ0IGEgbmV3bGluZSB3aGVuIHRoZXJlIHNob3VsZG4ndCBiZSBvbmVcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBtdXN0IGluc2VydCB0aGUgbm9kZSBhbnl3YXkgc28gdGhhdCB3ZSBkb24ndCBicmVhayB0aGUgcm91dGUgY2hpbGQgSURzLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maWR1c3dyaXRlci9kaWZmRE9NL2lzc3Vlcy8xMDBcbiAgICAgICAgICAgIGNvbnN0IGluc05vZGUgPSB3cmFwSW5zZXJ0aW9uKHN0cmluZ0FzVGV4dE5vZGUoZGlmZi52YWx1ZSAhPT0gXCJcXG5cIiA/IGRpZmYudmFsdWUgOiBcIlwiKSk7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocmVmUGFyZW50Tm9kZSwgcmVmTm9kZSwgaW5zTm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBlLmcuIHdoZW4gY2hhbmdpbmcgYSB0aGUgaHJlZiBvZiBhIGxpbmssXG4gICAgICAgIC8vIHNob3cgdGhlIGxpbmsgd2l0aCBvbGQgaHJlZiBhcyByZW1vdmVkIGFuZCB3aXRoIHRoZSBuZXcgaHJlZiBhcyBhZGRlZFxuICAgICAgICBjYXNlIFwicmVtb3ZlQXR0cmlidXRlXCI6XG4gICAgICAgIGNhc2UgXCJhZGRBdHRyaWJ1dGVcIjpcbiAgICAgICAgY2FzZSBcIm1vZGlmeUF0dHJpYnV0ZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBkZWxOb2RlID0gd3JhcERlbGV0aW9uKHJlZk5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlID0gcmVmTm9kZS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZGlmZi5hY3Rpb24gPT09IFwiYWRkQXR0cmlidXRlXCIgfHwgZGlmZi5hY3Rpb24gPT09IFwibW9kaWZ5QXR0cmlidXRlXCIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkTm9kZS5zZXRBdHRyaWJ1dGUoZGlmZi5uYW1lLCBkaWZmLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZE5vZGUucmVtb3ZlQXR0cmlidXRlKGRpZmYubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnNOb2RlID0gd3JhcEluc2VydGlvbih1cGRhdGVkTm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNoZWNrQmxvY2tOb2RlKHJlZk5vZGUpID8gXCJkaXZcIiA6IFwic3BhblwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkZWxOb2RlKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnNOb2RlKTtcbiAgICAgICAgICAgIHJlZk5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29udGFpbmVyLCByZWZOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBTaG91bGQgbm90IGhhcHBlbiAobW9kaWZ5Q29tbWVudCwgPz8/KVxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJNZXNzYWdlRGlmZlV0aWxzOjplZGl0Qm9keURpZmZUb0h0bWw6IGRpZmYgYWN0aW9uIG5vdCBzdXBwb3J0ZWQgYXRtXCIsIGRpZmYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcm91dGVJc0VxdWFsKHIxOiBudW1iZXJbXSwgcjI6IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHIxLmxlbmd0aCA9PT0gcjIubGVuZ3RoICYmICFyMS5zb21lKChlLCBpKSA9PiBlICE9PSByMltpXSk7XG59XG5cbi8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9maWR1c3dyaXRlci9kaWZmRE9NL2lzc3Vlcy85MFxuZnVuY3Rpb24gZmlsdGVyQ2FuY2VsaW5nT3V0RGlmZnMob3JpZ2luYWxEaWZmQWN0aW9uczogSURpZmZbXSk6IElEaWZmW10ge1xuICAgIGNvbnN0IGRpZmZBY3Rpb25zID0gb3JpZ2luYWxEaWZmQWN0aW9ucy5zbGljZSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmQWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZkFjdGlvbnNbaV07XG4gICAgICAgIGlmIChkaWZmLmFjdGlvbiA9PT0gXCJyZW1vdmVUZXh0RWxlbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0RGlmZiA9IGRpZmZBY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbHNPdXQgPSBuZXh0RGlmZiAmJlxuICAgICAgICAgICAgICAgIG5leHREaWZmLmFjdGlvbiA9PT0gXCJhZGRUZXh0RWxlbWVudFwiICYmXG4gICAgICAgICAgICAgICAgbmV4dERpZmYudGV4dCA9PT0gZGlmZi50ZXh0ICYmXG4gICAgICAgICAgICAgICAgcm91dGVJc0VxdWFsKG5leHREaWZmLnJvdXRlLCBkaWZmLnJvdXRlKTtcblxuICAgICAgICAgICAgaWYgKGNhbmNlbHNPdXQpIHtcbiAgICAgICAgICAgICAgICBkaWZmQWN0aW9ucy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZkFjdGlvbnM7XG59XG5cbi8qKlxuICogUmVuZGVycyBhIG1lc3NhZ2Ugd2l0aCB0aGUgY2hhbmdlcyBtYWRlIGluIGFuIGVkaXQgc2hvd24gdmlzdWFsbHkuXG4gKiBAcGFyYW0ge29iamVjdH0gb3JpZ2luYWxDb250ZW50IHRoZSBjb250ZW50IGZvciB0aGUgYmFzZSBtZXNzYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gZWRpdENvbnRlbnQgdGhlIGNvbnRlbnQgZm9yIHRoZSBlZGl0IG1lc3NhZ2VcbiAqIEByZXR1cm4ge29iamVjdH0gYSByZWFjdCBlbGVtZW50IHNpbWlsYXIgdG8gd2hhdCBgYm9keVRvSHRtbGAgcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZWRpdEJvZHlEaWZmVG9IdG1sKG9yaWdpbmFsQ29udGVudDogSUNvbnRlbnQsIGVkaXRDb250ZW50OiBJQ29udGVudCk6IFJlYWN0Tm9kZSB7XG4gICAgLy8gd3JhcCB0aGUgYm9keSBpbiBhIGRpdiwgRGlmZkRPTSBuZWVkcyBhIHJvb3QgZWxlbWVudFxuICAgIGNvbnN0IG9yaWdpbmFsQm9keSA9IGA8ZGl2PiR7Z2V0U2FuaXRpemVkSHRtbEJvZHkob3JpZ2luYWxDb250ZW50KX08L2Rpdj5gO1xuICAgIGNvbnN0IGVkaXRCb2R5ID0gYDxkaXY+JHtnZXRTYW5pdGl6ZWRIdG1sQm9keShlZGl0Q29udGVudCl9PC9kaXY+YDtcbiAgICBjb25zdCBkZCA9IG5ldyBEaWZmRE9NKCk7XG4gICAgLy8gZGlmZkFjdGlvbnMgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGF0IGxlYXN0IGEgYGFjdGlvbmAgYW5kIGByb3V0ZWBcbiAgICAvLyBwcm9wZXJ0eS4gYGFjdGlvbmAgdGVsbHMgdXMgd2hhdCB0aGUgZGlmZiBvYmplY3QgY2hhbmdlcywgYW5kIGByb3V0ZWAgd2hlcmUuXG4gICAgLy8gYHJvdXRlYCBpcyBhIHBhdGggb24gdGhlIERPTSB0cmVlIGV4cHJlc3NlZCBhcyBhbiBhcnJheSBvZiBpbmRpY2VzLlxuICAgIGNvbnN0IG9yaWdpbmFsZGlmZkFjdGlvbnMgPSBkZC5kaWZmKG9yaWdpbmFsQm9keSwgZWRpdEJvZHkpO1xuICAgIC8vIHdvcmsgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9maWR1c3dyaXRlci9kaWZmRE9NL2lzc3Vlcy85MFxuICAgIGNvbnN0IGRpZmZBY3Rpb25zID0gZmlsdGVyQ2FuY2VsaW5nT3V0RGlmZnMob3JpZ2luYWxkaWZmQWN0aW9ucyk7XG4gICAgLy8gZm9yIGRpZmZpbmcgdGV4dCBmcmFnbWVudHNcbiAgICBjb25zdCBkaWZmTWF0aFBhdGNoID0gbmV3IERpZmZNYXRjaFBhdGNoKCk7XG4gICAgLy8gcGFyc2UgdGhlIGJhc2UgaHRtbCBtZXNzYWdlIGFzIGEgRE9NIHRyZWUsIHRvIHdoaWNoIHdlJ2xsIGFwcGx5IHRoZSBkaWZmZXJlbmNlcyBmb3VuZC5cbiAgICAvLyBmaXNoIG91dCB0aGUgZGl2IGluIHdoaWNoIHdlIHdyYXBwZWQgdGhlIG1lc3NhZ2VzIGFib3ZlIHdpdGggY2hpbGRyZW5bMF0uXG4gICAgY29uc3Qgb3JpZ2luYWxSb290Tm9kZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcob3JpZ2luYWxCb2R5LCBcInRleHQvaHRtbFwiKS5ib2R5LmNoaWxkcmVuWzBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZkFjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZBY3Rpb25zW2ldO1xuICAgICAgICByZW5kZXJEaWZmZXJlbmNlSW5ET00ob3JpZ2luYWxSb290Tm9kZSwgZGlmZiwgZGlmZk1hdGhQYXRjaCk7XG4gICAgICAgIC8vIERpZmZET00gYXNzdW1lcyBpbiBzdWJzZXF1ZW50IGRpZmZzIHJvdXRlIHBhdGggdGhhdFxuICAgICAgICAvLyB0aGUgYWN0aW9uIHdhcyBhcHBsaWVkIChlLmcuIHRoYXQgYSByZW1vdmVFbGVtZW50IGFjdGlvbiByZW1vdmVkIHRoZSBlbGVtZW50KS5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yIHVzLiBXZSByZW5kZXIgZGlmZmVyZW5jZXMgaW4gdGhlIERPTSB0cmVlLCBhbmQgZG9uJ3QgYXBwbHkgdGhlbS5cbiAgICAgICAgLy8gU28gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHJvdXRlcyBvZiB0aGUgcmVtYWluaW5nIGRpZmZzIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAgICAgIGFkanVzdFJvdXRlcyhkaWZmLCBkaWZmQWN0aW9ucy5zbGljZShpICsgMSkpO1xuICAgIH1cbiAgICAvLyB0YWtlIHRoZSBodG1sIG91dCBvZiB0aGUgbW9kaWZpZWQgRE9NIHRyZWUgYWdhaW5cbiAgICBjb25zdCBzYWZlQm9keSA9IG9yaWdpbmFsUm9vdE5vZGUuaW5uZXJIVE1MO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAnbXhfRXZlbnRUaWxlX2JvZHknOiB0cnVlLFxuICAgICAgICAnbWFya2Rvd24tYm9keSc6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIDxzcGFuIGtleT1cImJvZHlcIiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBzYWZlQm9keSB9fSBkaXI9XCJhdXRvXCIgLz47XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUF2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0EsTUFBTUEsY0FBYyxHQUFJLFlBQVc7RUFDL0IsSUFBSUMsUUFBUSxHQUFHLElBQWY7RUFDQSxPQUFPLFVBQVNDLEdBQVQsRUFBOEI7SUFDakMsSUFBSSxDQUFDRCxRQUFMLEVBQWU7TUFDWEEsUUFBUSxHQUFHRSxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsVUFBdkIsQ0FBWDtJQUNIOztJQUNESCxRQUFRLENBQUNJLFNBQVQsR0FBcUJILEdBQXJCO0lBQ0EsT0FBT0QsUUFBUSxDQUFDSyxLQUFoQjtFQUNILENBTkQ7QUFPSCxDQVRzQixFQUF2Qjs7QUFXQSxTQUFTQyxVQUFULENBQW9CQyxJQUFwQixFQUEwQztFQUN0QyxNQUFNQyxTQUFTLEdBQUdOLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFsQjtFQUNBSyxTQUFTLENBQUNDLFdBQVYsR0FBd0JGLElBQXhCO0VBQ0EsT0FBT0MsU0FBUyxDQUFDSixTQUFqQjtBQUNIOztBQUVELFNBQVNNLG9CQUFULENBQThCQyxPQUE5QixFQUF5RDtFQUNyRCxNQUFNQyxJQUF1QixHQUFHO0lBQzVCQyxrQkFBa0IsRUFBRSxJQURRO0lBRTVCQyxZQUFZLEVBQUU7RUFGYyxDQUFoQzs7RUFJQSxJQUFJSCxPQUFPLENBQUNJLE1BQVIsS0FBbUIsd0JB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