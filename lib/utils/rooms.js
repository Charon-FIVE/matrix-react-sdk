"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFieldsForThirdPartyLocation = getFieldsForThirdPartyLocation;
exports.joinRoomByAlias = joinRoomByAlias;
exports.privateShouldBeEncrypted = privateShouldBeEncrypted;
exports.showRoom = void 0;

var _actions = require("../dispatcher/actions");

var _WellKnownUtils = require("./WellKnownUtils");

var _dispatcher = _interopRequireDefault(require("../dispatcher/dispatcher"));

var _Rooms = require("../Rooms");

var _languageHandler = require("../languageHandler");

var _DirectoryUtils = require("./DirectoryUtils");

var _SdkConfig = _interopRequireDefault(require("../SdkConfig"));

var _error = require("./error");

/*
Copyright 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function privateShouldBeEncrypted() {
  const e2eeWellKnown = (0, _WellKnownUtils.getE2EEWellKnown)();

  if (e2eeWellKnown) {
    const defaultDisabled = e2eeWellKnown["default"] === false;
    return !defaultDisabled;
  }

  return true;
}

const showRoom = (client, room, _ref) => {
  let {
    roomAlias,
    autoJoin = false,
    shouldPeek = false,
    roomServer
  } = _ref;
  const payload = {
    action: _actions.Action.ViewRoom,
    auto_join: autoJoin,
    should_peek: shouldPeek,
    metricsTrigger: "RoomDirectory"
  };

  if (room) {
    // Don't let the user view a room they won't be able to either
    // peek or join: fail earlier so they don't have to click back
    // to the directory.
    if (client.isGuest()) {
      if (!room.world_readable && !room.guest_can_join) {
        _dispatcher.default.dispatch({
          action: 'require_registration'
        });

        return;
      }
    }

    if (!roomAlias) {
      roomAlias = (0, _Rooms.getDisplayAliasForAliasSet)(room.canonical_alias, room.aliases);
    }

    payload.oob_data = {
      avatarUrl: room.avatar_url,
      // XXX: This logic is duplicated from the JS SDK which
      // would normally decide what the name is.
      name: room.name || roomAlias || (0, _languageHandler._t)('Unnamed room')
    };

    if (roomServer) {
      payload.via_servers = [roomServer];
    }
  } // It's not really possible to join Matrix rooms by ID because the HS has no way to know
  // which servers to start querying. However, there's no other way to join rooms in
  // this list without aliases at present, so if roomAlias isn't set here we have no
  // choice but to supply the ID.


  if (roomAlias) {
    payload.room_alias = roomAlias;
  } else {
    payload.room_id = room.room_id;
  }

  _dispatcher.default.dispatch(payload);
};

exports.showRoom = showRoom;

function joinRoomByAlias(cli, alias, _ref2) {
  let {
    instanceId,
    roomServer,
    protocols,
    metricsTrigger
  } = _ref2;

  // If we don't have a particular instance id selected, just show that rooms alias
  if (!instanceId || instanceId === _DirectoryUtils.ALL_ROOMS) {
    // If the user specified an alias without a domain, add on whichever server is selected
    // in the dropdown
    if (!alias.includes(':')) {
      alias = alias + ':' + roomServer;
    }

    showRoom(cli, null, {
      roomAlias: alias,
      autoJoin: true,
      metricsTrigger
    });
  } else {
    // This is a 3rd party protocol. Let's see if we can join it
    const protocolName = (0, _DirectoryUtils.protocolNameForInstanceId)(protocols, instanceId);
    const instance = (0, _DirectoryUtils.instanceForInstanceId)(protocols, instanceId);
    const fields = protocolName ? getFieldsForThirdPartyLocation(alias, protocols[protocolName], instance) : null;

    if (!fields) {
      const brand = _SdkConfig.default.get().brand;

      throw new _error.GenericError((0, _languageHandler._t)('Unable to join network'), (0, _languageHandler._t)('%(brand)s does not know how to join a room on this network', {
        brand
      }));
    }

    cli.getThirdpartyLocation(protocolName, fields).then(resp => {
      if (resp.length > 0 && resp[0].alias) {
        showRoom(cli, null, {
          roomAlias: resp[0].alias,
          autoJoin: true,
          metricsTrigger
        });
      } else {
        throw new _error.GenericError((0, _languageHandler._t)('Room not found'), (0, _languageHandler._t)('Couldn\'t find a matching Matrix room'));
      }
    }, e => {
      throw new _error.GenericError((0, _languageHandler._t)('Fetching third party location failed'), (0, _languageHandler._t)('Unable to look up room ID from server'));
    });
  }
}

function getFieldsForThirdPartyLocation(userInput, protocol, instance) {
  // make an object with the fields specified by that protocol. We
  // require that the values of all but the last field come from the
  // instance. The last is the user input.
  const requiredFields = protocol.location_fields;
  if (!requiredFields) return null;
  const fields = {};

  for (let i = 0; i < requiredFields.length - 1; ++i) {
    const thisField = requiredFields[i];
    if (instance.fields[thisField] === undefined) return null;
    fields[thisField] = instance.fields[thisField];
  }

  fields[requiredFields[requiredFields.length - 1]] = userInput;
  return fields;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwcml2YXRlU2hvdWxkQmVFbmNyeXB0ZWQiLCJlMmVlV2VsbEtub3duIiwiZ2V0RTJFRVdlbGxLbm93biIsImRlZmF1bHREaXNhYmxlZCIsInNob3dSb29tIiwiY2xpZW50Iiwicm9vbSIsInJvb21BbGlhcyIsImF1dG9Kb2luIiwic2hvdWxkUGVlayIsInJvb21TZXJ2ZXIiLCJwYXlsb2FkIiwiYWN0aW9uIiwiQWN0aW9uIiwiVmlld1Jvb20iLCJhdXRvX2pvaW4iLCJzaG91bGRfcGVlayIsIm1ldHJpY3NUcmlnZ2VyIiwiaXNHdWVzdCIsIndvcmxkX3JlYWRhYmxlIiwiZ3Vlc3RfY2FuX2pvaW4iLCJkaXMiLCJkaXNwYXRjaCIsImdldERpc3BsYXlBbGlhc0ZvckFsaWFzU2V0IiwiY2Fub25pY2FsX2FsaWFzIiwiYWxpYXNlcyIsIm9vYl9kYXRhIiwiYXZhdGFyVXJsIiwiYXZhdGFyX3VybCIsIm5hbWUiLCJfdCIsInZpYV9zZXJ2ZXJzIiwicm9vbV9hbGlhcyIsInJvb21faWQiLCJqb2luUm9vbUJ5QWxpYXMiLCJjbGkiLCJhbGlhcyIsImluc3RhbmNlSWQiLCJwcm90b2NvbHMiLCJBTExfUk9PTVMiLCJpbmNsdWRlcyIsInByb3RvY29sTmFtZSIsInByb3RvY29sTmFtZUZvckluc3RhbmNlSWQiLCJpbnN0YW5jZSIsImluc3RhbmNlRm9ySW5zdGFuY2VJZCIsImZpZWxkcyIsImdldEZpZWxkc0ZvclRoaXJkUGFydHlMb2NhdGlvbiIsImJyYW5kIiwiU2RrQ29uZmlnIiwiZ2V0IiwiR2VuZXJpY0Vycm9yIiwiZ2V0VGhpcmRwYXJ0eUxvY2F0aW9uIiwidGhlbiIsInJlc3AiLCJsZW5ndGgiLCJlIiwidXNlcklucHV0IiwicHJvdG9jb2wiLCJyZXF1aXJlZEZpZWxkcyIsImxvY2F0aW9uX2ZpZWxkcyIsImkiLCJ0aGlzRmllbGQiLCJ1bmRlZmluZWQiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvcm9vbXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIyIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgSUluc3RhbmNlLCBJUHJvdG9jb2wsIElQdWJsaWNSb29tc0NodW5rUm9vbSwgTWF0cml4Q2xpZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NsaWVudFwiO1xuaW1wb3J0IHsgVmlld1Jvb20gYXMgVmlld1Jvb21FdmVudCB9IGZyb20gXCJAbWF0cml4LW9yZy9hbmFseXRpY3MtZXZlbnRzL3R5cGVzL3R5cGVzY3JpcHQvVmlld1Jvb21cIjtcblxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4uL2Rpc3BhdGNoZXIvYWN0aW9uc1wiO1xuaW1wb3J0IHsgVmlld1Jvb21QYXlsb2FkIH0gZnJvbSBcIi4uL2Rpc3BhdGNoZXIvcGF5bG9hZHMvVmlld1Jvb21QYXlsb2FkXCI7XG5pbXBvcnQgeyBnZXRFMkVFV2VsbEtub3duIH0gZnJvbSBcIi4vV2VsbEtub3duVXRpbHNcIjtcbmltcG9ydCBkaXMgZnJvbSBcIi4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlclwiO1xuaW1wb3J0IHsgZ2V0RGlzcGxheUFsaWFzRm9yQWxpYXNTZXQgfSBmcm9tIFwiLi4vUm9vbXNcIjtcbmltcG9ydCB7IF90IH0gZnJvbSBcIi4uL2xhbmd1YWdlSGFuZGxlclwiO1xuaW1wb3J0IHsgaW5zdGFuY2VGb3JJbnN0YW5jZUlkLCBwcm90b2NvbE5hbWVGb3JJbnN0YW5jZUlkLCBBTExfUk9PTVMsIFByb3RvY29scyB9IGZyb20gXCIuL0RpcmVjdG9yeVV0aWxzXCI7XG5pbXBvcnQgU2RrQ29uZmlnIGZyb20gXCIuLi9TZGtDb25maWdcIjtcbmltcG9ydCB7IEdlbmVyaWNFcnJvciB9IGZyb20gXCIuL2Vycm9yXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcml2YXRlU2hvdWxkQmVFbmNyeXB0ZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZTJlZVdlbGxLbm93biA9IGdldEUyRUVXZWxsS25vd24oKTtcbiAgICBpZiAoZTJlZVdlbGxLbm93bikge1xuICAgICAgICBjb25zdCBkZWZhdWx0RGlzYWJsZWQgPSBlMmVlV2VsbEtub3duW1wiZGVmYXVsdFwiXSA9PT0gZmFsc2U7XG4gICAgICAgIHJldHVybiAhZGVmYXVsdERpc2FibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuaW50ZXJmYWNlIElTaG93Um9vbU9wdHMge1xuICAgIHJvb21BbGlhcz86IHN0cmluZztcbiAgICBhdXRvSm9pbj86IGJvb2xlYW47XG4gICAgc2hvdWxkUGVlaz86IGJvb2xlYW47XG4gICAgcm9vbVNlcnZlcj86IHN0cmluZztcbiAgICBtZXRyaWNzVHJpZ2dlcjogVmlld1Jvb21FdmVudFtcInRyaWdnZXJcIl07XG59XG5cbmV4cG9ydCBjb25zdCBzaG93Um9vbSA9IChcbiAgICBjbGllbnQ6IE1hdHJpeENsaWVudCxcbiAgICByb29tOiBJUHVibGljUm9vbXNDaHVua1Jvb20gfCBudWxsLFxuICAgIHtcbiAgICAgICAgcm9vbUFsaWFzLFxuICAgICAgICBhdXRvSm9pbiA9IGZhbHNlLFxuICAgICAgICBzaG91bGRQZWVrID0gZmFsc2UsXG4gICAgICAgIHJvb21TZXJ2ZXIsXG4gICAgfTogSVNob3dSb29tT3B0cyxcbik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQ6IFZpZXdSb29tUGF5bG9hZCA9IHtcbiAgICAgICAgYWN0aW9uOiBBY3Rpb24uVmlld1Jvb20sXG4gICAgICAgIGF1dG9fam9pbjogYXV0b0pvaW4sXG4gICAgICAgIHNob3VsZF9wZWVrOiBzaG91bGRQZWVrLFxuICAgICAgICBtZXRyaWNzVHJpZ2dlcjogXCJSb29tRGlyZWN0b3J5XCIsXG4gICAgfTtcbiAgICBpZiAocm9vbSkge1xuICAgICAgICAvLyBEb24ndCBsZXQgdGhlIHVzZXIgdmlldyBhIHJvb20gdGhleSB3b24ndCBiZSBhYmxlIHRvIGVpdGhlclxuICAgICAgICAvLyBwZWVrIG9yIGpvaW46IGZhaWwgZWFybGllciBzbyB0aGV5IGRvbid0IGhhdmUgdG8gY2xpY2sgYmFja1xuICAgICAgICAvLyB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAgICBpZiAoY2xpZW50LmlzR3Vlc3QoKSkge1xuICAgICAgICAgICAgaWYgKCFyb29tLndvcmxkX3JlYWRhYmxlICYmICFyb29tLmd1ZXN0X2Nhbl9qb2luKSB7XG4gICAgICAgICAgICAgICAgZGlzLmRpc3BhdGNoKHsgYWN0aW9uOiAncmVxdWlyZV9yZWdpc3RyYXRpb24nIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vbUFsaWFzKSB7XG4gICAgICAgICAgICByb29tQWxpYXMgPSBnZXREaXNwbGF5QWxpYXNGb3JBbGlhc1NldChyb29tLmNhbm9uaWNhbF9hbGlhcywgcm9vbS5hbGlhc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBheWxvYWQub29iX2RhdGEgPSB7XG4gICAgICAgICAgICBhdmF0YXJVcmw6IHJvb20uYXZhdGFyX3VybCxcbiAgICAgICAgICAgIC8vIFhYWDogVGhpcyBsb2dpYyBpcyBkdXBsaWNhdGVkIGZyb20gdGhlIEpTIFNESyB3aGljaFxuICAgICAgICAgICAgLy8gd291bGQgbm9ybWFsbHkgZGVjaWRlIHdoYXQgdGhlIG5hbWUgaXMuXG4gICAgICAgICAgICBuYW1lOiByb29tLm5hbWUgfHwgcm9vbUFsaWFzIHx8IF90KCdVbm5hbWVkIHJvb20nKSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocm9vbVNlcnZlcikge1xuICAgICAgICAgICAgcGF5bG9hZC52aWFfc2VydmVycyA9IFtyb29tU2VydmVyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJdCdzIG5vdCByZWFsbHkgcG9zc2libGUgdG8gam9pbiBNYXRyaXggcm9vbXMgYnkgSUQgYmVjYXVzZSB0aGUgSFMgaGFzIG5vIHdheSB0byBrbm93XG4gICAgLy8gd2hpY2ggc2VydmVycyB0byBzdGFydCBxdWVyeWluZy4gSG93ZXZlciwgdGhlcmUncyBubyBvdGhlciB3YXkgdG8gam9pbiByb29tcyBpblxuICAgIC8vIHRoaXMgbGlzdCB3aXRob3V0IGFsaWFzZXMgYXQgcHJlc2VudCwgc28gaWYgcm9vbUFsaWFzIGlzbid0IHNldCBoZXJlIHdlIGhhdmUgbm9cbiAgICAvLyBjaG9pY2UgYnV0IHRvIHN1cHBseSB0aGUgSUQuXG4gICAgaWYgKHJvb21BbGlhcykge1xuICAgICAgICBwYXlsb2FkLnJvb21fYWxpYXMgPSByb29tQWxpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGF5bG9hZC5yb29tX2lkID0gcm9vbS5yb29tX2lkO1xuICAgIH1cbiAgICBkaXMuZGlzcGF0Y2gocGF5bG9hZCk7XG59O1xuXG5pbnRlcmZhY2UgSUpvaW5Sb29tQnlBbGlhc09wdHMge1xuICAgIGluc3RhbmNlSWQ/OiBzdHJpbmc7XG4gICAgcm9vbVNlcnZlcj86IHN0cmluZztcbiAgICBwcm90b2NvbHM6IFByb3RvY29scztcbiAgICBtZXRyaWNzVHJpZ2dlcjogVmlld1Jvb21FdmVudFtcInRyaWdnZXJcIl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqb2luUm9vbUJ5QWxpYXMoY2xpOiBNYXRyaXhDbGllbnQsIGFsaWFzOiBzdHJpbmcsIHtcbiAgICBpbnN0YW5jZUlkLFxuICAgIHJvb21TZXJ2ZXIsXG4gICAgcHJvdG9jb2xzLFxuICAgIG1ldHJpY3NUcmlnZ2VyLFxufTogSUpvaW5Sb29tQnlBbGlhc09wdHMpOiB2b2lkIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcGFydGljdWxhciBpbnN0YW5jZSBpZCBzZWxlY3RlZCwganVzdCBzaG93IHRoYXQgcm9vbXMgYWxpYXNcbiAgICBpZiAoIWluc3RhbmNlSWQgfHwgaW5zdGFuY2VJZCA9PT0gQUxMX1JPT01TKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhbiBhbGlhcyB3aXRob3V0IGEgZG9tYWluLCBhZGQgb24gd2hpY2hldmVyIHNlcnZlciBpcyBzZWxlY3RlZFxuICAgICAgICAvLyBpbiB0aGUgZHJvcGRvd25cbiAgICAgICAgaWYgKCFhbGlhcy5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgICAgICBhbGlhcyA9IGFsaWFzICsgJzonICsgcm9vbVNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBzaG93Um9vbShjbGksIG51bGwsIHtcbiAgICAgICAgICAgIHJvb21BbGlhczogYWxpYXMsXG4gICAgICAgICAgICBhdXRvSm9pbjogdHJ1ZSxcbiAgICAgICAgICAgIG1ldHJpY3NUcmlnZ2VyLFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgM3JkIHBhcnR5IHByb3RvY29sLiBMZXQncyBzZWUgaWYgd2UgY2FuIGpvaW4gaXRcbiAgICAgICAgY29uc3QgcHJvdG9jb2xOYW1lID0gcHJvdG9jb2xOYW1lRm9ySW5zdGFuY2VJZChwcm90b2NvbHMsIGluc3RhbmNlSWQpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlRm9ySW5zdGFuY2VJZChwcm90b2NvbHMsIGluc3RhbmNlSWQpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBwcm90b2NvbE5hbWVcbiAgICAgICAgICAgID8gZ2V0RmllbGRzRm9yVGhpcmRQYXJ0eUxvY2F0aW9uKGFsaWFzLCBwcm90b2NvbHNbcHJvdG9jb2xOYW1lXSwgaW5zdGFuY2UpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBicmFuZCA9IFNka0NvbmZpZy5nZXQoKS5icmFuZDtcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmljRXJyb3IoXG4gICAgICAgICAgICAgICAgX3QoJ1VuYWJsZSB0byBqb2luIG5ldHdvcmsnKSxcbiAgICAgICAgICAgICAgICBfdCgnJShicmFuZClzIGRvZXMgbm90IGtub3cgaG93IHRvIGpvaW4gYSByb29tIG9uIHRoaXMgbmV0d29yaycsIHsgYnJhbmQgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNsaS5nZXRUaGlyZHBhcnR5TG9jYXRpb24ocHJvdG9jb2xOYW1lLCBmaWVsZHMpLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwLmxlbmd0aCA+IDAgJiYgcmVzcFswXS5hbGlhcykge1xuICAgICAgICAgICAgICAgIHNob3dSb29tKGNsaSwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICByb29tQWxpYXM6IHJlc3BbMF0uYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Kb2luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXRyaWNzVHJpZ2dlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyaWNFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgX3QoJ1Jvb20gbm90IGZvdW5kJyksXG4gICAgICAgICAgICAgICAgICAgIF90KCdDb3VsZG5cXCd0IGZpbmQgYSBtYXRjaGluZyBNYXRyaXggcm9vbScpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJpY0Vycm9yKFxuICAgICAgICAgICAgICAgIF90KCdGZXRjaGluZyB0aGlyZCBwYXJ0eSBsb2NhdGlvbiBmYWlsZWQnKSxcbiAgICAgICAgICAgICAgICBfdCgnVW5hYmxlIHRvIGxvb2sgdXAgcm9vbSBJRCBmcm9tIHNlcnZlcicpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRzRm9yVGhpcmRQYXJ0eUxvY2F0aW9uKFxuICAgIHVzZXJJbnB1dDogc3RyaW5nLFxuICAgIHByb3RvY29sOiBJUHJvdG9jb2wsXG4gICAgaW5zdGFuY2U6IElJbnN0YW5jZSxcbik6IHsgc2VhcmNoRmllbGRzPzogc3RyaW5nW10gfSB8IG51bGwge1xuICAgIC8vIG1ha2UgYW4gb2JqZWN0IHdpdGggdGhlIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhhdCBwcm90b2NvbC4gV2VcbiAgICAvLyByZXF1aXJlIHRoYXQgdGhlIHZhbHVlcyBvZiBhbGwgYnV0IHRoZSBsYXN0IGZpZWxkIGNvbWUgZnJvbSB0aGVcbiAgICAvLyBpbnN0YW5jZS4gVGhlIGxhc3QgaXMgdGhlIHVzZXIgaW5wdXQuXG4gICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBwcm90b2NvbC5sb2NhdGlvbl9maWVsZHM7XG4gICAgaWYgKCFyZXF1aXJlZEZpZWxkcykgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZmllbGRzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlZEZpZWxkcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGhpc0ZpZWxkID0gcmVxdWlyZWRGaWVsZHNbaV07XG4gICAgICAgIGlmIChpbnN0YW5jZS5maWVsZHNbdGhpc0ZpZWxkXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZmllbGRzW3RoaXNGaWVsZF0gPSBpbnN0YW5jZS5maWVsZHNbdGhpc0ZpZWxkXTtcbiAgICB9XG4gICAgZmllbGRzW3JlcXVpcmVkRmllbGRzW3JlcXVpcmVkRmllbGRzLmxlbmd0aCAtIDFdXSA9IHVzZXJJbnB1dDtcbiAgICByZXR1cm4gZmllbGRzO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFtQkE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVPLFNBQVNBLHdCQUFULEdBQTZDO0VBQ2hELE1BQU1DLGFBQWEsR0FBRyxJQUFBQyxnQ0FBQSxHQUF0Qjs7RUFDQSxJQUFJRCxhQUFKLEVBQW1CO0lBQ2YsTUFBTUUsZUFBZSxHQUFHRixhQUFhLENBQUMsU0FBRCxDQUFiLEtBQTZCLEtBQXJEO0lBQ0EsT0FBTyxDQUFDRSxlQUFSO0VBQ0g7O0VBQ0QsT0FBTyxJQUFQO0FBQ0g7O0FBVU0sTUFBTUMsUUFBUSxHQUFHLENBQ3BCQyxNQURvQixFQUVwQkMsSUFGb0IsV0FTYjtFQUFBLElBTlA7SUFDSUMsU0FESjtJQUVJQyxRQUFRLEdBQUcsS0FGZjtJQUdJQyxVQUFVLEdBQUcsS0FIakI7SUFJSUM7RUFKSixDQU1PO0VBQ1AsTUFBTUMsT0FBd0IsR0FBRztJQUM3QkMsTUFBTSxFQUFFQyxlQUFBLENBQU9DLFFBRGM7SUFFN0JDLFNBQVMsRUFBRVAsUUFGa0I7SUFHN0JRLFdBQVcsRUFBRVAsVUFIZ0I7SUFJN0JRLGNB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