"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useConnectedMembers = exports.removeOurDevice = exports.getGroupCall = exports.fixStuckDevices = exports.STUCK_DEVICE_TIMEOUT_MS = exports.CALL_STATE_EVENT_TYPE = exports.CALL_MEMBER_STATE_EVENT_TYPE = void 0;

var _matrix = require("matrix-js-sdk/src/matrix");

var _NamespacedValue = require("matrix-js-sdk/src/NamespacedValue");

var _utils = require("matrix-js-sdk/src/utils");

/*
Copyright 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const STUCK_DEVICE_TIMEOUT_MS = 1000 * 60 * 60; // 1 hour

exports.STUCK_DEVICE_TIMEOUT_MS = STUCK_DEVICE_TIMEOUT_MS;
const CALL_STATE_EVENT_TYPE = new _NamespacedValue.UnstableValue("m.call", "org.matrix.msc3401.call");
exports.CALL_STATE_EVENT_TYPE = CALL_STATE_EVENT_TYPE;
const CALL_MEMBER_STATE_EVENT_TYPE = new _NamespacedValue.UnstableValue("m.call.member", "org.matrix.msc3401.call.member");
exports.CALL_MEMBER_STATE_EVENT_TYPE = CALL_MEMBER_STATE_EVENT_TYPE;
const CALL_STATE_EVENT_TERMINATED = "m.terminated";

const getRoomState = (client, roomId) => {
  return client.getRoom(roomId)?.getLiveTimeline()?.getState?.(_matrix.EventTimeline.FORWARDS);
};
/**
 * Returns all room state events for the stable and unstable type value.
 */


const getRoomStateEvents = (client, roomId, type) => {
  const roomState = getRoomState(client, roomId);
  if (!roomState) return [];
  return [...roomState.getStateEvents(type.name), ...roomState.getStateEvents(type.altName)];
};
/**
 * Finds the latest, non-terminated call state event.
 */


const getGroupCall = (client, roomId) => {
  return getRoomStateEvents(client, roomId, CALL_STATE_EVENT_TYPE).sort((a, b) => b.getTs() - a.getTs()).find(event => {
    return !(CALL_STATE_EVENT_TERMINATED in event.getContent());
  });
};
/**
 * Finds the "m.call.member" events for an "m.call" event.
 *
 * @returns {MatrixEvent[]} non-expired "m.call.member" events for the call
 */


exports.getGroupCall = getGroupCall;

const useConnectedMembers = (client, callEvent) => {
  if (!CALL_STATE_EVENT_TYPE.matches(callEvent.getType())) return [];
  const callId = callEvent.getStateKey();
  const now = Date.now();
  return getRoomStateEvents(client, callEvent.getRoomId(), CALL_MEMBER_STATE_EVENT_TYPE).filter(callMemberEvent => {
    const {
      ["m.expires_ts"]: expiresTs,
      ["m.calls"]: calls
    } = callMemberEvent.getContent(); // state event expired

    if (expiresTs && expiresTs < now) return false;
    return !!calls?.find(call => call["m.call_id"] === callId);
  }) || [];
};
/**
 * Removes a list of devices from a call.
 * Only works for the current user's devices.
 */


exports.useConnectedMembers = useConnectedMembers;

const removeDevices = async (client, callEvent, deviceIds) => {
  if (!CALL_STATE_EVENT_TYPE.matches(callEvent.getType())) return;
  const roomId = callEvent.getRoomId();
  const roomState = getRoomState(client, roomId);
  if (!roomState) return;
  const callMemberEvent = roomState.getStateEvents(CALL_MEMBER_STATE_EVENT_TYPE.name, client.getUserId()) ?? roomState.getStateEvents(CALL_MEMBER_STATE_EVENT_TYPE.altName, client.getUserId());
  const callMemberEventContent = callMemberEvent?.getContent();

  if (!Array.isArray(callMemberEventContent?.["m.calls"]) || callMemberEventContent?.["m.calls"].length === 0) {
    return;
  } // copy the content to prevent mutations


  const newContent = (0, _utils.deepCopy)(callMemberEventContent);
  const callId = callEvent.getStateKey();
  let changed = false;
  newContent["m.calls"].forEach(call => {
    // skip other calls
    if (call["m.call_id"] !== callId) return;
    call["m.devices"] = call["m.devices"]?.filter(device => {
      if (deviceIds.includes(device["m.device_id"])) {
        changed = true;
        return false;
      }

      return true;
    });
  });

  if (changed) {
    // only send a new state event if there has been a change
    newContent["m.expires_ts"] = Date.now() + STUCK_DEVICE_TIMEOUT_MS;
    await client.sendStateEvent(roomId, CALL_MEMBER_STATE_EVENT_TYPE.name, newContent, client.getUserId());
  }
};
/**
 * Removes the current device from a call.
 */


const removeOurDevice = async (client, callEvent) => {
  return removeDevices(client, callEvent, [client.getDeviceId()]);
};
/**
 * Removes all devices of the current user that have not been seen within the STUCK_DEVICE_TIMEOUT_MS.
 * Does per default not remove the current device unless includeCurrentDevice is true.
 *
 * @param {boolean} includeCurrentDevice - Whether to include the current device of this session here.
 */


exports.removeOurDevice = removeOurDevice;

const fixStuckDevices = async (client, callEvent, includeCurrentDevice) => {
  const now = Date.now();
  const {
    devices: myDevices
  } = await client.getDevices();
  const currentDeviceId = client.getDeviceId();
  const devicesToBeRemoved = myDevices.filter(_ref => {
    let {
      last_seen_ts: lastSeenTs,
      device_id: deviceId
    } = _ref;
    return lastSeenTs && (deviceId !== currentDeviceId || includeCurrentDevice) && now - lastSeenTs > STUCK_DEVICE_TIMEOUT_MS;
  }).map(d => d.device_id);
  return removeDevices(client, callEvent, devicesToBeRemoved);
};

exports.fixStuckDevices = fixStuckDevices;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTVFVDS19ERVZJQ0VfVElNRU9VVF9NUyIsIkNBTExfU1RBVEVfRVZFTlRfVFlQRSIsIlVuc3RhYmxlVmFsdWUiLCJDQUxMX01FTUJFUl9TVEFURV9FVkVOVF9UWVBFIiwiQ0FMTF9TVEFURV9FVkVOVF9URVJNSU5BVEVEIiwiZ2V0Um9vbVN0YXRlIiwiY2xpZW50Iiwicm9vbUlkIiwiZ2V0Um9vbSIsImdldExpdmVUaW1lbGluZSIsImdldFN0YXRlIiwiRXZlbnRUaW1lbGluZSIsIkZPUldBUkRTIiwiZ2V0Um9vbVN0YXRlRXZlbnRzIiwidHlwZSIsInJvb21TdGF0ZSIsImdldFN0YXRlRXZlbnRzIiwibmFtZSIsImFsdE5hbWUiLCJnZXRHcm91cENhbGwiLCJzb3J0IiwiYSIsImIiLCJnZXRUcyIsImZpbmQiLCJldmVudCIsImdldENvbnRlbnQiLCJ1c2VDb25uZWN0ZWRNZW1iZXJzIiwiY2FsbEV2ZW50IiwibWF0Y2hlcyIsImdldFR5cGUiLCJjYWxsSWQiLCJnZXRTdGF0ZUtleSIsIm5vdyIsIkRhdGUiLCJnZXRSb29tSWQiLCJmaWx0ZXIiLCJjYWxsTWVtYmVyRXZlbnQiLCJleHBpcmVzVHMiLCJjYWxscyIsImNhbGwiLCJyZW1vdmVEZXZpY2VzIiwiZGV2aWNlSWRzIiwiZ2V0VXNlcklkIiwiY2FsbE1lbWJlckV2ZW50Q29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIm5ld0NvbnRlbnQiLCJkZWVwQ29weSIsImNoYW5nZWQiLCJmb3JFYWNoIiwiZGV2aWNlIiwiaW5jbHVkZXMiLCJzZW5kU3RhdGVFdmVudCIsInJlbW92ZU91ckRldmljZSIsImdldERldmljZUlkIiwiZml4U3R1Y2tEZXZpY2VzIiwiaW5jbHVkZUN1cnJlbnREZXZpY2UiLCJkZXZpY2VzIiwibXlEZXZpY2VzIiwiZ2V0RGV2aWNlcyIsImN1cnJlbnREZXZpY2VJZCIsImRldmljZXNUb0JlUmVtb3ZlZCIsImxhc3Rfc2Vlbl90cyIsImxhc3RTZWVuVHMiLCJkZXZpY2VfaWQiLCJkZXZpY2VJZCIsIm1hcCIsImQiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvR3JvdXBDYWxsVXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIyIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgRXZlbnRUaW1lbGluZSwgTWF0cml4Q2xpZW50LCBNYXRyaXhFdmVudCwgUm9vbVN0YXRlIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21hdHJpeFwiO1xuaW1wb3J0IHsgVW5zdGFibGVWYWx1ZSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9OYW1lc3BhY2VkVmFsdWVcIjtcbmltcG9ydCB7IGRlZXBDb3B5IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL3V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBTVFVDS19ERVZJQ0VfVElNRU9VVF9NUyA9IDEwMDAgKiA2MCAqIDYwOyAvLyAxIGhvdXJcblxuZXhwb3J0IGNvbnN0IENBTExfU1RBVEVfRVZFTlRfVFlQRSA9IG5ldyBVbnN0YWJsZVZhbHVlKFwibS5jYWxsXCIsIFwib3JnLm1hdHJpeC5tc2MzNDAxLmNhbGxcIik7XG5leHBvcnQgY29uc3QgQ0FMTF9NRU1CRVJfU1RBVEVfRVZFTlRfVFlQRSA9IG5ldyBVbnN0YWJsZVZhbHVlKFwibS5jYWxsLm1lbWJlclwiLCBcIm9yZy5tYXRyaXgubXNjMzQwMS5jYWxsLm1lbWJlclwiKTtcbmNvbnN0IENBTExfU1RBVEVfRVZFTlRfVEVSTUlOQVRFRCA9IFwibS50ZXJtaW5hdGVkXCI7XG5cbmludGVyZmFjZSBNRGV2aWNlIHtcbiAgICBbXCJtLmRldmljZV9pZFwiXTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTUNhbGwge1xuICAgIFtcIm0uY2FsbF9pZFwiXTogc3RyaW5nO1xuICAgIFtcIm0uZGV2aWNlc1wiXTogQXJyYXk8TURldmljZT47XG59XG5cbmludGVyZmFjZSBNQ2FsbE1lbWJlckNvbnRlbnQge1xuICAgIFtcIm0uZXhwaXJlc190c1wiXTogbnVtYmVyO1xuICAgIFtcIm0uY2FsbHNcIl06IEFycmF5PE1DYWxsPjtcbn1cblxuY29uc3QgZ2V0Um9vbVN0YXRlID0gKGNsaWVudDogTWF0cml4Q2xpZW50LCByb29tSWQ6IHN0cmluZyk6IFJvb21TdGF0ZSA9PiB7XG4gICAgcmV0dXJuIGNsaWVudC5nZXRSb29tKHJvb21JZClcbiAgICAgICAgPy5nZXRMaXZlVGltZWxpbmUoKVxuICAgICAgICA/LmdldFN0YXRlPy4oRXZlbnRUaW1lbGluZS5GT1JXQVJEUyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHJvb20gc3RhdGUgZXZlbnRzIGZvciB0aGUgc3RhYmxlIGFuZCB1bnN0YWJsZSB0eXBlIHZhbHVlLlxuICovXG5jb25zdCBnZXRSb29tU3RhdGVFdmVudHMgPSAoXG4gICAgY2xpZW50OiBNYXRyaXhDbGllbnQsXG4gICAgcm9vbUlkOiBzdHJpbmcsXG4gICAgdHlwZTogVW5zdGFibGVWYWx1ZTxzdHJpbmcsIHN0cmluZz4sXG4pOiBNYXRyaXhFdmVudFtdID0+IHtcbiAgICBjb25zdCByb29tU3RhdGUgPSBnZXRSb29tU3RhdGUoY2xpZW50LCByb29tSWQpO1xuICAgIGlmICghcm9vbVN0YXRlKSByZXR1cm4gW107XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5yb29tU3RhdGUuZ2V0U3RhdGVFdmVudHModHlwZS5uYW1lKSxcbiAgICAgICAgLi4ucm9vbVN0YXRlLmdldFN0YXRlRXZlbnRzKHR5cGUuYWx0TmFtZSksXG4gICAgXTtcbn07XG5cbi8qKlxuICogRmluZHMgdGhlIGxhdGVzdCwgbm9uLXRlcm1pbmF0ZWQgY2FsbCBzdGF0ZSBldmVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEdyb3VwQ2FsbCA9IChjbGllbnQ6IE1hdHJpeENsaWVudCwgcm9vbUlkOiBzdHJpbmcpOiBNYXRyaXhFdmVudCA9PiB7XG4gICAgcmV0dXJuIGdldFJvb21TdGF0ZUV2ZW50cyhjbGllbnQsIHJvb21JZCwgQ0FMTF9TVEFURV9FVkVOVF9UWVBFKVxuICAgICAgICAuc29ydCgoYTogTWF0cml4RXZlbnQsIGI6IE1hdHJpeEV2ZW50KSA9PiBiLmdldFRzKCkgLSBhLmdldFRzKCkpXG4gICAgICAgIC5maW5kKChldmVudDogTWF0cml4RXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhKENBTExfU1RBVEVfRVZFTlRfVEVSTUlOQVRFRCBpbiBldmVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogRmluZHMgdGhlIFwibS5jYWxsLm1lbWJlclwiIGV2ZW50cyBmb3IgYW4gXCJtLmNhbGxcIiBldmVudC5cbiAqXG4gKiBAcmV0dXJucyB7TWF0cml4RXZlbnRbXX0gbm9uLWV4cGlyZWQgXCJtLmNhbGwubWVtYmVyXCIgZXZlbnRzIGZvciB0aGUgY2FsbFxuICovXG5leHBvcnQgY29uc3QgdXNlQ29ubmVjdGVkTWVtYmVycyA9IChjbGllbnQ6IE1hdHJpeENsaWVudCwgY2FsbEV2ZW50OiBNYXRyaXhFdmVudCk6IE1hdHJpeEV2ZW50W10gPT4ge1xuICAgIGlmICghQ0FMTF9TVEFURV9FVkVOVF9UWVBFLm1hdGNoZXMoY2FsbEV2ZW50LmdldFR5cGUoKSkpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGNhbGxJZCA9IGNhbGxFdmVudC5nZXRTdGF0ZUtleSgpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICByZXR1cm4gZ2V0Um9vbVN0YXRlRXZlbnRzKGNsaWVudCwgY2FsbEV2ZW50LmdldFJvb21JZCgpLCBDQUxMX01FTUJFUl9TVEFURV9FVkVOVF9UWVBFKVxuICAgICAgICAuZmlsdGVyKChjYWxsTWVtYmVyRXZlbnQ6IE1hdHJpeEV2ZW50KTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgW1wibS5leHBpcmVzX3RzXCJdOiBleHBpcmVzVHMsXG4gICAgICAgICAgICAgICAgW1wibS5jYWxsc1wiXTogY2FsbHMsXG4gICAgICAgICAgICB9ID0gY2FsbE1lbWJlckV2ZW50LmdldENvbnRlbnQ8TUNhbGxNZW1iZXJDb250ZW50PigpO1xuXG4gICAgICAgICAgICAvLyBzdGF0ZSBldmVudCBleHBpcmVkXG4gICAgICAgICAgICBpZiAoZXhwaXJlc1RzICYmIGV4cGlyZXNUcyA8IG5vdykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gISFjYWxscz8uZmluZCgoY2FsbDogTUNhbGwpID0+IGNhbGxbXCJtLmNhbGxfaWRcIl0gPT09IGNhbGxJZCk7XG4gICAgICAgIH0pIHx8IFtdO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbGlzdCBvZiBkZXZpY2VzIGZyb20gYSBjYWxsLlxuICogT25seSB3b3JrcyBmb3IgdGhlIGN1cnJlbnQgdXNlcidzIGRldmljZXMuXG4gKi9cbmNvbnN0IHJlbW92ZURldmljZXMgPSBhc3luYyAoY2xpZW50OiBNYXRyaXhDbGllbnQsIGNhbGxFdmVudDogTWF0cml4RXZlbnQsIGRldmljZUlkczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIUNBTExfU1RBVEVfRVZFTlRfVFlQRS5tYXRjaGVzKGNhbGxFdmVudC5nZXRUeXBlKCkpKSByZXR1cm47XG5cbiAgICBjb25zdCByb29tSWQgPSBjYWxsRXZlbnQuZ2V0Um9vbUlkKCk7XG4gICAgY29uc3Qgcm9vbVN0YXRlID0gZ2V0Um9vbVN0YXRlKGNsaWVudCwgcm9vbUlkKTtcbiAgICBpZiAoIXJvb21TdGF0ZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2FsbE1lbWJlckV2ZW50ID0gcm9vbVN0YXRlLmdldFN0YXRlRXZlbnRzKENBTExfTUVNQkVSX1NUQVRFX0VWRU5UX1RZUEUubmFtZSwgY2xpZW50LmdldFVzZXJJZCgpKVxuICAgICAgICA/PyByb29tU3RhdGUuZ2V0U3RhdGVFdmVudHMoQ0FMTF9NRU1CRVJfU1RBVEVfRVZFTlRfVFlQRS5hbHROYW1lLCBjbGllbnQuZ2V0VXNlcklkKCkpO1xuICAgIGNvbnN0IGNhbGxNZW1iZXJFdmVudENvbnRlbnQgPSBjYWxsTWVtYmVyRXZlbnQ/LmdldENvbnRlbnQ8TUNhbGxNZW1iZXJDb250ZW50PigpO1xuICAgIGlmIChcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoY2FsbE1lbWJlckV2ZW50Q29udGVudD8uW1wibS5jYWxsc1wiXSlcbiAgICAgICAgfHwgY2FsbE1lbWJlckV2ZW50Q29udGVudD8uW1wibS5jYWxsc1wiXS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvcHkgdGhlIGNvbnRlbnQgdG8gcHJldmVudCBtdXRhdGlvbnNcbiAgICBjb25zdCBuZXdDb250ZW50ID0gZGVlcENvcHkoY2FsbE1lbWJlckV2ZW50Q29udGVudCk7XG4gICAgY29uc3QgY2FsbElkID0gY2FsbEV2ZW50LmdldFN0YXRlS2V5KCk7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIG5ld0NvbnRlbnRbXCJtLmNhbGxzXCJdLmZvckVhY2goKGNhbGw6IE1DYWxsKSA9PiB7XG4gICAgICAgIC8vIHNraXAgb3RoZXIgY2FsbHNcbiAgICAgICAgaWYgKGNhbGxbXCJtLmNhbGxfaWRcIl0gIT09IGNhbGxJZCkgcmV0dXJuO1xuXG4gICAgICAgIGNhbGxbXCJtLmRldmljZXNcIl0gPSBjYWxsW1wibS5kZXZpY2VzXCJdPy5maWx0ZXIoKGRldmljZTogTURldmljZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRldmljZUlkcy5pbmNsdWRlcyhkZXZpY2VbXCJtLmRldmljZV9pZFwiXSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIC8vIG9ubHkgc2VuZCBhIG5ldyBzdGF0ZSBldmVudCBpZiB0aGVyZSBoYXMgYmVlbiBhIGNoYW5nZVxuICAgICAgICBuZXdDb250ZW50W1wibS5leHBpcmVzX3RzXCJdID0gRGF0ZS5ub3coKSArIFNUVUNLX0RFVklDRV9USU1FT1VUX01TO1xuICAgICAgICBhd2FpdCBjbGllbnQuc2VuZFN0YXRlRXZlbnQoXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBDQUxMX01FTUJFUl9TVEFURV9FVkVOVF9UWVBFLm5hbWUsXG4gICAgICAgICAgICBuZXdDb250ZW50LFxuICAgICAgICAgICAgY2xpZW50LmdldFVzZXJJZCgpLFxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgY3VycmVudCBkZXZpY2UgZnJvbSBhIGNhbGwuXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVPdXJEZXZpY2UgPSBhc3luYyAoY2xpZW50OiBNYXRyaXhDbGllbnQsIGNhbGxFdmVudDogTWF0cml4RXZlbnQpID0+IHtcbiAgICByZXR1cm4gcmVtb3ZlRGV2aWNlcyhjbGllbnQsIGNhbGxFdmVudCwgW2NsaWVudC5nZXREZXZpY2VJZCgpXSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGRldmljZXMgb2YgdGhlIGN1cnJlbnQgdXNlciB0aGF0IGhhdmUgbm90IGJlZW4gc2VlbiB3aXRoaW4gdGhlIFNUVUNLX0RFVklDRV9USU1FT1VUX01TLlxuICogRG9lcyBwZXIgZGVmYXVsdCBub3QgcmVtb3ZlIHRoZSBjdXJyZW50IGRldmljZSB1bmxlc3MgaW5jbHVkZUN1cnJlbnREZXZpY2UgaXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDdXJyZW50RGV2aWNlIC0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBjdXJyZW50IGRldmljZSBvZiB0aGlzIHNlc3Npb24gaGVyZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpeFN0dWNrRGV2aWNlcyA9IGFzeW5jIChjbGllbnQ6IE1hdHJpeENsaWVudCwgY2FsbEV2ZW50OiBNYXRyaXhFdmVudCwgaW5jbHVkZUN1cnJlbnREZXZpY2U6IGJvb2xlYW4pID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHsgZGV2aWNlczogbXlEZXZpY2VzIH0gPSBhd2FpdCBjbGllbnQuZ2V0RGV2aWNlcygpO1xuICAgIGNvbnN0IGN1cnJlbnREZXZpY2VJZCA9IGNsaWVudC5nZXREZXZpY2VJZCgpO1xuICAgIGNvbnN0IGRldmljZXNUb0JlUmVtb3ZlZCA9IG15RGV2aWNlcy5maWx0ZXIoKHsgbGFzdF9zZWVuX3RzOiBsYXN0U2VlblRzLCBkZXZpY2VfaWQ6IGRldmljZUlkIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGxhc3RTZWVuVHNcbiAgICAgICAgICAgICYmIChkZXZpY2VJZCAhPT0gY3VycmVudERldmljZUlkIHx8IGluY2x1ZGVDdXJyZW50RGV2aWNlKVxuICAgICAgICAgICAgJiYgKG5vdyAtIGxhc3RTZWVuVHMpID4gU1RVQ0tfREVWSUNFX1RJTUVPVVRfTVM7XG4gICAgfSkubWFwKGQgPT4gZC5kZXZpY2VfaWQpO1xuICAgIHJldHVybiByZW1vdmVEZXZpY2VzKGNsaWVudCwgY2FsbEV2ZW50LCBkZXZpY2VzVG9CZVJlbW92ZWQpO1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTU8sTUFBTUEsdUJBQXVCLEdBQUcsT0FBTyxFQUFQLEdBQVksRUFBNUMsQyxDQUFnRDs7O0FBRWhELE1BQU1DLHFCQUFxQixHQUFHLElBQUlDLDhCQUFKLENBQWtCLFFBQWxCLEVBQTRCLHlCQUE1QixDQUE5Qjs7QUFDQSxNQUFNQyw0QkFBNEIsR0FBRyxJQUFJRCw4QkFBSixDQUFrQixlQUFsQixFQUFtQyxnQ0FBbkMsQ0FBckM7O0FBQ1AsTUFBTUUsMkJBQTJCLEdBQUcsY0FBcEM7O0FBZ0JBLE1BQU1DLFlBQVksR0FBRyxDQUFDQyxNQUFELEVBQXVCQyxNQUF2QixLQUFxRDtFQUN0RSxPQUFPRCxNQUFNLENBQUNFLE9BQVAsQ0FBZUQsTUFBZixHQUNERSxlQURDLElBRURDLFFBRkMsR0FFVUMscUJBQUEsQ0FBY0MsUUFGeEIsQ0FBUDtBQUdILENBSkQ7QUFNQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLGtCQUFrQixHQUFHLENBQ3ZCUCxNQUR1QixFQUV2QkMsTUFGdUIsRUFHdkJPLElBSHVCLEtBSVA7RUFDaEIsTUFBTUMsU0FBUyxHQUFHVixZQUFZLENBQUNDLE1BQUQsRUFBU0MsTUFBVCxDQUE5QjtFQUNBLElBQUksQ0FBQ1EsU0FBTCxFQUFnQixPQUFPLEVBQVA7RUFFaEIsT0FBTyxDQUNI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