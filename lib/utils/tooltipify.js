"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltipifyLinks = tooltipifyLinks;
exports.unmountTooltips = unmountTooltips;

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _PlatformPeg = _interopRequireDefault(require("../PlatformPeg"));

var _LinkWithTooltip = _interopRequireDefault(require("../components/views/elements/LinkWithTooltip"));

/*
Copyright 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * If the platform enabled needsUrlTooltips, recurses depth-first through a DOM tree, adding tooltip previews
 * for link elements. Otherwise, does nothing.
 *
 * @param {Element[]} rootNodes - a list of sibling DOM nodes to traverse to try
 *   to add tooltips.
 * @param {Element[]} ignoredNodes: a list of nodes to not recurse into.
 * @param {Element[]} containers: an accumulator of the DOM nodes which contain
 *   React components that have been mounted by this function. The initial caller
 *   should pass in an empty array to seed the accumulator.
 */
function tooltipifyLinks(rootNodes, ignoredNodes, containers) {
  if (!_PlatformPeg.default.get()?.needsUrlTooltips()) {
    return;
  }

  let node = rootNodes[0];

  while (node) {
    if (ignoredNodes.includes(node) || containers.includes(node)) {
      node = node.nextSibling;
      continue;
    }

    if (node.tagName === "A" && node.getAttribute("href") && node.getAttribute("href") !== node.textContent.trim()) {
      const href = node.getAttribute("href"); // The node's innerHTML was already sanitized before being rendered in the first place, here we are just
      // wrapping the link with the LinkWithTooltip component, keeping the same children. Ideally we'd do this
      // without the superfluous span but this is not something React trivially supports at this time.

      const tooltip = /*#__PURE__*/_react.default.createElement(_LinkWithTooltip.default, {
        tooltip: new URL(href, window.location.href).toString()
      }, /*#__PURE__*/_react.default.createElement("span", {
        dangerouslySetInnerHTML: {
          __html: node.innerHTML
        }
      }));

      _reactDom.default.render(tooltip, node);

      containers.push(node);
    } else if (node.childNodes?.length) {
      tooltipifyLinks(node.childNodes, ignoredNodes, containers);
    }

    node = node.nextSibling;
  }
}
/**
 * Unmount tooltip containers created by tooltipifyLinks.
 *
 * It's critical to call this after tooltipifyLinks, otherwise
 * tooltips will leak.
 *
 * @param {Element[]} containers - array of tooltip containers to unmount
 */


function unmountTooltips(containers) {
  for (const container of containers) {
    _reactDom.default.unmountComponentAtNode(container);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0b29sdGlwaWZ5TGlua3MiLCJyb290Tm9kZXMiLCJpZ25vcmVkTm9kZXMiLCJjb250YWluZXJzIiwiUGxhdGZvcm1QZWciLCJnZXQiLCJuZWVkc1VybFRvb2x0aXBzIiwibm9kZSIsImluY2x1ZGVzIiwibmV4dFNpYmxpbmciLCJ0YWdOYW1lIiwiZ2V0QXR0cmlidXRlIiwidGV4dENvbnRlbnQiLCJ0cmltIiwiaHJlZiIsInRvb2x0aXAiLCJVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInRvU3RyaW5nIiwiX19odG1sIiwiaW5uZXJIVE1MIiwiUmVhY3RET00iLCJyZW5kZXIiLCJwdXNoIiwiY2hpbGROb2RlcyIsImxlbmd0aCIsInVubW91bnRUb29sdGlwcyIsImNvbnRhaW5lciIsInVubW91bnRDb21wb25lbnRBdE5vZGUiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvdG9vbHRpcGlmeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIyIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBQbGF0Zm9ybVBlZyBmcm9tIFwiLi4vUGxhdGZvcm1QZWdcIjtcbmltcG9ydCBMaW5rV2l0aFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudHMvdmlld3MvZWxlbWVudHMvTGlua1dpdGhUb29sdGlwXCI7XG5cbi8qKlxuICogSWYgdGhlIHBsYXRmb3JtIGVuYWJsZWQgbmVlZHNVcmxUb29sdGlwcywgcmVjdXJzZXMgZGVwdGgtZmlyc3QgdGhyb3VnaCBhIERPTSB0cmVlLCBhZGRpbmcgdG9vbHRpcCBwcmV2aWV3c1xuICogZm9yIGxpbmsgZWxlbWVudHMuIE90aGVyd2lzZSwgZG9lcyBub3RoaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSByb290Tm9kZXMgLSBhIGxpc3Qgb2Ygc2libGluZyBET00gbm9kZXMgdG8gdHJhdmVyc2UgdG8gdHJ5XG4gKiAgIHRvIGFkZCB0b29sdGlwcy5cbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBpZ25vcmVkTm9kZXM6IGEgbGlzdCBvZiBub2RlcyB0byBub3QgcmVjdXJzZSBpbnRvLlxuICogQHBhcmFtIHtFbGVtZW50W119IGNvbnRhaW5lcnM6IGFuIGFjY3VtdWxhdG9yIG9mIHRoZSBET00gbm9kZXMgd2hpY2ggY29udGFpblxuICogICBSZWFjdCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIG1vdW50ZWQgYnkgdGhpcyBmdW5jdGlvbi4gVGhlIGluaXRpYWwgY2FsbGVyXG4gKiAgIHNob3VsZCBwYXNzIGluIGFuIGVtcHR5IGFycmF5IHRvIHNlZWQgdGhlIGFjY3VtdWxhdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9vbHRpcGlmeUxpbmtzKHJvb3ROb2RlczogQXJyYXlMaWtlPEVsZW1lbnQ+LCBpZ25vcmVkTm9kZXM6IEVsZW1lbnRbXSwgY29udGFpbmVyczogRWxlbWVudFtdKSB7XG4gICAgaWYgKCFQbGF0Zm9ybVBlZy5nZXQoKT8ubmVlZHNVcmxUb29sdGlwcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHJvb3ROb2Rlc1swXTtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChpZ25vcmVkTm9kZXMuaW5jbHVkZXMobm9kZSkgfHwgY29udGFpbmVycy5pbmNsdWRlcyhub2RlKSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcgYXMgRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJBXCIgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG4gICAgICAgICAgICAmJiBub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIikgIT09IG5vZGUudGV4dENvbnRlbnQudHJpbSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcblxuICAgICAgICAgICAgLy8gVGhlIG5vZGUncyBpbm5lckhUTUwgd2FzIGFscmVhZHkgc2FuaXRpemVkIGJlZm9yZSBiZWluZyByZW5kZXJlZCBpbiB0aGUgZmlyc3QgcGxhY2UsIGhlcmUgd2UgYXJlIGp1c3RcbiAgICAgICAgICAgIC8vIHdyYXBwaW5nIHRoZSBsaW5rIHdpdGggdGhlIExpbmtXaXRoVG9vbHRpcCBjb21wb25lbnQsIGtlZXBpbmcgdGhlIHNhbWUgY2hpbGRyZW4uIElkZWFsbHkgd2UnZCBkbyB0aGlzXG4gICAgICAgICAgICAvLyB3aXRob3V0IHRoZSBzdXBlcmZsdW91cyBzcGFuIGJ1dCB0aGlzIGlzIG5vdCBzb21ldGhpbmcgUmVhY3QgdHJpdmlhbGx5IHN1cHBvcnRzIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXAgPSA8TGlua1dpdGhUb29sdGlwIHRvb2x0aXA9e25ldyBVUkwoaHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpLnRvU3RyaW5nKCl9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogbm9kZS5pbm5lckhUTUwgfX0gLz5cbiAgICAgICAgICAgIDwvTGlua1dpdGhUb29sdGlwPjtcblxuICAgICAgICAgICAgUmVhY3RET00ucmVuZGVyKHRvb2x0aXAsIG5vZGUpO1xuICAgICAgICAgICAgY29udGFpbmVycy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGROb2Rlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b29sdGlwaWZ5TGlua3Mobm9kZS5jaGlsZE5vZGVzIGFzIE5vZGVMaXN0T2Y8RWxlbWVudD4sIGlnbm9yZWROb2RlcywgY29udGFpbmVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZyBhcyBFbGVtZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IHRvb2x0aXAgY29udGFpbmVycyBjcmVhdGVkIGJ5IHRvb2x0aXBpZnlMaW5rcy5cbiAqXG4gKiBJdCdzIGNyaXRpY2FsIHRvIGNhbGwgdGhpcyBhZnRlciB0b29sdGlwaWZ5TGlua3MsIG90aGVyd2lzZVxuICogdG9vbHRpcHMgd2lsbCBsZWFrLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBjb250YWluZXJzIC0gYXJyYXkgb2YgdG9vbHRpcCBjb250YWluZXJzIHRvIHVubW91bnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnRUb29sdGlwcyhjb250YWluZXJzOiBFbGVtZW50W10pIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiBjb250YWluZXJzKSB7XG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsZUFBVCxDQUF5QkMsU0FBekIsRUFBd0RDLFlBQXhELEVBQWlGQyxVQUFqRixFQUF3RztFQUMzRyxJQUFJLENBQUNDLG9CQUFBLENBQVlDLEdBQVosSUFBbUJDLGdCQUFuQixFQUFMLEVBQTRDO0lBQ3hDO0VBQ0g7O0VBRUQsSUFBSUMsSUFBSSxHQUFHTixTQUFTLENBQUMsQ0FBRCxDQUFwQjs7RUFFQSxPQUFPTSxJQUFQLEVBQWE7SUFDVCxJQUFJTCxZQUFZLENBQUNNLFFBQWIsQ0FBc0JELElBQXRCLEtBQStCSixVQUFVLENBQUNLLFFBQVgsQ0FBb0JELElBQXBCLENBQW5DLEVBQThEO01BQzFEQSxJQUFJLEdBQUdBLElBQUksQ0FBQ0UsV0FBWjtNQUNBO0lBQ0g7O0lBRUQsSUFBSUYsSUFBSSxDQUFDRyxPQUFMLEtBQWlCLEdBQWpCLElBQXdCSCxJQUFJLENBQUNJLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeEIsSUFDR0osSUFBSSxDQUFDSSxZQUFMLENBQWtCLE1BQWxCLE1BQThCSixJQUFJLENBQUNLLFdBQUwsQ0FBaUJDLElBQWpCLEVBRHJDLEVBRUU7TUFDRSxNQUFNQyxJQUFJLEdBQUdQLElBQUksQ0FBQ0ksWUFBTCxDQUFrQixNQUFsQixDQUFiLENBREYsQ0FHRTtNQUNBO01BQ0E7O01BQ0EsTUFBTUksT0FBTyxnQkFBRyw2QkFBQyx3QkFBRDtRQUFpQixPQUFPLEVBQUUsSUFBSUMsR0FBSixDQUFRRixJQUFSLEVBQWNHLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkosSUFBOUIsRUFBb0NLLFFBQXBDO01BQTFCLGdCQUNaO1FBQU0sdUJBQXVCLEVBQUU7VUFBRUMsTUFBTSxFQUFFYixJQUFJLENBQUNjO1FBQWY7TUFBL0IsRUFEWSxDQUFoQjs7TUFJQUMsaUJBQUEsQ0FBU0MsTUFBVCxDQUFnQlIsT0FBaEIsRUFBeUJSLElBQXpCOztNQUNBSixVQUFVLENBQUNxQixJQUFYLENBQWdCakIsSUFBaEI7SUFDSCxDQWRELE1BY08sSUFBSUEsSUFBSSxDQUFDa0IsVUFBTCxFQUFpQkMsTUFBckIsRUFBNkI7TUFDaEMxQixlQUFlLENBQUNPLElBQUksQ0FBQ2tCLFVBQU4sRUFBeUN2QixZQUF6QyxFQUF1REMsVUFBdkQsQ0FBZjtJQUNIOztJQUVESSxJQUFJLEdBQUdBLElBQUksQ0FBQ0UsV0FBWjtFQUNIO0FBQ0o7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTa0IsZUFBVCxDQUF5QnhCLFVBQXpCLEVBQWdEO0VBQ25ELEtBQUssTUFBTXlCLFNBQVgsSUFBd0J6QixVQUF4QixFQUFvQztJQUNoQ21CLGlCQUFBLENBQVNPLHNCQUFULENBQWdDRCxTQUFoQztFQUNIO0FBQ0oifQ==