"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.midPointsBetweenStrings = midPointsBetweenStrings;
exports.reorderLexicographically = void 0;

var _utils = require("matrix-js-sdk/src/utils");

var _arrays = require("./arrays");

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function midPointsBetweenStrings(a, b, count, maxLen) {
  let alphabet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _utils.DEFAULT_ALPHABET;
  const padN = Math.min(Math.max(a.length, b.length), maxLen);
  const padA = (0, _utils.alphabetPad)(a, padN, alphabet);
  const padB = (0, _utils.alphabetPad)(b, padN, alphabet);
  const baseA = (0, _utils.stringToBase)(padA, alphabet);
  const baseB = (0, _utils.stringToBase)(padB, alphabet);

  if (baseB - baseA - BigInt(1) < count) {
    if (padN < maxLen) {
      // this recurses once at most due to the new limit of n+1
      return midPointsBetweenStrings((0, _utils.alphabetPad)(padA, padN + 1, alphabet), (0, _utils.alphabetPad)(padB, padN + 1, alphabet), count, padN + 1, alphabet);
    }

    return [];
  }

  const step = (baseB - baseA) / BigInt(count + 1);
  const start = BigInt(baseA + step);
  return Array(count).fill(undefined).map((_, i) => (0, _utils.baseToString)(start + BigInt(i) * step, alphabet));
}

const reorderLexicographically = function (orders, fromIndex, toIndex) {
  let maxLen = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;

  // sanity check inputs
  if (fromIndex < 0 || toIndex < 0 || fromIndex > orders.length || toIndex > orders.length || fromIndex === toIndex) {
    return [];
  } // zip orders with their indices to simplify later index wrangling


  const ordersWithIndices = orders.map((order, index) => ({
    index,
    order
  })); // apply the fundamental order update to the zipped array

  const newOrder = (0, _arrays.moveElement)(ordersWithIndices, fromIndex, toIndex); // check if we have to fill undefined orders to complete placement

  const orderToLeftUndefined = newOrder[toIndex - 1]?.order === undefined;
  let leftBoundIdx = toIndex;
  let rightBoundIdx = toIndex;
  let canMoveLeft = true;
  const nextBase = newOrder[toIndex + 1]?.order !== undefined ? (0, _utils.stringToBase)(newOrder[toIndex + 1].order) : BigInt(Number.MAX_VALUE); // check how far left we would have to mutate to fit in that direction

  for (let i = toIndex - 1, j = 1; i >= 0; i--, j++) {
    if (newOrder[i]?.order !== undefined && nextBase - (0, _utils.stringToBase)(newOrder[i].order) > j) break;
    leftBoundIdx = i;
  } // verify the left move would be sufficient


  const firstOrderBase = newOrder[0].order === undefined ? undefined : (0, _utils.stringToBase)(newOrder[0].order);
  const bigToIndex = BigInt(toIndex);

  if (leftBoundIdx === 0 && firstOrderBase !== undefined && nextBase - firstOrderBase <= bigToIndex && firstOrderBase <= bigToIndex) {
    canMoveLeft = false;
  }

  const canDisplaceRight = !orderToLeftUndefined;
  let canMoveRight = canDisplaceRight;

  if (canDisplaceRight) {
    const prevBase = newOrder[toIndex - 1]?.order !== undefined ? (0, _utils.stringToBase)(newOrder[toIndex - 1]?.order) : BigInt(Number.MIN_VALUE); // check how far right we would have to mutate to fit in that direction

    for (let i = toIndex + 1, j = 1; i < newOrder.length; i++, j++) {
      if (newOrder[i]?.order === undefined || (0, _utils.stringToBase)(newOrder[i].order) - prevBase > j) break;
      rightBoundIdx = i;
    } // verify the right move would be sufficient


    if (rightBoundIdx === newOrder.length - 1 && (newOrder[rightBoundIdx] ? (0, _utils.stringToBase)(newOrder[rightBoundIdx].order) : BigInt(Number.MAX_VALUE)) - prevBase <= rightBoundIdx - toIndex) {
      canMoveRight = false;
    }
  } // pick the cheaper direction


  const leftDiff = canMoveLeft ? toIndex - leftBoundIdx : Number.MAX_SAFE_INTEGER;
  const rightDiff = canMoveRight ? rightBoundIdx - toIndex : Number.MAX_SAFE_INTEGER;

  if (orderToLeftUndefined || leftDiff < rightDiff) {
    rightBoundIdx = toIndex;
  } else {
    leftBoundIdx = toIndex;
  }

  const prevOrder = newOrder[leftBoundIdx - 1]?.order ?? "";

  const nextOrder = newOrder[rightBoundIdx + 1]?.order ?? _utils.DEFAULT_ALPHABET.charAt(_utils.DEFAULT_ALPHABET.length - 1).repeat(prevOrder.length || 1);

  const changes = midPointsBetweenStrings(prevOrder, nextOrder, 1 + rightBoundIdx - leftBoundIdx, maxLen);
  return changes.map((order, i) => ({
    index: newOrder[leftBoundIdx + i].index,
    order
  }));
};

exports.reorderLexicographically = reorderLexicographically;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtaWRQb2ludHNCZXR3ZWVuU3RyaW5ncyIsImEiLCJiIiwiY291bnQiLCJtYXhMZW4iLCJhbHBoYWJldCIsIkRFRkFVTFRfQUxQSEFCRVQiLCJwYWROIiwiTWF0aCIsIm1pbiIsIm1heCIsImxlbmd0aCIsInBhZEEiLCJhbHBoYWJldFBhZCIsInBhZEIiLCJiYXNlQSIsInN0cmluZ1RvQmFzZSIsImJhc2VCIiwiQmlnSW50Iiwic3RlcCIsInN0YXJ0IiwiQXJyYXkiLCJmaWxsIiwidW5kZWZpbmVkIiwibWFwIiwiXyIsImkiLCJiYXNlVG9TdHJpbmciLCJyZW9yZGVyTGV4aWNvZ3JhcGhpY2FsbHkiLCJvcmRlcnMiLCJmcm9tSW5kZXgiLCJ0b0luZGV4Iiwib3JkZXJzV2l0aEluZGljZXMiLCJvcmRlciIsImluZGV4IiwibmV3T3JkZXIiLCJtb3ZlRWxlbWVudCIsIm9yZGVyVG9MZWZ0VW5kZWZpbmVkIiwibGVmdEJvdW5kSWR4IiwicmlnaHRCb3VuZElkeCIsImNhbk1vdmVMZWZ0IiwibmV4dEJhc2UiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJqIiwiZmlyc3RPcmRlckJhc2UiLCJiaWdUb0luZGV4IiwiY2FuRGlzcGxhY2VSaWdodCIsImNhbk1vdmVSaWdodCIsInByZXZCYXNlIiwiTUlOX1ZBTFVFIiwibGVmdERpZmYiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmlnaHREaWZmIiwicHJldk9yZGVyIiwibmV4dE9yZGVyIiwiY2hhckF0IiwicmVwZWF0IiwiY2hhbmdlcyJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zdHJpbmdPcmRlckZpZWxkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IGFscGhhYmV0UGFkLCBiYXNlVG9TdHJpbmcsIHN0cmluZ1RvQmFzZSwgREVGQVVMVF9BTFBIQUJFVCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy91dGlsc1wiO1xuXG5pbXBvcnQgeyBtb3ZlRWxlbWVudCB9IGZyb20gXCIuL2FycmF5c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbWlkUG9pbnRzQmV0d2VlblN0cmluZ3MoXG4gICAgYTogc3RyaW5nLFxuICAgIGI6IHN0cmluZyxcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIG1heExlbjogbnVtYmVyLFxuICAgIGFscGhhYmV0ID0gREVGQVVMVF9BTFBIQUJFVCxcbik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBwYWROID0gTWF0aC5taW4oTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKSwgbWF4TGVuKTtcbiAgICBjb25zdCBwYWRBID0gYWxwaGFiZXRQYWQoYSwgcGFkTiwgYWxwaGFiZXQpO1xuICAgIGNvbnN0IHBhZEIgPSBhbHBoYWJldFBhZChiLCBwYWROLCBhbHBoYWJldCk7XG4gICAgY29uc3QgYmFzZUEgPSBzdHJpbmdUb0Jhc2UocGFkQSwgYWxwaGFiZXQpO1xuICAgIGNvbnN0IGJhc2VCID0gc3RyaW5nVG9CYXNlKHBhZEIsIGFscGhhYmV0KTtcblxuICAgIGlmIChiYXNlQiAtIGJhc2VBIC0gQmlnSW50KDEpIDwgY291bnQpIHtcbiAgICAgICAgaWYgKHBhZE4gPCBtYXhMZW4pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgcmVjdXJzZXMgb25jZSBhdCBtb3N0IGR1ZSB0byB0aGUgbmV3IGxpbWl0IG9mIG4rMVxuICAgICAgICAgICAgcmV0dXJuIG1pZFBvaW50c0JldHdlZW5TdHJpbmdzKFxuICAgICAgICAgICAgICAgIGFscGhhYmV0UGFkKHBhZEEsIHBhZE4gKyAxLCBhbHBoYWJldCksXG4gICAgICAgICAgICAgICAgYWxwaGFiZXRQYWQocGFkQiwgcGFkTiArIDEsIGFscGhhYmV0KSxcbiAgICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgICBwYWROICsgMSxcbiAgICAgICAgICAgICAgICBhbHBoYWJldCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZXAgPSAoYmFzZUIgLSBiYXNlQSkgLyBCaWdJbnQoY291bnQgKyAxKTtcbiAgICBjb25zdCBzdGFydCA9IEJpZ0ludChiYXNlQSArIHN0ZXApO1xuICAgIHJldHVybiBBcnJheShjb3VudCkuZmlsbCh1bmRlZmluZWQpLm1hcCgoXywgaSkgPT4gYmFzZVRvU3RyaW5nKHN0YXJ0ICsgKEJpZ0ludChpKSAqIHN0ZXApLCBhbHBoYWJldCkpO1xufVxuXG5pbnRlcmZhY2UgSUVudHJ5IHtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIG9yZGVyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCByZW9yZGVyTGV4aWNvZ3JhcGhpY2FsbHkgPSAoXG4gICAgb3JkZXJzOiBBcnJheTxzdHJpbmcgfCB1bmRlZmluZWQ+LFxuICAgIGZyb21JbmRleDogbnVtYmVyLFxuICAgIHRvSW5kZXg6IG51bWJlcixcbiAgICBtYXhMZW4gPSA1MCxcbik6IElFbnRyeVtdID0+IHtcbiAgICAvLyBzYW5pdHkgY2hlY2sgaW5wdXRzXG4gICAgaWYgKFxuICAgICAgICBmcm9tSW5kZXggPCAwIHx8IHRvSW5kZXggPCAwIHx8XG4gICAgICAgIGZyb21JbmRleCA+IG9yZGVycy5sZW5ndGggfHwgdG9JbmRleCA+IG9yZGVycy5sZW5ndGggfHxcbiAgICAgICAgZnJvbUluZGV4ID09PSB0b0luZGV4XG4gICAgKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyB6aXAgb3JkZXJzIHdpdGggdGhlaXIgaW5kaWNlcyB0byBzaW1wbGlmeSBsYXRlciBpbmRleCB3cmFuZ2xpbmdcbiAgICBjb25zdCBvcmRlcnNXaXRoSW5kaWNlczogSUVudHJ5W10gPSBvcmRlcnMubWFwKChvcmRlciwgaW5kZXgpID0+ICh7IGluZGV4LCBvcmRlciB9KSk7XG4gICAgLy8gYXBwbHkgdGhlIGZ1bmRhbWVudGFsIG9yZGVyIHVwZGF0ZSB0byB0aGUgemlwcGVkIGFycmF5XG4gICAgY29uc3QgbmV3T3JkZXIgPSBtb3ZlRWxlbWVudChvcmRlcnNXaXRoSW5kaWNlcywgZnJvbUluZGV4LCB0b0luZGV4KTtcblxuICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgdG8gZmlsbCB1bmRlZmluZWQgb3JkZXJzIHRvIGNvbXBsZXRlIHBsYWNlbWVudFxuICAgIGNvbnN0IG9yZGVyVG9MZWZ0VW5kZWZpbmVkID0gbmV3T3JkZXJbdG9JbmRleCAtIDFdPy5vcmRlciA9PT0gdW5kZWZpbmVkO1xuXG4gICAgbGV0IGxlZnRCb3VuZElkeCA9IHRvSW5kZXg7XG4gICAgbGV0IHJpZ2h0Qm91bmRJZHggPSB0b0luZGV4O1xuXG4gICAgbGV0IGNhbk1vdmVMZWZ0ID0gdHJ1ZTtcbiAgICBjb25zdCBuZXh0QmFzZSA9IG5ld09yZGVyW3RvSW5kZXggKyAxXT8ub3JkZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHN0cmluZ1RvQmFzZShuZXdPcmRlclt0b0luZGV4ICsgMV0ub3JkZXIpXG4gICAgICAgIDogQmlnSW50KE51bWJlci5NQVhfVkFMVUUpO1xuXG4gICAgLy8gY2hlY2sgaG93IGZhciBsZWZ0IHdlIHdvdWxkIGhhdmUgdG8gbXV0YXRlIHRvIGZpdCBpbiB0aGF0IGRpcmVjdGlvblxuICAgIGZvciAobGV0IGkgPSB0b0luZGV4IC0gMSwgaiA9IDE7IGkgPj0gMDsgaS0tLCBqKyspIHtcbiAgICAgICAgaWYgKG5ld09yZGVyW2ldPy5vcmRlciAhPT0gdW5kZWZpbmVkICYmIG5leHRCYXNlIC0gc3RyaW5nVG9CYXNlKG5ld09yZGVyW2ldLm9yZGVyKSA+IGopIGJyZWFrO1xuICAgICAgICBsZWZ0Qm91bmRJZHggPSBpO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSB0aGUgbGVmdCBtb3ZlIHdvdWxkIGJlIHN1ZmZpY2llbnRcbiAgICBjb25zdCBmaXJzdE9yZGVyQmFzZSA9IG5ld09yZGVyWzBdLm9yZGVyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzdHJpbmdUb0Jhc2UobmV3T3JkZXJbMF0ub3JkZXIpO1xuICAgIGNvbnN0IGJpZ1RvSW5kZXggPSBCaWdJbnQodG9JbmRleCk7XG4gICAgaWYgKGxlZnRCb3VuZElkeCA9PT0gMCAmJlxuICAgICAgICBmaXJzdE9yZGVyQmFzZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG5leHRCYXNlIC0gZmlyc3RPcmRlckJhc2UgPD0gYmlnVG9JbmRleCAmJlxuICAgICAgICBmaXJzdE9yZGVyQmFzZSA8PSBiaWdUb0luZGV4XG4gICAgKSB7XG4gICAgICAgIGNhbk1vdmVMZWZ0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY2FuRGlzcGxhY2VSaWdodCA9ICFvcmRlclRvTGVmdFVuZGVmaW5lZDtcbiAgICBsZXQgY2FuTW92ZVJpZ2h0ID0gY2FuRGlzcGxhY2VSaWdodDtcbiAgICBpZiAoY2FuRGlzcGxhY2VSaWdodCkge1xuICAgICAgICBjb25zdCBwcmV2QmFzZSA9IG5ld09yZGVyW3RvSW5kZXggLSAxXT8ub3JkZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBzdHJpbmdUb0Jhc2UobmV3T3JkZXJbdG9JbmRleCAtIDFdPy5vcmRlcilcbiAgICAgICAgICAgIDogQmlnSW50KE51bWJlci5NSU5fVkFMVUUpO1xuXG4gICAgICAgIC8vIGNoZWNrIGhvdyBmYXIgcmlnaHQgd2Ugd291bGQgaGF2ZSB0byBtdXRhdGUgdG8gZml0IGluIHRoYXQgZGlyZWN0aW9uXG4gICAgICAgIGZvciAobGV0IGkgPSB0b0luZGV4ICsgMSwgaiA9IDE7IGkgPCBuZXdPcmRlci5sZW5ndGg7IGkrKywgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3T3JkZXJbaV0/Lm9yZGVyID09PSB1bmRlZmluZWQgfHwgc3RyaW5nVG9CYXNlKG5ld09yZGVyW2ldLm9yZGVyKSAtIHByZXZCYXNlID4gaikgYnJlYWs7XG4gICAgICAgICAgICByaWdodEJvdW5kSWR4ID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSB0aGUgcmlnaHQgbW92ZSB3b3VsZCBiZSBzdWZmaWNpZW50XG4gICAgICAgIGlmIChyaWdodEJvdW5kSWR4ID09PSBuZXdPcmRlci5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAobmV3T3JkZXJbcmlnaHRCb3VuZElkeF1cbiAgICAgICAgICAgICAgICA/IHN0cmluZ1RvQmFzZShuZXdPcmRlcltyaWdodEJvdW5kSWR4XS5vcmRlcilcbiAgICAgICAgICAgICAgICA6IEJpZ0ludChOdW1iZXIuTUFYX1ZBTFVFKSkgLSBwcmV2QmFzZSA8PSAocmlnaHRCb3VuZElkeCAtIHRvSW5kZXgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2FuTW92ZVJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBjaGVhcGVyIGRpcmVjdGlvblxuICAgIGNvbnN0IGxlZnREaWZmID0gY2FuTW92ZUxlZnQgPyB0b0luZGV4IC0gbGVmdEJvdW5kSWR4IDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgY29uc3QgcmlnaHREaWZmID0gY2FuTW92ZVJpZ2h0ID8gcmlnaHRCb3VuZElkeCAtIHRvSW5kZXggOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAob3JkZXJUb0xlZnRVbmRlZmluZWQgfHwgbGVmdERpZmYgPCByaWdodERpZmYpIHtcbiAgICAgICAgcmlnaHRCb3VuZElkeCA9IHRvSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdEJvdW5kSWR4ID0gdG9JbmRleDtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2T3JkZXIgPSBuZXdPcmRlcltsZWZ0Qm91bmRJZHggLSAxXT8ub3JkZXIgPz8gXCJcIjtcbiAgICBjb25zdCBuZXh0T3JkZXIgPSBuZXdPcmRlcltyaWdodEJvdW5kSWR4ICsgMV0/Lm9yZGVyXG4gICAgICAgID8/IERFRkFVTFRfQUxQSEFCRVQuY2hhckF0KERFRkFVTFRfQUxQSEFCRVQubGVuZ3RoIC0gMSkucmVwZWF0KHByZXZPcmRlci5sZW5ndGggfHwgMSk7XG5cbiAgICBjb25zdCBjaGFuZ2VzID0gbWlkUG9pbnRzQmV0d2VlblN0cmluZ3MocHJldk9yZGVyLCBuZXh0T3JkZXIsIDEgKyByaWdodEJvdW5kSWR4IC0gbGVmdEJvdW5kSWR4LCBtYXhMZW4pO1xuXG4gICAgcmV0dXJuIGNoYW5nZXMubWFwKChvcmRlciwgaSkgPT4gKHtcbiAgICAgICAgaW5kZXg6IG5ld09yZGVyW2xlZnRCb3VuZElkeCArIGldLmluZGV4LFxuICAgICAgICBvcmRlcixcbiAgICB9KSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQWdCQTs7QUFFQTs7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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