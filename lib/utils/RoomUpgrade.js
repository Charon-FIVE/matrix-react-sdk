"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.awaitRoomDownSync = awaitRoomDownSync;
exports.upgradeRoom = upgradeRoom;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _event = require("matrix-js-sdk/src/@types/event");

var _logger = require("matrix-js-sdk/src/logger");

var _client = require("matrix-js-sdk/src/client");

var _RoomInvite = require("../RoomInvite");

var _Modal = _interopRequireDefault(require("../Modal"));

var _languageHandler = require("../languageHandler");

var _ErrorDialog = _interopRequireDefault(require("../components/views/dialogs/ErrorDialog"));

var _SpaceStore = _interopRequireDefault(require("../stores/spaces/SpaceStore"));

var _Spinner = _interopRequireDefault(require("../components/views/elements/Spinner"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

async function awaitRoomDownSync(cli, roomId) {
  const room = cli.getRoom(roomId);
  if (room) return room; // already have the room

  return new Promise(resolve => {
    // We have to wait for the js-sdk to give us the room back so
    // we can more effectively abuse the MultiInviter behaviour
    // which heavily relies on the Room object being available.
    const checkForRoomFn = room => {
      if (room.roomId !== roomId) return;
      resolve(room);
      cli.off(_client.ClientEvent.Room, checkForRoomFn);
    };

    cli.on(_client.ClientEvent.Room, checkForRoomFn);
  });
}

async function upgradeRoom(room, targetVersion) {
  let inviteUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let handleError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  let updateSpaces = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  let awaitRoom = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  let progressCallback = arguments.length > 6 ? arguments[6] : undefined;
  const cli = room.client;
  let spinnerModal;

  if (!progressCallback) {
    spinnerModal = _Modal.default.createDialog(_Spinner.default, null, "mx_Dialog_spinner");
  }

  let toInvite = [];

  if (inviteUsers) {
    toInvite = [...room.getMembersWithMembership("join"), ...room.getMembersWithMembership("invite")].map(m => m.userId).filter(m => m !== cli.getUserId());
  }

  let parentsToRelink = [];

  if (updateSpaces) {
    parentsToRelink = Array.from(_SpaceStore.default.instance.getKnownParents(room.roomId)).map(roomId => cli.getRoom(roomId)).filter(parent => parent?.currentState.maySendStateEvent(_event.EventType.SpaceChild, cli.getUserId()));
  }

  const progress = {
    roomUpgraded: false,
    roomSynced: awaitRoom || inviteUsers ? false : undefined,
    inviteUsersProgress: inviteUsers ? 0 : undefined,
    inviteUsersTotal: toInvite.length,
    updateSpacesProgress: updateSpaces ? 0 : undefined,
    updateSpacesTotal: parentsToRelink.length
  };
  progressCallback?.(progress);
  let newRoomId;

  try {
    ({
      replacement_room: newRoomId
    } = await cli.upgradeRoom(room.roomId, targetVersion));
  } catch (e) {
    if (!handleError) throw e;

    _logger.logger.error(e);

    _Modal.default.createDialog(_ErrorDialog.default, {
      title: (0, _languageHandler._t)('Error upgrading room'),
      description: (0, _languageHandler._t)('Double check that your server supports the room version chosen and try again.')
    });

    throw e;
  }

  progress.roomUpgraded = true;
  progressCallback?.(progress);

  if (awaitRoom || inviteUsers) {
    await awaitRoomDownSync(room.client, newRoomId);
    progress.roomSynced = true;
    progressCallback?.(progress);
  }

  if (toInvite.length > 0) {
    // Errors are handled internally to this function
    await (0, _RoomInvite.inviteUsersToRoom)(newRoomId, toInvite, false, () => {
      progress.inviteUsersProgress++;
      progressCallback?.(progress);
    });
  }

  if (parentsToRelink.length > 0) {
    try {
      for (const parent of parentsToRelink) {
        const currentEv = parent.currentState.getStateEvents(_event.EventType.SpaceChild, room.roomId);
        await cli.sendStateEvent(parent.roomId, _event.EventType.SpaceChild, _objectSpread(_objectSpread({}, currentEv?.getContent() || {}), {}, {
          // copy existing attributes like suggested
          via: [cli.getDomain()]
        }), newRoomId);
        await cli.sendStateEvent(parent.roomId, _event.EventType.SpaceChild, {}, room.roomId);
        progress.updateSpacesProgress++;
        progressCallback?.(progress);
      }
    } catch (e) {
      // These errors are not critical to the room upgrade itself
      _logger.logger.warn("Failed to update parent spaces during room upgrade", e);
    }
  }

  spinnerModal?.close();
  return newRoomId;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhd2FpdFJvb21Eb3duU3luYyIsImNsaSIsInJvb21JZCIsInJvb20iLCJnZXRSb29tIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjaGVja0ZvclJvb21GbiIsIm9mZiIsIkNsaWVudEV2ZW50IiwiUm9vbSIsIm9uIiwidXBncmFkZVJvb20iLCJ0YXJnZXRWZXJzaW9uIiwiaW52aXRlVXNlcnMiLCJoYW5kbGVFcnJvciIsInVwZGF0ZVNwYWNlcyIsImF3YWl0Um9vbSIsInByb2dyZXNzQ2FsbGJhY2siLCJjbGllbnQiLCJzcGlubmVyTW9kYWwiLCJNb2RhbCIsImNyZWF0ZURpYWxvZyIsIlNwaW5uZXIiLCJ0b0ludml0ZSIsImdldE1lbWJlcnNXaXRoTWVtYmVyc2hpcCIsIm1hcCIsIm0iLCJ1c2VySWQiLCJmaWx0ZXIiLCJnZXRVc2VySWQiLCJwYXJlbnRzVG9SZWxpbmsiLCJBcnJheSIsImZyb20iLCJTcGFjZVN0b3JlIiwiaW5zdGFuY2UiLCJnZXRLbm93blBhcmVudHMiLCJwYXJlbnQiLCJjdXJyZW50U3RhdGUiLCJtYXlTZW5kU3RhdGVFdmVudCIsIkV2ZW50VHlwZSIsIlNwYWNlQ2hpbGQiLCJwcm9ncmVzcyIsInJvb21VcGdyYWRlZCIsInJvb21TeW5jZWQiLCJ1bmRlZmluZWQiLCJpbnZpdGVVc2Vyc1Byb2dyZXNzIiwiaW52aXRlVXNlcnNUb3RhbCIsImxlbmd0aCIsInVwZGF0ZVNwYWNlc1Byb2dyZXNzIiwidXBkYXRlU3BhY2VzVG90YWwiLCJuZXdSb29tSWQiLCJyZXBsYWNlbWVudF9yb29tIiwiZSIsImxvZ2dlciIsImVycm9yIiwiRXJyb3JEaWFsb2ciLCJ0aXRsZSIsIl90IiwiZGVzY3JpcHRpb24iLCJpbnZpdGVVc2Vyc1RvUm9vbSIsImN1cnJlbnRFdiIsImdldFN0YXRlRXZlbnRzIiwic2VuZFN0YXRlRXZlbnQiLCJnZXRDb250ZW50IiwidmlhIiwiZ2V0RG9tYWluIiwid2FybiIsImNsb3NlIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL1Jvb21VcGdyYWRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IFJvb20gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL3Jvb21cIjtcbmltcG9ydCB7IEV2ZW50VHlwZSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9AdHlwZXMvZXZlbnRcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcbmltcG9ydCB7IENsaWVudEV2ZW50LCBNYXRyaXhDbGllbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY2xpZW50XCI7XG5cbmltcG9ydCB7IGludml0ZVVzZXJzVG9Sb29tIH0gZnJvbSBcIi4uL1Jvb21JbnZpdGVcIjtcbmltcG9ydCBNb2RhbCwgeyBJSGFuZGxlIH0gZnJvbSBcIi4uL01vZGFsXCI7XG5pbXBvcnQgeyBfdCB9IGZyb20gXCIuLi9sYW5ndWFnZUhhbmRsZXJcIjtcbmltcG9ydCBFcnJvckRpYWxvZyBmcm9tIFwiLi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL0Vycm9yRGlhbG9nXCI7XG5pbXBvcnQgU3BhY2VTdG9yZSBmcm9tIFwiLi4vc3RvcmVzL3NwYWNlcy9TcGFjZVN0b3JlXCI7XG5pbXBvcnQgU3Bpbm5lciBmcm9tIFwiLi4vY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9TcGlubmVyXCI7XG5cbmludGVyZmFjZSBJUHJvZ3Jlc3Mge1xuICAgIHJvb21VcGdyYWRlZDogYm9vbGVhbjtcbiAgICByb29tU3luY2VkPzogYm9vbGVhbjtcbiAgICBpbnZpdGVVc2Vyc1Byb2dyZXNzPzogbnVtYmVyO1xuICAgIGludml0ZVVzZXJzVG90YWw6IG51bWJlcjtcbiAgICB1cGRhdGVTcGFjZXNQcm9ncmVzcz86IG51bWJlcjtcbiAgICB1cGRhdGVTcGFjZXNUb3RhbDogbnVtYmVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXdhaXRSb29tRG93blN5bmMoY2xpOiBNYXRyaXhDbGllbnQsIHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tPiB7XG4gICAgY29uc3Qgcm9vbSA9IGNsaS5nZXRSb29tKHJvb21JZCk7XG4gICAgaWYgKHJvb20pIHJldHVybiByb29tOyAvLyBhbHJlYWR5IGhhdmUgdGhlIHJvb21cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxSb29tPihyZXNvbHZlID0+IHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3YWl0IGZvciB0aGUganMtc2RrIHRvIGdpdmUgdXMgdGhlIHJvb20gYmFjayBzb1xuICAgICAgICAvLyB3ZSBjYW4gbW9yZSBlZmZlY3RpdmVseSBhYnVzZSB0aGUgTXVsdGlJbnZpdGVyIGJlaGF2aW91clxuICAgICAgICAvLyB3aGljaCBoZWF2aWx5IHJlbGllcyBvbiB0aGUgUm9vbSBvYmplY3QgYmVpbmcgYXZhaWxhYmxlLlxuICAgICAgICBjb25zdCBjaGVja0ZvclJvb21GbiA9IChyb29tOiBSb29tKSA9PiB7XG4gICAgICAgICAgICBpZiAocm9vbS5yb29tSWQgIT09IHJvb21JZCkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzb2x2ZShyb29tKTtcbiAgICAgICAgICAgIGNsaS5vZmYoQ2xpZW50RXZlbnQuUm9vbSwgY2hlY2tGb3JSb29tRm4pO1xuICAgICAgICB9O1xuICAgICAgICBjbGkub24oQ2xpZW50RXZlbnQuUm9vbSwgY2hlY2tGb3JSb29tRm4pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBncmFkZVJvb20oXG4gICAgcm9vbTogUm9vbSxcbiAgICB0YXJnZXRWZXJzaW9uOiBzdHJpbmcsXG4gICAgaW52aXRlVXNlcnMgPSBmYWxzZSxcbiAgICBoYW5kbGVFcnJvciA9IHRydWUsXG4gICAgdXBkYXRlU3BhY2VzID0gdHJ1ZSxcbiAgICBhd2FpdFJvb20gPSBmYWxzZSxcbiAgICBwcm9ncmVzc0NhbGxiYWNrPzogKHByb2dyZXNzOiBJUHJvZ3Jlc3MpID0+IHZvaWQsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGNsaSA9IHJvb20uY2xpZW50O1xuICAgIGxldCBzcGlubmVyTW9kYWw6IElIYW5kbGU8YW55PjtcbiAgICBpZiAoIXByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgc3Bpbm5lck1vZGFsID0gTW9kYWwuY3JlYXRlRGlhbG9nKFNwaW5uZXIsIG51bGwsIFwibXhfRGlhbG9nX3NwaW5uZXJcIik7XG4gICAgfVxuXG4gICAgbGV0IHRvSW52aXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChpbnZpdGVVc2Vycykge1xuICAgICAgICB0b0ludml0ZSA9IFtcbiAgICAgICAgICAgIC4uLnJvb20uZ2V0TWVtYmVyc1dpdGhNZW1iZXJzaGlwKFwiam9pblwiKSxcbiAgICAgICAgICAgIC4uLnJvb20uZ2V0TWVtYmVyc1dpdGhNZW1iZXJzaGlwKFwiaW52aXRlXCIpLFxuICAgICAgICBdLm1hcChtID0+IG0udXNlcklkKS5maWx0ZXIobSA9PiBtICE9PSBjbGkuZ2V0VXNlcklkKCkpO1xuICAgIH1cblxuICAgIGxldCBwYXJlbnRzVG9SZWxpbms6IFJvb21bXSA9IFtdO1xuICAgIGlmICh1cGRhdGVTcGFjZXMpIHtcbiAgICAgICAgcGFyZW50c1RvUmVsaW5rID0gQXJyYXkuZnJvbShTcGFjZVN0b3JlLmluc3RhbmNlLmdldEtub3duUGFyZW50cyhyb29tLnJvb21JZCkpXG4gICAgICAgICAgICAubWFwKHJvb21JZCA9PiBjbGkuZ2V0Um9vbShyb29tSWQpKVxuICAgICAgICAgICAgLmZpbHRlcihwYXJlbnQgPT4gcGFyZW50Py5jdXJyZW50U3RhdGUubWF5U2VuZFN0YXRlRXZlbnQoRXZlbnRUeXBlLlNwYWNlQ2hpbGQsIGNsaS5nZXRVc2VySWQoKSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2dyZXNzOiBJUHJvZ3Jlc3MgPSB7XG4gICAgICAgIHJvb21VcGdyYWRlZDogZmFsc2UsXG4gICAgICAgIHJvb21TeW5jZWQ6IChhd2FpdFJvb20gfHwgaW52aXRlVXNlcnMpID8gZmFsc2UgOiB1bmRlZmluZWQsXG4gICAgICAgIGludml0ZVVzZXJzUHJvZ3Jlc3M6IGludml0ZVVzZXJzID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgaW52aXRlVXNlcnNUb3RhbDogdG9JbnZpdGUubGVuZ3RoLFxuICAgICAgICB1cGRhdGVTcGFjZXNQcm9ncmVzczogdXBkYXRlU3BhY2VzID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXBkYXRlU3BhY2VzVG90YWw6IHBhcmVudHNUb1JlbGluay5sZW5ndGgsXG4gICAgfTtcbiAgICBwcm9ncmVzc0NhbGxiYWNrPy4ocHJvZ3Jlc3MpO1xuXG4gICAgbGV0IG5ld1Jvb21JZDogc3RyaW5nO1xuICAgIHRyeSB7XG4gICAgICAgICh7IHJlcGxhY2VtZW50X3Jvb206IG5ld1Jvb21JZCB9ID0gYXdhaXQgY2xpLnVwZ3JhZGVSb29tKHJvb20ucm9vbUlkLCB0YXJnZXRWZXJzaW9uKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIWhhbmRsZUVycm9yKSB0aHJvdyBlO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG5cbiAgICAgICAgTW9kYWwuY3JlYXRlRGlhbG9nKEVycm9yRGlhbG9nLCB7XG4gICAgICAgICAgICB0aXRsZTogX3QoJ0Vycm9yIHVwZ3JhZGluZyByb29tJyksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogX3QoJ0RvdWJsZSBjaGVjayB0aGF0IHlvdXIgc2VydmVyIHN1cHBvcnRzIHRoZSByb29tIHZlcnNpb24gY2hvc2VuIGFuZCB0cnkgYWdhaW4uJyksXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHByb2dyZXNzLnJvb21VcGdyYWRlZCA9IHRydWU7XG4gICAgcHJvZ3Jlc3NDYWxsYmFjaz8uKHByb2dyZXNzKTtcblxuICAgIGlmIChhd2FpdFJvb20gfHwgaW52aXRlVXNlcnMpIHtcbiAgICAgICAgYXdhaXQgYXdhaXRSb29tRG93blN5bmMocm9vbS5jbGllbnQsIG5ld1Jvb21JZCk7XG4gICAgICAgIHByb2dyZXNzLnJvb21TeW5jZWQgPSB0cnVlO1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrPy4ocHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmICh0b0ludml0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEVycm9ycyBhcmUgaGFuZGxlZCBpbnRlcm5hbGx5IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgYXdhaXQgaW52aXRlVXNlcnNUb1Jvb20obmV3Um9vbUlkLCB0b0ludml0ZSwgZmFsc2UsICgpID0+IHtcbiAgICAgICAgICAgIHByb2dyZXNzLmludml0ZVVzZXJzUHJvZ3Jlc3MrKztcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lihwcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnRzVG9SZWxpbmsubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50c1RvUmVsaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEV2ID0gcGFyZW50LmN1cnJlbnRTdGF0ZS5nZXRTdGF0ZUV2ZW50cyhFdmVudFR5cGUuU3BhY2VDaGlsZCwgcm9vbS5yb29tSWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNsaS5zZW5kU3RhdGVFdmVudChwYXJlbnQucm9vbUlkLCBFdmVudFR5cGUuU3BhY2VDaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICAuLi4oY3VycmVudEV2Py5nZXRDb250ZW50KCkgfHwge30pLCAvLyBjb3B5IGV4aXN0aW5nIGF0dHJpYnV0ZXMgbGlrZSBzdWdnZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmlhOiBbY2xpLmdldERvbWFpbigpXSxcbiAgICAgICAgICAgICAgICB9LCBuZXdSb29tSWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNsaS5zZW5kU3RhdGVFdmVudChwYXJlbnQucm9vbUlkLCBFdmVudFR5cGUuU3BhY2VDaGlsZCwge30sIHJvb20ucm9vbUlkKTtcblxuICAgICAgICAgICAgICAgIHByb2dyZXNzLnVwZGF0ZVNwYWNlc1Byb2dyZXNzKys7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjaz8uKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgZXJyb3JzIGFyZSBub3QgY3JpdGljYWwgdG8gdGhlIHJvb20gdXBncmFkZSBpdHNlbGZcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHVwZGF0ZSBwYXJlbnQgc3BhY2VzIGR1cmluZyByb29tIHVwZ3JhZGVcIiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzcGlubmVyTW9kYWw/LmNsb3NlKCk7XG4gICAgcmV0dXJuIG5ld1Jvb21JZDtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBaUJBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFXTyxlQUFlQSxpQkFBZixDQUFpQ0MsR0FBakMsRUFBb0RDLE1BQXBELEVBQW1GO0VBQ3RGLE1BQU1DLElBQUksR0FBR0YsR0FBRyxDQUFDRyxPQUFKLENBQVlGLE1BQVosQ0FBYjtFQUNBLElBQUlDLElBQUosRUFBVSxPQUFPQSxJQUFQLENBRjRFLENBRS9EOztFQUV2QixPQUFPLElBQUlFLE9BQUosQ0FBa0JDLE9BQU8sSUFBSTtJQUNoQztJQUNBO0lBQ0E7SUFDQSxNQUFNQyxjQUFjLEdBQUlKLElBQUQsSUFBZ0I7TUFDbkMsSUFBSUEsSUFBSSxDQUFDRCxNQUFMLEtBQWdCQSxNQUFwQixFQUE0QjtNQUM1QkksT0FBTyxDQUFDSCxJQUFELENBQVA7TUFDQUYsR0FBRyxDQUFDTyxHQUFKLENBQVFDLG1CQUFBLENBQVlDLElBQXBCLEVBQTBCSCxjQUExQjtJQUNILENBSkQ7O0lBS0FOLEdBQUcsQ0FBQ1UsRUFBSixDQUFPRixtQkFBQSxDQUFZQyxJQUFuQixFQUF5QkgsY0FBekI7RUFDSCxDQVZNLENBQVA7QUFXSDs7QUFFTSxlQUFlSyxXQUFmLENBQ0hULElBREcsRUFFSFUsYUFGRyxFQVFZO0VBQUEsSUFMZkMsV0FLZSx1RUFMRCxLQUtDO0VBQUEsSUFKZkMsV0FJZSx1RUFKRCxJQUlDO0VBQUEsSUFIZkMsWUFHZSx1RUFIQSxJQUdBO0VBQUEsSUFGZkMsU0FFZSx1RUFGSCxLQUVHO0VBQUEsSUFEZkMsZ0JBQ2U7RUFDZixNQUFNakIsR0FBRyxHQUFHRSxJQUFJLENBQUNnQixNQUFqQjtFQUNBLElBQUlDLFlBQUo7O0VBQ0EsSUFBSSxDQUFDRixnQkFBTCxFQUF1QjtJQUNu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