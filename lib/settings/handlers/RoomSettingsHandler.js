"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _roomState = require("matrix-js-sdk/src/models/room-state");

var _utils = require("matrix-js-sdk/src/utils");

var _MatrixClientBackedSettingsHandler = _interopRequireDefault(require("./MatrixClientBackedSettingsHandler"));

var _objects = require("../../utils/objects");

var _SettingLevel = require("../SettingLevel");

/*
Copyright 2017 Travis Ralston
Copyright 2019, 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const DEFAULT_SETTINGS_EVENT_TYPE = "im.vector.web.settings";
/**
 * Gets and sets settings at the "room" level.
 */

class RoomSettingsHandler extends _MatrixClientBackedSettingsHandler.default {
  constructor(watchers) {
    super();
    this.watchers = watchers;
    (0, _defineProperty2.default)(this, "onEvent", (event, state, prevEvent) => {
      const roomId = event.getRoomId();
      const room = this.client.getRoom(roomId); // Note: in tests and during the encryption setup on initial load we might not have
      // rooms in the store, so we just quietly ignore the problem. If we log it then we'll
      // just end up spamming the logs a few thousand times. It is perfectly fine for us
      // to ignore the problem as the app will not have loaded enough to care yet.

      if (!room) return; // ignore state updates which are not current

      if (room && state !== room.currentState) return;

      if (event.getType() === "org.matrix.room.preview_urls") {
        let val = event.getContent()['disable'];

        if (typeof val !== "boolean") {
          val = null;
        } else {
          val = !val;
        }

        this.watchers.notifyUpdate("urlPreviewsEnabled", roomId, _SettingLevel.SettingLevel.ROOM, val);
      } else if (event.getType() === DEFAULT_SETTINGS_EVENT_TYPE) {
        // Figure out what changed and fire those updates
        const prevContent = prevEvent ? prevEvent.getContent() : {};
        const changedSettings = (0, _objects.objectKeyChanges)(prevContent, event.getContent());

        for (const settingName of changedSettings) {
          this.watchers.notifyUpdate(settingName, roomId, _SettingLevel.SettingLevel.ROOM, event.getContent()[settingName]);
        }
      }
    });
  }

  initMatrixClient(oldClient, newClient) {
    if (oldClient) {
      oldClient.removeListener(_roomState.RoomStateEvent.Events, this.onEvent);
    }

    newClient.on(_roomState.RoomStateEvent.Events, this.onEvent);
  }

  getValue(settingName, roomId) {
    // Special case URL previews
    if (settingName === "urlPreviewsEnabled") {
      const content = this.getSettings(roomId, "org.matrix.room.preview_urls") || {}; // Check to make sure that we actually got a boolean

      if (typeof content['disable'] !== "boolean") return null;
      return !content['disable'];
    }

    const settings = this.getSettings(roomId) || {};
    return settings[settingName];
  } // helper function to send state event then await it being echoed back


  async sendStateEvent(roomId, eventType, field, value) {
    const content = this.getSettings(roomId, eventType) || {};
    content[field] = value;
    const {
      event_id: eventId
    } = await this.client.sendStateEvent(roomId, eventType, content);
    const deferred = (0, _utils.defer)();

    const handler = event => {
      if (event.getId() !== eventId) return;
      this.client.off(_roomState.RoomStateEvent.Events, handler);
      deferred.resolve();
    };

    this.client.on(_roomState.RoomStateEvent.Events, handler);
    await deferred.promise;
  }

  setValue(settingName, roomId, newValue) {
    switch (settingName) {
      // Special case URL previews
      case "urlPreviewsEnabled":
        return this.sendStateEvent(roomId, "org.matrix.room.preview_urls", "disable", !newValue);

      default:
        return this.sendStateEvent(roomId, DEFAULT_SETTINGS_EVENT_TYPE, settingName, newValue);
    }
  }

  canSetValue(settingName, roomId) {
    const room = this.client.getRoom(roomId);
    let eventType = DEFAULT_SETTINGS_EVENT_TYPE;
    if (settingName === "urlPreviewsEnabled") eventType = "org.matrix.room.preview_urls";
    return room?.currentState.maySendStateEvent(eventType, this.client.getUserId()) ?? false;
  }

  isSupported() {
    return !!this.client;
  }

  getSettings(roomId) {
    let eventType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SETTINGS_EVENT_TYPE;
    const event = this.client.getRoom(roomId)?.currentState.getStateEvents(eventType, "");
    if (!event?.getContent()) return null;
    return (0, _objects.objectClone)(event.getContent()); // clone to prevent mutation
  }

}

exports.default = RoomSettingsHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJERUZBVUxUX1NFVFRJTkdTX0VWRU5UX1RZUEUiLCJSb29tU2V0dGluZ3NIYW5kbGVyIiwiTWF0cml4Q2xpZW50QmFja2VkU2V0dGluZ3NIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJ3YXRjaGVycyIsImV2ZW50Iiwic3RhdGUiLCJwcmV2RXZlbnQiLCJyb29tSWQiLCJnZXRSb29tSWQiLCJyb29tIiwiY2xpZW50IiwiZ2V0Um9vbSIsImN1cnJlbnRTdGF0ZSIsImdldFR5cGUiLCJ2YWwiLCJnZXRDb250ZW50Iiwibm90aWZ5VXBkYXRlIiwiU2V0dGluZ0xldmVsIiwiUk9PTSIsInByZXZDb250ZW50IiwiY2hhbmdlZFNldHRpbmdzIiwib2JqZWN0S2V5Q2hhbmdlcyIsInNldHRpbmdOYW1lIiwiaW5pdE1hdHJpeENsaWVudCIsIm9sZENsaWVudCIsIm5ld0NsaWVudCIsInJlbW92ZUxpc3RlbmVyIiwiUm9vbVN0YXRlRXZlbnQiLCJFdmVudHMiLCJvbkV2ZW50Iiwib24iLCJnZXRWYWx1ZSIsImNvbnRlbnQiLCJnZXRTZXR0aW5ncyIsInNldHRpbmdzIiwic2VuZFN0YXRlRXZlbnQiLCJldmVudFR5cGUiLCJmaWVsZCIsInZhbHVlIiwiZXZlbnRfaWQiLCJldmVudElkIiwiZGVmZXJyZWQiLCJkZWZlciIsImhhbmRsZXIiLCJnZXRJZCIsIm9mZiIsInJlc29sdmUiLCJwcm9taXNlIiwic2V0VmFsdWUiLCJuZXdWYWx1ZSIsImNhblNldFZhbHVlIiwibWF5U2VuZFN0YXRlRXZlbnQiLCJnZXRVc2VySWQiLCJpc1N1cHBvcnRlZCIsImdldFN0YXRlRXZlbnRzIiwib2JqZWN0Q2xvbmUiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc2V0dGluZ3MvaGFuZGxlcnMvUm9vbVNldHRpbmdzSGFuZGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTcgVHJhdmlzIFJhbHN0b25cbkNvcHlyaWdodCAyMDE5LCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgTWF0cml4Q2xpZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NsaWVudFwiO1xuaW1wb3J0IHsgTWF0cml4RXZlbnQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbW9kZWxzL2V2ZW50XCI7XG5pbXBvcnQgeyBSb29tU3RhdGUsIFJvb21TdGF0ZUV2ZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tLXN0YXRlXCI7XG5pbXBvcnQgeyBkZWZlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy91dGlsc1wiO1xuXG5pbXBvcnQgTWF0cml4Q2xpZW50QmFja2VkU2V0dGluZ3NIYW5kbGVyIGZyb20gXCIuL01hdHJpeENsaWVudEJhY2tlZFNldHRpbmdzSGFuZGxlclwiO1xuaW1wb3J0IHsgb2JqZWN0Q2xvbmUsIG9iamVjdEtleUNoYW5nZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvb2JqZWN0c1wiO1xuaW1wb3J0IHsgU2V0dGluZ0xldmVsIH0gZnJvbSBcIi4uL1NldHRpbmdMZXZlbFwiO1xuaW1wb3J0IHsgV2F0Y2hNYW5hZ2VyIH0gZnJvbSBcIi4uL1dhdGNoTWFuYWdlclwiO1xuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTX0VWRU5UX1RZUEUgPSBcImltLnZlY3Rvci53ZWIuc2V0dGluZ3NcIjtcblxuLyoqXG4gKiBHZXRzIGFuZCBzZXRzIHNldHRpbmdzIGF0IHRoZSBcInJvb21cIiBsZXZlbC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm9vbVNldHRpbmdzSGFuZGxlciBleHRlbmRzIE1hdHJpeENsaWVudEJhY2tlZFNldHRpbmdzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHdhdGNoZXJzOiBXYXRjaE1hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaW5pdE1hdHJpeENsaWVudChvbGRDbGllbnQ6IE1hdHJpeENsaWVudCwgbmV3Q2xpZW50OiBNYXRyaXhDbGllbnQpIHtcbiAgICAgICAgaWYgKG9sZENsaWVudCkge1xuICAgICAgICAgICAgb2xkQ2xpZW50LnJlbW92ZUxpc3RlbmVyKFJvb21TdGF0ZUV2ZW50LkV2ZW50cywgdGhpcy5vbkV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0NsaWVudC5vbihSb29tU3RhdGVFdmVudC5FdmVudHMsIHRoaXMub25FdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkV2ZW50ID0gKGV2ZW50OiBNYXRyaXhFdmVudCwgc3RhdGU6IFJvb21TdGF0ZSwgcHJldkV2ZW50OiBNYXRyaXhFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCByb29tSWQgPSBldmVudC5nZXRSb29tSWQoKTtcbiAgICAgICAgY29uc3Qgcm9vbSA9IHRoaXMuY2xpZW50LmdldFJvb20ocm9vbUlkKTtcblxuICAgICAgICAvLyBOb3RlOiBpbiB0ZXN0cyBhbmQgZHVyaW5nIHRoZSBlbmNyeXB0aW9uIHNldHVwIG9uIGluaXRpYWwgbG9hZCB3ZSBtaWdodCBub3QgaGF2ZVxuICAgICAgICAvLyByb29tcyBpbiB0aGUgc3RvcmUsIHNvIHdlIGp1c3QgcXVpZXRseSBpZ25vcmUgdGhlIHByb2JsZW0uIElmIHdlIGxvZyBpdCB0aGVuIHdlJ2xsXG4gICAgICAgIC8vIGp1c3QgZW5kIHVwIHNwYW1taW5nIHRoZSBsb2dzIGEgZmV3IHRob3VzYW5kIHRpbWVzLiBJdCBpcyBwZXJmZWN0bHkgZmluZSBmb3IgdXNcbiAgICAgICAgLy8gdG8gaWdub3JlIHRoZSBwcm9ibGVtIGFzIHRoZSBhcHAgd2lsbCBub3QgaGF2ZSBsb2FkZWQgZW5vdWdoIHRvIGNhcmUgeWV0LlxuICAgICAgICBpZiAoIXJvb20pIHJldHVybjtcblxuICAgICAgICAvLyBpZ25vcmUgc3RhdGUgdXBkYXRlcyB3aGljaCBhcmUgbm90IGN1cnJlbnRcbiAgICAgICAgaWYgKHJvb20gJiYgc3RhdGUgIT09IHJvb20uY3VycmVudFN0YXRlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGV2ZW50LmdldFR5cGUoKSA9PT0gXCJvcmcubWF0cml4LnJvb20ucHJldmlld191cmxzXCIpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBldmVudC5nZXRDb250ZW50KClbJ2Rpc2FibGUnXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbCkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gIXZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy53YXRjaGVycy5ub3RpZnlVcGRhdGUoXCJ1cmxQcmV2aWV3c0VuYWJsZWRcIiwgcm9vbUlkLCBTZXR0aW5nTGV2ZWwuUk9PTSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5nZXRUeXBlKCkgPT09IERFRkFVTFRfU0VUVElOR1NfRVZFTlRfVFlQRSkge1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGF0IGNoYW5nZWQgYW5kIGZpcmUgdGhvc2UgdXBkYXRlc1xuICAgICAgICAgICAgY29uc3QgcHJldkNvbnRlbnQgPSBwcmV2RXZlbnQgPyBwcmV2RXZlbnQuZ2V0Q29udGVudCgpIDoge307XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkU2V0dGluZ3MgPSBvYmplY3RLZXlDaGFuZ2VzPFJlY29yZDxzdHJpbmcsIGFueT4+KHByZXZDb250ZW50LCBldmVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nTmFtZSBvZiBjaGFuZ2VkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoZXJzLm5vdGlmeVVwZGF0ZShzZXR0aW5nTmFtZSwgcm9vbUlkLCBTZXR0aW5nTGV2ZWwuUk9PTSwgZXZlbnQuZ2V0Q29udGVudCgpW3NldHRpbmdOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHVibGljIGdldFZhbHVlKHNldHRpbmdOYW1lOiBzdHJpbmcsIHJvb21JZDogc3RyaW5nKTogYW55IHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIFVSTCBwcmV2aWV3c1xuICAgICAgICBpZiAoc2V0dGluZ05hbWUgPT09IFwidXJsUHJldmlld3NFbmFibGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldFNldHRpbmdzKHJvb21JZCwgXCJvcmcubWF0cml4LnJvb20ucHJldmlld191cmxzXCIpIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhhdCB3ZSBhY3R1YWxseSBnb3QgYSBib29sZWFuXG4gICAgICAgICAgICBpZiAodHlwZW9mIChjb250ZW50WydkaXNhYmxlJ10pICE9PSBcImJvb2xlYW5cIikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gIWNvbnRlbnRbJ2Rpc2FibGUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5nZXRTZXR0aW5ncyhyb29tSWQpIHx8IHt9O1xuICAgICAgICByZXR1cm4gc2V0dGluZ3Nbc2V0dGluZ05hbWVdO1xuICAgIH1cblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0byBzZW5kIHN0YXRlIGV2ZW50IHRoZW4gYXdhaXQgaXQgYmVpbmcgZWNob2VkIGJhY2tcbiAgICBwcml2YXRlIGFzeW5jIHNlbmRTdGF0ZUV2ZW50KFxuICAgICAgICByb29tSWQ6IHN0cmluZyxcbiAgICAgICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgICAgIGZpZWxkOiBzdHJpbmcsXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldFNldHRpbmdzKHJvb21JZCwgZXZlbnRUeXBlKSB8fCB7fTtcbiAgICAgICAgY29udGVudFtmaWVsZF0gPSB2YWx1ZTtcblxuICAgICAgICBjb25zdCB7IGV2ZW50X2lkOiBldmVudElkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5zZW5kU3RhdGVFdmVudChyb29tSWQsIGV2ZW50VHlwZSwgY29udGVudCk7XG5cbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcjx2b2lkPigpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gKGV2ZW50OiBNYXRyaXhFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmdldElkKCkgIT09IGV2ZW50SWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50Lm9mZihSb29tU3RhdGVFdmVudC5FdmVudHMsIGhhbmRsZXIpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsaWVudC5vbihSb29tU3RhdGVFdmVudC5FdmVudHMsIGhhbmRsZXIpO1xuXG4gICAgICAgIGF3YWl0IGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFZhbHVlKHNldHRpbmdOYW1lOiBzdHJpbmcsIHJvb21JZDogc3RyaW5nLCBuZXdWYWx1ZTogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ05hbWUpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBVUkwgcHJldmlld3NcbiAgICAgICAgICAgIGNhc2UgXCJ1cmxQcmV2aWV3c0VuYWJsZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kU3RhdGVFdmVudChyb29tSWQsIFwib3JnLm1hdHJpeC5yb29tLnByZXZpZXdfdXJsc1wiLCBcImRpc2FibGVcIiwgIW5ld1ZhbHVlKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kU3RhdGVFdmVudChyb29tSWQsIERFRkFVTFRfU0VUVElOR1NfRVZFTlRfVFlQRSwgc2V0dGluZ05hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjYW5TZXRWYWx1ZShzZXR0aW5nTmFtZTogc3RyaW5nLCByb29tSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCByb29tID0gdGhpcy5jbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuXG4gICAgICAgIGxldCBldmVudFR5cGUgPSBERUZBVUxUX1NFVFRJTkdTX0VWRU5UX1RZUEU7XG4gICAgICAgIGlmIChzZXR0aW5nTmFtZSA9PT0gXCJ1cmxQcmV2aWV3c0VuYWJsZWRcIikgZXZlbnRUeXBlID0gXCJvcmcubWF0cml4LnJvb20ucHJldmlld191cmxzXCI7XG5cbiAgICAgICAgcmV0dXJuIHJvb20/LmN1cnJlbnRTdGF0ZS5tYXlTZW5kU3RhdGVFdmVudChldmVudFR5cGUsIHRoaXMuY2xpZW50LmdldFVzZXJJZCgpKSA/PyBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY2xpZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U2V0dGluZ3Mocm9vbUlkOiBzdHJpbmcsIGV2ZW50VHlwZSA9IERFRkFVTFRfU0VUVElOR1NfRVZFTlRfVFlQRSk6IGFueSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jbGllbnQuZ2V0Um9vbShyb29tSWQpPy5jdXJyZW50U3RhdGUuZ2V0U3RhdGVFdmVudHMoZXZlbnRUeXBlLCBcIlwiKTtcbiAgICAgICAgaWYgKCFldmVudD8uZ2V0Q29udGVudCgpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG9iamVjdENsb25lKGV2ZW50LmdldENvbnRlbnQoKSk7IC8vIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBbUJBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQXhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBLE1BQU1BLDJCQUEyQixHQUFHLHdCQUFwQztBQUVBO0FBQ0E7QUFDQTs7QUFDZSxNQUFNQyxtQkFBTixTQUFrQ0MsMENBQWxDLENBQW9FO0VBQy9FQyxXQUFXLENBQWlCQyxRQUFqQixFQUF5QztJQUNoRDtJQURnRCxLQUF4QkEsUUFBd0IsR0FBeEJBLFFBQXdCO0lBQUEsK0NBWWxDLENBQUNDLEtBQUQsRUFBcUJDLEtBQXJCLEVBQXVDQyxTQUF2QyxLQUFrRTtNQUNoRixNQUFNQyxNQUFNLEdBQUdILEtBQUssQ0FBQ0ksU0FBTixFQUFmO01BQ0EsTUFBTUMsSUFBSSxHQUFHLEtBQUtDLE1BQUwsQ0FBWUMsT0FBWixDQUFvQkosTUFB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