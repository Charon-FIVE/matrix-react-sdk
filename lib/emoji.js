"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmojiFromUnicode = exports.EMOTICON_TO_EMOJI = exports.EMOJI = exports.DATA_BY_CATEGORY = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _compact = _interopRequireDefault(require("emojibase-data/en/compact.json"));

var _iamcal = _interopRequireDefault(require("emojibase-data/en/shortcodes/iamcal.json"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

// The unicode is stored without the variant selector
const UNICODE_TO_EMOJI = new Map(); // not exported as gets for it are handled by getEmojiFromUnicode

const EMOTICON_TO_EMOJI = new Map();
exports.EMOTICON_TO_EMOJI = EMOTICON_TO_EMOJI;

const getEmojiFromUnicode = unicode => UNICODE_TO_EMOJI.get(stripVariation(unicode));

exports.getEmojiFromUnicode = getEmojiFromUnicode;

const isRegionalIndicator = x => {
  // First verify that the string is a single character. We use Array.from
  // to make sure we count by characters, not UTF-8 code units.
  return Array.from(x).length === 1 && // Next verify that the character is within the code point range for
  // regional indicators.
  // http://unicode.org/charts/PDF/Unicode-6.0/U60-1F100.pdf
  x >= '\u{1f1e6}' && x <= '\u{1f1ff}';
};

const EMOJIBASE_GROUP_ID_TO_CATEGORY = ["people", // smileys
"people", // actually people
"control", // modifiers and such, not displayed in picker
"nature", "foods", "places", "activity", "objects", "symbols", "flags"];
const DATA_BY_CATEGORY = {
  "people": [],
  "nature": [],
  "foods": [],
  "places": [],
  "activity": [],
  "objects": [],
  "symbols": [],
  "flags": []
}; // Store various mappings from unicode/emoticon/shortcode to the Emoji objects

exports.DATA_BY_CATEGORY = DATA_BY_CATEGORY;

const EMOJI = _compact.default.map(emojiData => {
  // If there's ever a gap in shortcode coverage, we fudge it by
  // filling it in with the emoji's CLDR annotation
  const shortcodeData = _iamcal.default[emojiData.hexcode] ?? [emojiData.label.toLowerCase().replace(/\W+/g, "_")];

  const emoji = _objectSpread(_objectSpread({}, emojiData), {}, {
    // Homogenize shortcodes by ensuring that everything is an array
    shortcodes: typeof shortcodeData === "string" ? [shortcodeData] : shortcodeData
  }); // We manually include regional indicators in the symbols group, since
  // Emojibase intentionally leaves them uncategorized


  const categoryId = EMOJIBASE_GROUP_ID_TO_CATEGORY[emoji.group] ?? (isRegionalIndicator(emoji.unicode) ? "symbols" : null);

  if (DATA_BY_CATEGORY.hasOwnProperty(categoryId)) {
    DATA_BY_CATEGORY[categoryId].push(emoji);
  } // Add mapping from unicode to Emoji object
  // The 'unicode' field that we use in emojibase has either
  // VS15 or VS16 appended to any characters that can take
  // variation selectors. Which one it appends depends
  // on whether emojibase considers their type to be 'text' or
  // 'emoji'. We therefore strip any variation chars from strings
  // both when building the map and when looking up.


  UNICODE_TO_EMOJI.set(stripVariation(emoji.unicode), emoji);

  if (emoji.emoticon) {
    // Add mapping from emoticon to Emoji object
    Array.isArray(emoji.emoticon) ? emoji.emoticon.forEach(x => EMOTICON_TO_EMOJI.set(x, emoji)) : EMOTICON_TO_EMOJI.set(emoji.emoticon, emoji);
  }

  return emoji;
});
/**
 * Strips variation selectors from the end of given string
 * NB. Skin tone modifiers are not variation selectors:
 * this function does not touch them. (Should it?)
 *
 * @param {string} str string to strip
 * @returns {string} stripped string
 */


exports.EMOJI = EMOJI;

function stripVariation(str) {
  return str.replace(/[\uFE00-\uFE0F]$/, "");
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVTklDT0RFX1RPX0VNT0pJIiwiTWFwIiwiRU1PVElDT05fVE9fRU1PSkkiLCJnZXRFbW9qaUZyb21Vbmljb2RlIiwidW5pY29kZSIsImdldCIsInN0cmlwVmFyaWF0aW9uIiwiaXNSZWdpb25hbEluZGljYXRvciIsIngiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJFTU9KSUJBU0VfR1JPVVBfSURfVE9fQ0FURUdPUlkiLCJEQVRBX0JZX0NBVEVHT1JZIiwiRU1PSkkiLCJFTU9KSUJBU0UiLCJtYXAiLCJlbW9qaURhdGEiLCJzaG9ydGNvZGVEYXRhIiwiU0hPUlRDT0RFUyIsImhleGNvZGUiLCJsYWJlbCIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImVtb2ppIiwic2hvcnRjb2RlcyIsImNhdGVnb3J5SWQiLCJncm91cCIsImhhc093blByb3BlcnR5IiwicHVzaCIsInNldCIsImVtb3RpY29uIiwiaXNBcnJheSIsImZvckVhY2giLCJzdHIiXSwic291cmNlcyI6WyIuLi9zcmMvZW1vamkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IEVNT0pJQkFTRSBmcm9tICdlbW9qaWJhc2UtZGF0YS9lbi9jb21wYWN0Lmpzb24nO1xuaW1wb3J0IFNIT1JUQ09ERVMgZnJvbSAnZW1vamliYXNlLWRhdGEvZW4vc2hvcnRjb2Rlcy9pYW1jYWwuanNvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVtb2ppIHtcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIGdyb3VwPzogbnVtYmVyO1xuICAgIGhleGNvZGU6IHN0cmluZztcbiAgICBvcmRlcj86IG51bWJlcjtcbiAgICBzaG9ydGNvZGVzOiBzdHJpbmdbXTtcbiAgICB0YWdzPzogc3RyaW5nW107XG4gICAgdW5pY29kZTogc3RyaW5nO1xuICAgIHNraW5zPzogT21pdDxJRW1vamksIFwic2hvcnRjb2Rlc1wiIHwgXCJ0YWdzXCI+W107IC8vIEN1cnJlbnRseSB1bnVzZWRcbiAgICBlbW90aWNvbj86IHN0cmluZyB8IHN0cmluZ1tdO1xufVxuXG4vLyBUaGUgdW5pY29kZSBpcyBzdG9yZWQgd2l0aG91dCB0aGUgdmFyaWFudCBzZWxlY3RvclxuY29uc3QgVU5JQ09ERV9UT19FTU9KSSA9IG5ldyBNYXA8c3RyaW5nLCBJRW1vamk+KCk7IC8vIG5vdCBleHBvcnRlZCBhcyBnZXRzIGZvciBpdCBhcmUgaGFuZGxlZCBieSBnZXRFbW9qaUZyb21Vbmljb2RlXG5leHBvcnQgY29uc3QgRU1PVElDT05fVE9fRU1PSkkgPSBuZXcgTWFwPHN0cmluZywgSUVtb2ppPigpO1xuXG5leHBvcnQgY29uc3QgZ2V0RW1vamlGcm9tVW5pY29kZSA9IHVuaWNvZGUgPT4gVU5JQ09ERV9UT19FTU9KSS5nZXQoc3RyaXBWYXJpYXRpb24odW5pY29kZSkpO1xuXG5jb25zdCBpc1JlZ2lvbmFsSW5kaWNhdG9yID0gKHg6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIC8vIEZpcnN0IHZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLiBXZSB1c2UgQXJyYXkuZnJvbVxuICAgIC8vIHRvIG1ha2Ugc3VyZSB3ZSBjb3VudCBieSBjaGFyYWN0ZXJzLCBub3QgVVRGLTggY29kZSB1bml0cy5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh4KS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgLy8gTmV4dCB2ZXJpZnkgdGhhdCB0aGUgY2hhcmFjdGVyIGlzIHdpdGhpbiB0aGUgY29kZSBwb2ludCByYW5nZSBmb3JcbiAgICAgICAgLy8gcmVnaW9uYWwgaW5kaWNhdG9ycy5cbiAgICAgICAgLy8gaHR0cDovL3VuaWNvZGUub3JnL2NoYXJ0cy9QREYvVW5pY29kZS02LjAvVTYwLTFGMTAwLnBkZlxuICAgICAgICB4ID49ICdcXHV7MWYxZTZ9JyAmJiB4IDw9ICdcXHV7MWYxZmZ9Jztcbn07XG5cbmNvbnN0IEVNT0pJQkFTRV9HUk9VUF9JRF9UT19DQVRFR09SWSA9IFtcbiAgICBcInBlb3BsZVwiLCAvLyBzbWlsZXlzXG4gICAgXCJwZW9wbGVcIiwgLy8gYWN0dWFsbHkgcGVvcGxlXG4gICAgXCJjb250cm9sXCIsIC8vIG1vZGlmaWVycyBhbmQgc3VjaCwgbm90IGRpc3BsYXllZCBpbiBwaWNrZXJcbiAgICBcIm5hdHVyZVwiLFxuICAgIFwiZm9vZHNcIixcbiAgICBcInBsYWNlc1wiLFxuICAgIFwiYWN0aXZpdHlcIixcbiAgICBcIm9iamVjdHNcIixcbiAgICBcInN5bWJvbHNcIixcbiAgICBcImZsYWdzXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgREFUQV9CWV9DQVRFR09SWSA9IHtcbiAgICBcInBlb3BsZVwiOiBbXSxcbiAgICBcIm5hdHVyZVwiOiBbXSxcbiAgICBcImZvb2RzXCI6IFtdLFxuICAgIFwicGxhY2VzXCI6IFtdLFxuICAgIFwiYWN0aXZpdHlcIjogW10sXG4gICAgXCJvYmplY3RzXCI6IFtdLFxuICAgIFwic3ltYm9sc1wiOiBbXSxcbiAgICBcImZsYWdzXCI6IFtdLFxufTtcblxuLy8gU3RvcmUgdmFyaW91cyBtYXBwaW5ncyBmcm9tIHVuaWNvZGUvZW1vdGljb24vc2hvcnRjb2RlIHRvIHRoZSBFbW9qaSBvYmplY3RzXG5leHBvcnQgY29uc3QgRU1PSkk6IElFbW9qaVtdID0gRU1PSklCQVNFLm1hcCgoZW1vamlEYXRhOiBPbWl0PElFbW9qaSwgXCJzaG9ydGNvZGVzXCI+KSA9PiB7XG4gICAgLy8gSWYgdGhlcmUncyBldmVyIGEgZ2FwIGluIHNob3J0Y29kZSBjb3ZlcmFnZSwgd2UgZnVkZ2UgaXQgYnlcbiAgICAvLyBmaWxsaW5nIGl0IGluIHdpdGggdGhlIGVtb2ppJ3MgQ0xEUiBhbm5vdGF0aW9uXG4gICAgY29uc3Qgc2hvcnRjb2RlRGF0YSA9IFNIT1JUQ09ERVNbZW1vamlEYXRhLmhleGNvZGVdID8/XG4gICAgICAgIFtlbW9qaURhdGEubGFiZWwudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXFcrL2csIFwiX1wiKV07XG5cbiAgICBjb25zdCBlbW9qaTogSUVtb2ppID0ge1xuICAgICAgICAuLi5lbW9qaURhdGEsXG4gICAgICAgIC8vIEhvbW9nZW5pemUgc2hvcnRjb2RlcyBieSBlbnN1cmluZyB0aGF0IGV2ZXJ5dGhpbmcgaXMgYW4gYXJyYXlcbiAgICAgICAgc2hvcnRjb2RlczogdHlwZW9mIHNob3J0Y29kZURhdGEgPT09IFwic3RyaW5nXCIgPyBbc2hvcnRjb2RlRGF0YV0gOiBzaG9ydGNvZGVEYXRhLFxuICAgIH07XG5cbiAgICAvLyBXZSBtYW51YWxseSBpbmNsdWRlIHJlZ2lvbmFsIGluZGljYXRvcnMgaW4gdGhlIHN5bWJvbHMgZ3JvdXAsIHNpbmNlXG4gICAgLy8gRW1vamliYXNlIGludGVudGlvbmFsbHkgbGVhdmVzIHRoZW0gdW5jYXRlZ29yaXplZFxuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSBFTU9KSUJBU0VfR1JPVVBfSURfVE9fQ0FURUdPUllbZW1vamkuZ3JvdXBdID8/XG4gICAgICAgIChpc1JlZ2lvbmFsSW5kaWNhdG9yKGVtb2ppLnVuaWNvZGUpID8gXCJzeW1ib2xzXCIgOiBudWxsKTtcblxuICAgIGlmIChEQVRBX0JZX0NBVEVHT1JZLmhhc093blByb3BlcnR5KGNhdGVnb3J5SWQpKSB7XG4gICAgICAgIERBVEFfQllfQ0FURUdPUllbY2F0ZWdvcnlJZF0ucHVzaChlbW9qaSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1hcHBpbmcgZnJvbSB1bmljb2RlIHRvIEVtb2ppIG9iamVjdFxuICAgIC8vIFRoZSAndW5pY29kZScgZmllbGQgdGhhdCB3ZSB1c2UgaW4gZW1vamliYXNlIGhhcyBlaXRoZXJcbiAgICAvLyBWUzE1IG9yIFZTMTYgYXBwZW5kZWQgdG8gYW55IGNoYXJhY3RlcnMgdGhhdCBjYW4gdGFrZVxuICAgIC8vIHZhcmlhdGlvbiBzZWxlY3RvcnMuIFdoaWNoIG9uZSBpdCBhcHBlbmRzIGRlcGVuZHNcbiAgICAvLyBvbiB3aGV0aGVyIGVtb2ppYmFzZSBjb25zaWRlcnMgdGhlaXIgdHlwZSB0byBiZSAndGV4dCcgb3JcbiAgICAvLyAnZW1vamknLiBXZSB0aGVyZWZvcmUgc3RyaXAgYW55IHZhcmlhdGlvbiBjaGFycyBmcm9tIHN0cmluZ3NcbiAgICAvLyBib3RoIHdoZW4gYnVpbGRpbmcgdGhlIG1hcCBhbmQgd2hlbiBsb29raW5nIHVwLlxuICAgIFVOSUNPREVfVE9fRU1PSkkuc2V0KHN0cmlwVmFyaWF0aW9uKGVtb2ppLnVuaWNvZGUpLCBlbW9qaSk7XG5cbiAgICBpZiAoZW1vamkuZW1vdGljb24pIHtcbiAgICAgICAgLy8gQWRkIG1hcHBpbmcgZnJvbSBlbW90aWNvbiB0byBFbW9qaSBvYmplY3RcbiAgICAgICAgQXJyYXkuaXNBcnJheShlbW9qaS5lbW90aWNvbilcbiAgICAgICAgICAgID8gZW1vamkuZW1vdGljb24uZm9yRWFjaCgoeCkgPT4gRU1PVElDT05fVE9fRU1PSkkuc2V0KHgsIGVtb2ppKSlcbiAgICAgICAgICAgIDogRU1PVElDT05fVE9fRU1PSkkuc2V0KGVtb2ppLmVtb3RpY29uLCBlbW9qaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtb2ppO1xufSk7XG5cbi8qKlxuICogU3RyaXBzIHZhcmlhdGlvbiBzZWxlY3RvcnMgZnJvbSB0aGUgZW5kIG9mIGdpdmVuIHN0cmluZ1xuICogTkIuIFNraW4gdG9uZSBtb2RpZmllcnMgYXJlIG5vdCB2YXJpYXRpb24gc2VsZWN0b3JzOlxuICogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB0b3VjaCB0aGVtLiAoU2hvdWxkIGl0PylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBzdHJpcFxuICogQHJldHVybnMge3N0cmluZ30gc3RyaXBwZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHN0cmlwVmFyaWF0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdUZFMDAtXFx1RkUwRl0kLywgXCJcIik7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUNBOzs7Ozs7QUFjQTtBQUNBLE1BQU1BLGdCQUFnQixHQUFHLElBQUlDLEdBQUosRUFBekIsQyxDQUFvRDs7QUFDN0MsTUFBTUMsaUJBQWlCLEdBQUcsSUFBSUQsR0FBSixFQUExQjs7O0FBRUEsTUFBTUUsbUJBQW1CLEdBQUdDLE9BQU8sSUFBSUosZ0JBQWdCLENBQUNLLEdBQWpCLENBQXFCQyxjQUFjLENBQUNGLE9BQUQsQ0FBbkMsQ0FBdkM7Ozs7QUFFUCxNQUFNRyxtQkFBbUIsR0FBSUMsQ0FBRCxJQUF3QjtFQUNoRDtFQUNBO0VBQ0EsT0FBT0MsS0FBSyxDQUFDQyxJQUFOLENBQVdGLENBQVgsRUFBY0csTUFBZCxLQUF5QixDQUF6QixJQUNIO0VBQ0E7RUFDQTtFQUNBSCxDQUFDLElBQUksV0FKRixJQUlpQkEsQ0FBQyxJ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