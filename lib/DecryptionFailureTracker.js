"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DecryptionFailureTracker = exports.DecryptionFailure = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _PosthogAnalytics = require("./PosthogAnalytics");

/*
Copyright 2018 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class DecryptionFailure {
  constructor(failedEventId, errorCode) {
    this.failedEventId = failedEventId;
    this.errorCode = errorCode;
    (0, _defineProperty2.default)(this, "ts", void 0);
    this.ts = Date.now();
  }

}

exports.DecryptionFailure = DecryptionFailure;

class DecryptionFailureTracker {
  // Map of event IDs to DecryptionFailure items.
  // Set of event IDs that have been visible to the user.
  // Map of visible event IDs to `DecryptionFailure`s. Every
  // `CHECK_INTERVAL_MS`, this map is checked for failures that
  // happened > `GRACE_PERIOD_MS` ago. Those that did are
  // accumulated in `failureCounts`.
  // A histogram of the number of failures that will be tracked at the next tracking
  // interval, split by failure error code.
  // Event IDs of failures that were tracked previously
  // Set to an interval ID when `start` is called
  // Spread the load on `Analytics` by tracking at a low frequency, `TRACK_INTERVAL_MS`.
  // Call `checkFailures` every `CHECK_INTERVAL_MS`.
  // Give events a chance to be decrypted by waiting `GRACE_PERIOD_MS` before counting
  // the failure in `failureCounts`.

  /**
   * Create a new DecryptionFailureTracker.
   *
   * Call `eventDecrypted(event, err)` on this instance when an event is decrypted.
   *
   * Call `start()` to start the tracker, and `stop()` to stop tracking.
   *
   * @param {function} fn The tracking function, which will be called when failures
   * are tracked. The function should have a signature `(count, trackedErrorCode) => {...}`,
   * where `count` is the number of failures and `errorCode` matches the `.code` of
   * provided DecryptionError errors (by default, unless `errorCodeMapFn` is specified.
   * @param {function?} errorCodeMapFn The function used to map error codes to the
   * trackedErrorCode. If not provided, the `.code` of errors will be used.
   */
  constructor(fn, errorCodeMapFn) {
    this.fn = fn;
    this.errorCodeMapFn = errorCodeMapFn;
    (0, _defineProperty2.default)(this, "failures", new Map());
    (0, _defineProperty2.default)(this, "visibleEvents", new Set());
    (0, _defineProperty2.default)(this, "visibleFailures", new Map());
    (0, _defineProperty2.default)(this, "failureCounts", {// [errorCode]: 42
    });
    (0, _defineProperty2.default)(this, "trackedEvents", new Set());
    (0, _defineProperty2.default)(this, "checkInterval", null);
    (0, _defineProperty2.default)(this, "trackInterval", null);

    if (!fn || typeof fn !== 'function') {
      throw new Error('DecryptionFailureTracker requires tracking function');
    }

    if (typeof errorCodeMapFn !== 'function') {
      throw new Error('DecryptionFailureTracker second constructor argument should be a function');
    }
  }

  static get instance() {
    return DecryptionFailureTracker.internalInstance;
  } // loadTrackedEvents() {
  //     this.trackedEvents = new Set(JSON.parse(localStorage.getItem('mx-decryption-failure-event-ids')) || []);
  // }
  // saveTrackedEvents() {
  //     localStorage.setItem('mx-decryption-failure-event-ids', JSON.stringify([...this.trackedEvents]));
  // }


  eventDecrypted(e, err) {
    // for now we only track megolm decrytion failures
    if (e.getWireContent().algorithm != "m.megolm.v1.aes-sha2") {
      return;
    }

    if (err) {
      this.addDecryptionFailure(new DecryptionFailure(e.getId(), err.code));
    } else {
      // Could be an event in the failures, remove it
      this.removeDecryptionFailuresForEvent(e);
    }
  }

  addVisibleEvent(e) {
    const eventId = e.getId();

    if (this.trackedEvents.has(eventId)) {
      return;
    }

    this.visibleEvents.add(eventId);

    if (this.failures.has(eventId) && !this.visibleFailures.has(eventId)) {
      this.visibleFailures.set(eventId, this.failures.get(eventId));
    }
  }

  addDecryptionFailure(failure) {
    const eventId = failure.failedEventId;

    if (this.trackedEvents.has(eventId)) {
      return;
    }

    this.failures.set(eventId, failure);

    if (this.visibleEvents.has(eventId) && !this.visibleFailures.has(eventId)) {
      this.visibleFailures.set(eventId, failure);
    }
  }

  removeDecryptionFailuresForEvent(e) {
    const eventId = e.getId();
    this.failures.delete(eventId);
    this.visibleFailures.delete(eventId);
  }
  /**
   * Start checking for and tracking failures.
   */


  start() {
    this.checkInterval = setInterval(() => this.checkFailures(Date.now()), DecryptionFailureTracker.CHECK_INTERVAL_MS);
    this.trackInterval = setInterval(() => this.trackFailures(), DecryptionFailureTracker.TRACK_INTERVAL_MS);
  }
  /**
   * Clear state and stop checking for and tracking failures.
   */


  stop() {
    clearInterval(this.checkInterval);
    clearInterval(this.trackInterval);
    this.failures = new Map();
    this.visibleEvents = new Set();
    this.visibleFailures = new Map();
    this.failureCounts = {};
  }
  /**
   * Mark failures that occurred before nowTs - GRACE_PERIOD_MS as failures that should be
   * tracked. Only mark one failure per event ID.
   * @param {number} nowTs the timestamp that represents the time now.
   */


  checkFailures(nowTs) {
    const failuresGivenGrace = new Set();
    const failuresNotReady = new Map();

    for (const [eventId, failure] of this.visibleFailures) {
      if (nowTs > failure.ts + DecryptionFailureTracker.GRACE_PERIOD_MS) {
        failuresGivenGrace.add(failure);
        this.trackedEvents.add(eventId);
      } else {
        failuresNotReady.set(eventId, failure);
      }
    }

    this.visibleFailures = failuresNotReady; // Commented out for now for expediency, we need to consider unbound nature of storing
    // this in localStorage
    // this.saveTrackedEvents();

    this.aggregateFailures(failuresGivenGrace);
  }

  aggregateFailures(failures) {
    for (const failure of failures) {
      const errorCode = failure.errorCode;
      this.failureCounts[errorCode] = (this.failureCounts[errorCode] || 0) + 1;
    }
  }
  /**
   * If there are failures that should be tracked, call the given trackDecryptionFailure
   * function with the number of failures that should be tracked.
   */


  trackFailures() {
    for (const errorCode of Object.keys(this.failureCounts)) {
      if (this.failureCounts[errorCode] > 0) {
        const trackedErrorCode = this.errorCodeMapFn(errorCode);
        this.fn(this.failureCounts[errorCode], trackedErrorCode, errorCode);
        this.failureCounts[errorCode] = 0;
      }
    }
  }

}

exports.DecryptionFailureTracker = DecryptionFailureTracker;
(0, _defineProperty2.default)(DecryptionFailureTracker, "internalInstance", new DecryptionFailureTracker((total, errorCode, rawError) => {
  for (let i = 0; i < total; i++) {
    _PosthogAnalytics.PosthogAnalytics.instance.trackEvent({
      eventName: "Error",
      domain: "E2EE",
      name: errorCode,
      context: `mxc_crypto_error_type_${rawError}`
    });
  }
}, errorCode => {
  // Map JS-SDK error codes to tracker codes for aggregation
  switch (errorCode) {
    case 'MEGOLM_UNKNOWN_INBOUND_SESSION_ID':
      return 'OlmKeysNotSentError';

    case 'OLM_UNKNOWN_MESSAGE_INDEX':
      return 'OlmIndexError';

    case undefined:
      return 'OlmUnspecifiedError';

    default:
      return 'UnknownError';
  }
}));
(0, _defineProperty2.default)(DecryptionFailureTracker, "TRACK_INTERVAL_MS", 60000);
(0, _defineProperty2.default)(DecryptionFailureTracker, "CHECK_INTERVAL_MS", 5000);
(0, _defineProperty2.default)(DecryptionFailureTracker, "GRACE_PERIOD_MS", 4000);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZWNyeXB0aW9uRmFpbHVyZSIsImNvbnN0cnVjdG9yIiwiZmFpbGVkRXZlbnRJZCIsImVycm9yQ29kZSIsInRzIiwiRGF0ZSIsIm5vdyIsIkRlY3J5cHRpb25GYWlsdXJlVHJhY2tlciIsImZuIiwiZXJyb3JDb2RlTWFwRm4iLCJNYXAiLCJTZXQiLCJFcnJvciIsImluc3RhbmNlIiwiaW50ZXJuYWxJbnN0YW5jZSIsImV2ZW50RGVjcnlwdGVkIiwiZSIsImVyciIsImdldFdpcmVDb250ZW50IiwiYWxnb3JpdGhtIiwiYWRkRGVjcnlwdGlvbkZhaWx1cmUiLCJnZXRJZCIsImNvZGUiLCJyZW1vdmVEZWNyeXB0aW9uRmFpbHVyZXNGb3JFdmVudCIsImFkZFZpc2libGVFdmVudCIsImV2ZW50SWQiLCJ0cmFja2VkRXZlbnRzIiwiaGFzIiwidmlzaWJsZUV2ZW50cyIsImFkZCIsImZhaWx1cmVzIiwidmlzaWJsZUZhaWx1cmVzIiwic2V0IiwiZ2V0IiwiZmFpbHVyZSIsImRlbGV0ZSIsInN0YXJ0IiwiY2hlY2tJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2hlY2tGYWlsdXJlcyIsIkNIRUNLX0lOVEVSVkFMX01TIiwidHJhY2tJbnRlcnZhbCIsInRyYWNrRmFpbHVyZXMiLCJUUkFDS19JTlRFUlZBTF9NUyIsInN0b3AiLCJjbGVhckludGVydmFsIiwiZmFpbHVyZUNvdW50cyIsIm5vd1RzIiwiZmFpbHVyZXNHaXZlbkdyYWNlIiwiZmFpbHVyZXNOb3RSZWFkeSIsIkdSQUNFX1BFUklPRF9NUyIsImFnZ3JlZ2F0ZUZhaWx1cmVzIiwiT2JqZWN0Iiwia2V5cyIsInRyYWNrZWRFcnJvckNvZGUiLCJ0b3RhbCIsInJhd0Vycm9yIiwiaSIsIlBvc3Rob2dBbmFseXRpY3MiLCJ0cmFja0V2ZW50IiwiZXZlbnROYW1lIiwiZG9tYWluIiwibmFtZSIsImNvbnRleHQiLCJ1bmRlZmluZWQiXSwic291cmNlcyI6WyIuLi9zcmMvRGVjcnlwdGlvbkZhaWx1cmVUcmFja2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOCAtIDIwMjEgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBEZWNyeXB0aW9uRXJyb3IgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL2FsZ29yaXRobXNcIjtcbmltcG9ydCB7IE1hdHJpeEV2ZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudFwiO1xuaW1wb3J0IHsgRXJyb3IgYXMgRXJyb3JFdmVudCB9IGZyb20gXCJAbWF0cml4LW9yZy9hbmFseXRpY3MtZXZlbnRzL3R5cGVzL3R5cGVzY3JpcHQvRXJyb3JcIjtcblxuaW1wb3J0IHsgUG9zdGhvZ0FuYWx5dGljcyB9IGZyb20gJy4vUG9zdGhvZ0FuYWx5dGljcyc7XG5cbmV4cG9ydCBjbGFzcyBEZWNyeXB0aW9uRmFpbHVyZSB7XG4gICAgcHVibGljIHJlYWRvbmx5IHRzOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZmFpbGVkRXZlbnRJZDogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgZXJyb3JDb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy50cyA9IERhdGUubm93KCk7XG4gICAgfVxufVxuXG50eXBlIEVycm9yQ29kZSA9IFwiT2xtS2V5c05vdFNlbnRFcnJvclwiIHwgXCJPbG1JbmRleEVycm9yXCIgfCBcIlVua25vd25FcnJvclwiIHwgXCJPbG1VbnNwZWNpZmllZEVycm9yXCI7XG5cbnR5cGUgVHJhY2tpbmdGbiA9IChjb3VudDogbnVtYmVyLCB0cmFja2VkRXJyQ29kZTogRXJyb3JDb2RlLCByYXdFcnJvcjogc3RyaW5nKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBFcnJDb2RlTWFwRm4gPSAoZXJyY29kZTogc3RyaW5nKSA9PiBFcnJvckNvZGU7XG5cbmV4cG9ydCBjbGFzcyBEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGludGVybmFsSW5zdGFuY2UgPSBuZXcgRGVjcnlwdGlvbkZhaWx1cmVUcmFja2VyKCh0b3RhbCwgZXJyb3JDb2RlLCByYXdFcnJvcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIFBvc3Rob2dBbmFseXRpY3MuaW5zdGFuY2UudHJhY2tFdmVudDxFcnJvckV2ZW50Pih7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lOiBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgZG9tYWluOiBcIkUyRUVcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgY29udGV4dDogYG14Y19jcnlwdG9fZXJyb3JfdHlwZV8ke3Jhd0Vycm9yfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIChlcnJvckNvZGUpID0+IHtcbiAgICAgICAgLy8gTWFwIEpTLVNESyBlcnJvciBjb2RlcyB0byB0cmFja2VyIGNvZGVzIGZvciBhZ2dyZWdhdGlvblxuICAgICAgICBzd2l0Y2ggKGVycm9yQ29kZSkge1xuICAgICAgICAgICAgY2FzZSAnTUVHT0xNX1VOS05PV05fSU5CT1VORF9TRVNTSU9OX0lEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ09sbUtleXNOb3RTZW50RXJyb3InO1xuICAgICAgICAgICAgY2FzZSAnT0xNX1VOS05PV05fTUVTU0FHRV9JTkRFWCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdPbG1JbmRleEVycm9yJztcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHJldHVybiAnT2xtVW5zcGVjaWZpZWRFcnJvcic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93bkVycm9yJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTWFwIG9mIGV2ZW50IElEcyB0byBEZWNyeXB0aW9uRmFpbHVyZSBpdGVtcy5cbiAgICBwdWJsaWMgZmFpbHVyZXM6IE1hcDxzdHJpbmcsIERlY3J5cHRpb25GYWlsdXJlPiA9IG5ldyBNYXAoKTtcblxuICAgIC8vIFNldCBvZiBldmVudCBJRHMgdGhhdCBoYXZlIGJlZW4gdmlzaWJsZSB0byB0aGUgdXNlci5cbiAgICBwdWJsaWMgdmlzaWJsZUV2ZW50czogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBNYXAgb2YgdmlzaWJsZSBldmVudCBJRHMgdG8gYERlY3J5cHRpb25GYWlsdXJlYHMuIEV2ZXJ5XG4gICAgLy8gYENIRUNLX0lOVEVSVkFMX01TYCwgdGhpcyBtYXAgaXMgY2hlY2tlZCBmb3IgZmFpbHVyZXMgdGhhdFxuICAgIC8vIGhhcHBlbmVkID4gYEdSQUNFX1BFUklPRF9NU2AgYWdvLiBUaG9zZSB0aGF0IGRpZCBhcmVcbiAgICAvLyBhY2N1bXVsYXRlZCBpbiBgZmFpbHVyZUNvdW50c2AuXG4gICAgcHVibGljIHZpc2libGVGYWlsdXJlczogTWFwPHN0cmluZywgRGVjcnlwdGlvbkZhaWx1cmU+ID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gQSBoaXN0b2dyYW0gb2YgdGhlIG51bWJlciBvZiBmYWlsdXJlcyB0aGF0IHdpbGwgYmUgdHJhY2tlZCBhdCB0aGUgbmV4dCB0cmFja2luZ1xuICAgIC8vIGludGVydmFsLCBzcGxpdCBieSBmYWlsdXJlIGVycm9yIGNvZGUuXG4gICAgcHVibGljIGZhaWx1cmVDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICAgIC8vIFtlcnJvckNvZGVdOiA0MlxuICAgIH07XG5cbiAgICAvLyBFdmVudCBJRHMgb2YgZmFpbHVyZXMgdGhhdCB3ZXJlIHRyYWNrZWQgcHJldmlvdXNseVxuICAgIHB1YmxpYyB0cmFja2VkRXZlbnRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICAgIC8vIFNldCB0byBhbiBpbnRlcnZhbCBJRCB3aGVuIGBzdGFydGAgaXMgY2FsbGVkXG4gICAgcHVibGljIGNoZWNrSW50ZXJ2YWw6IG51bWJlciA9IG51bGw7XG4gICAgcHVibGljIHRyYWNrSW50ZXJ2YWw6IG51bWJlciA9IG51bGw7XG5cbiAgICAvLyBTcHJlYWQgdGhlIGxvYWQgb24gYEFuYWx5dGljc2AgYnkgdHJhY2tpbmcgYXQgYSBsb3cgZnJlcXVlbmN5LCBgVFJBQ0tfSU5URVJWQUxfTVNgLlxuICAgIHN0YXRpYyBUUkFDS19JTlRFUlZBTF9NUyA9IDYwMDAwO1xuXG4gICAgLy8gQ2FsbCBgY2hlY2tGYWlsdXJlc2AgZXZlcnkgYENIRUNLX0lOVEVSVkFMX01TYC5cbiAgICBzdGF0aWMgQ0hFQ0tfSU5URVJWQUxfTVMgPSA1MDAwO1xuXG4gICAgLy8gR2l2ZSBldmVudHMgYSBjaGFuY2UgdG8gYmUgZGVjcnlwdGVkIGJ5IHdhaXRpbmcgYEdSQUNFX1BFUklPRF9NU2AgYmVmb3JlIGNvdW50aW5nXG4gICAgLy8gdGhlIGZhaWx1cmUgaW4gYGZhaWx1cmVDb3VudHNgLlxuICAgIHN0YXRpYyBHUkFDRV9QRVJJT0RfTVMgPSA0MDAwO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IERlY3J5cHRpb25GYWlsdXJlVHJhY2tlci5cbiAgICAgKlxuICAgICAqIENhbGwgYGV2ZW50RGVjcnlwdGVkKGV2ZW50LCBlcnIpYCBvbiB0aGlzIGluc3RhbmNlIHdoZW4gYW4gZXZlbnQgaXMgZGVjcnlwdGVkLlxuICAgICAqXG4gICAgICogQ2FsbCBgc3RhcnQoKWAgdG8gc3RhcnQgdGhlIHRyYWNrZXIsIGFuZCBgc3RvcCgpYCB0byBzdG9wIHRyYWNraW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIHRyYWNraW5nIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIGZhaWx1cmVzXG4gICAgICogYXJlIHRyYWNrZWQuIFRoZSBmdW5jdGlvbiBzaG91bGQgaGF2ZSBhIHNpZ25hdHVyZSBgKGNvdW50LCB0cmFja2VkRXJyb3JDb2RlKSA9PiB7Li4ufWAsXG4gICAgICogd2hlcmUgYGNvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGZhaWx1cmVzIGFuZCBgZXJyb3JDb2RlYCBtYXRjaGVzIHRoZSBgLmNvZGVgIG9mXG4gICAgICogcHJvdmlkZWQgRGVjcnlwdGlvbkVycm9yIGVycm9ycyAoYnkgZGVmYXVsdCwgdW5sZXNzIGBlcnJvckNvZGVNYXBGbmAgaXMgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBlcnJvckNvZGVNYXBGbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBtYXAgZXJyb3IgY29kZXMgdG8gdGhlXG4gICAgICogdHJhY2tlZEVycm9yQ29kZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgYC5jb2RlYCBvZiBlcnJvcnMgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIHByaXZhdGUgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBmbjogVHJhY2tpbmdGbiwgcHJpdmF0ZSByZWFkb25seSBlcnJvckNvZGVNYXBGbjogRXJyQ29kZU1hcEZuKSB7XG4gICAgICAgIGlmICghZm4gfHwgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb25GYWlsdXJlVHJhY2tlciByZXF1aXJlcyB0cmFja2luZyBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvckNvZGVNYXBGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIgc2Vjb25kIGNvbnN0cnVjdG9yIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldCBpbnN0YW5jZSgpOiBEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIge1xuICAgICAgICByZXR1cm4gRGVjcnlwdGlvbkZhaWx1cmVUcmFja2VyLmludGVybmFsSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gbG9hZFRyYWNrZWRFdmVudHMoKSB7XG4gICAgLy8gICAgIHRoaXMudHJhY2tlZEV2ZW50cyA9IG5ldyBTZXQoSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXgtZGVjcnlwdGlvbi1mYWlsdXJlLWV2ZW50LWlkcycpKSB8fCBbXSk7XG4gICAgLy8gfVxuXG4gICAgLy8gc2F2ZVRyYWNrZWRFdmVudHMoKSB7XG4gICAgLy8gICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdteC1kZWNyeXB0aW9uLWZhaWx1cmUtZXZlbnQtaWRzJywgSlNPTi5zdHJpbmdpZnkoWy4uLnRoaXMudHJhY2tlZEV2ZW50c10pKTtcbiAgICAvLyB9XG5cbiAgICBwdWJsaWMgZXZlbnREZWNyeXB0ZWQoZTogTWF0cml4RXZlbnQsIGVycjogRGVjcnlwdGlvbkVycm9yKTogdm9pZCB7XG4gICAgICAgIC8vIGZvciBub3cgd2Ugb25seSB0cmFjayBtZWdvbG0gZGVjcnl0aW9uIGZhaWx1cmVzXG4gICAgICAgIGlmIChlLmdldFdpcmVDb250ZW50KCkuYWxnb3JpdGhtICE9IFwibS5tZWdvbG0udjEuYWVzLXNoYTJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVjcnlwdGlvbkZhaWx1cmUobmV3IERlY3J5cHRpb25GYWlsdXJlKGUuZ2V0SWQoKSwgZXJyLmNvZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvdWxkIGJlIGFuIGV2ZW50IGluIHRoZSBmYWlsdXJlcywgcmVtb3ZlIGl0XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURlY3J5cHRpb25GYWlsdXJlc0ZvckV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFkZFZpc2libGVFdmVudChlOiBNYXRyaXhFdmVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBldmVudElkID0gZS5nZXRJZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRFdmVudHMuaGFzKGV2ZW50SWQpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRoaXMudmlzaWJsZUV2ZW50cy5hZGQoZXZlbnRJZCk7XG4gICAgICAgIGlmICh0aGlzLmZhaWx1cmVzLmhhcyhldmVudElkKSAmJiAhdGhpcy52aXNpYmxlRmFpbHVyZXMuaGFzKGV2ZW50SWQpKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVGYWlsdXJlcy5zZXQoZXZlbnRJZCwgdGhpcy5mYWlsdXJlcy5nZXQoZXZlbnRJZCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFkZERlY3J5cHRpb25GYWlsdXJlKGZhaWx1cmU6IERlY3J5cHRpb25GYWlsdXJlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGV2ZW50SWQgPSBmYWlsdXJlLmZhaWxlZEV2ZW50SWQ7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEV2ZW50cy5oYXMoZXZlbnRJZCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdGhpcy5mYWlsdXJlcy5zZXQoZXZlbnRJZCwgZmFpbHVyZSk7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVFdmVudHMuaGFzKGV2ZW50SWQpICYmICF0aGlzLnZpc2libGVGYWlsdXJlcy5oYXMoZXZlbnRJZCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUZhaWx1cmVzLnNldChldmVudElkLCBmYWlsdXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVEZWNyeXB0aW9uRmFpbHVyZXNGb3JFdmVudChlOiBNYXRyaXhFdmVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBldmVudElkID0gZS5nZXRJZCgpO1xuICAgICAgICB0aGlzLmZhaWx1cmVzLmRlbGV0ZShldmVudElkKTtcbiAgICAgICAgdGhpcy52aXNpYmxlRmFpbHVyZXMuZGVsZXRlKGV2ZW50SWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGNoZWNraW5nIGZvciBhbmQgdHJhY2tpbmcgZmFpbHVyZXMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgICgpID0+IHRoaXMuY2hlY2tGYWlsdXJlcyhEYXRlLm5vdygpKSxcbiAgICAgICAgICAgIERlY3J5cHRpb25GYWlsdXJlVHJhY2tlci5DSEVDS19JTlRFUlZBTF9NUyxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnRyYWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgICgpID0+IHRoaXMudHJhY2tGYWlsdXJlcygpLFxuICAgICAgICAgICAgRGVjcnlwdGlvbkZhaWx1cmVUcmFja2VyLlRSQUNLX0lOVEVSVkFMX01TLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHN0YXRlIGFuZCBzdG9wIGNoZWNraW5nIGZvciBhbmQgdHJhY2tpbmcgZmFpbHVyZXMuXG4gICAgICovXG4gICAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jaGVja0ludGVydmFsKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRyYWNrSW50ZXJ2YWwpO1xuXG4gICAgICAgIHRoaXMuZmFpbHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudmlzaWJsZUV2ZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy52aXNpYmxlRmFpbHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmFpbHVyZUNvdW50cyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmsgZmFpbHVyZXMgdGhhdCBvY2N1cnJlZCBiZWZvcmUgbm93VHMgLSBHUkFDRV9QRVJJT0RfTVMgYXMgZmFpbHVyZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiB0cmFja2VkLiBPbmx5IG1hcmsgb25lIGZhaWx1cmUgcGVyIGV2ZW50IElELlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3dUcyB0aGUgdGltZXN0YW1wIHRoYXQgcmVwcmVzZW50cyB0aGUgdGltZSBub3cuXG4gICAgICovXG4gICAgcHVibGljIGNoZWNrRmFpbHVyZXMobm93VHM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBmYWlsdXJlc0dpdmVuR3JhY2U6IFNldDxEZWNyeXB0aW9uRmFpbHVyZT4gPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGZhaWx1cmVzTm90UmVhZHk6IE1hcDxzdHJpbmcsIERlY3J5cHRpb25GYWlsdXJlPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBbZXZlbnRJZCwgZmFpbHVyZV0gb2YgdGhpcy52aXNpYmxlRmFpbHVyZXMpIHtcbiAgICAgICAgICAgIGlmIChub3dUcyA+IGZhaWx1cmUudHMgKyBEZWNyeXB0aW9uRmFpbHVyZVRyYWNrZXIuR1JBQ0VfUEVSSU9EX01TKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZXNHaXZlbkdyYWNlLmFkZChmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZWRFdmVudHMuYWRkKGV2ZW50SWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlc05vdFJlYWR5LnNldChldmVudElkLCBmYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2libGVGYWlsdXJlcyA9IGZhaWx1cmVzTm90UmVhZHk7XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIG91dCBmb3Igbm93IGZvciBleHBlZGllbmN5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIHVuYm91bmQgbmF0dXJlIG9mIHN0b3JpbmdcbiAgICAgICAgLy8gdGhpcyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgLy8gdGhpcy5zYXZlVHJhY2tlZEV2ZW50cygpO1xuXG4gICAgICAgIHRoaXMuYWdncmVnYXRlRmFpbHVyZXMoZmFpbHVyZXNHaXZlbkdyYWNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFnZ3JlZ2F0ZUZhaWx1cmVzKGZhaWx1cmVzOiBTZXQ8RGVjcnlwdGlvbkZhaWx1cmU+KTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZmFpbHVyZS5lcnJvckNvZGU7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmVDb3VudHNbZXJyb3JDb2RlXSA9ICh0aGlzLmZhaWx1cmVDb3VudHNbZXJyb3JDb2RlXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBhcmUgZmFpbHVyZXMgdGhhdCBzaG91bGQgYmUgdHJhY2tlZCwgY2FsbCB0aGUgZ2l2ZW4gdHJhY2tEZWNyeXB0aW9uRmFpbHVyZVxuICAgICAqIGZ1bmN0aW9uIHdpdGggdGhlIG51bWJlciBvZiBmYWlsdXJlcyB0aGF0IHNob3VsZCBiZSB0cmFja2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFja0ZhaWx1cmVzKCk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IGVycm9yQ29kZSBvZiBPYmplY3Qua2V5cyh0aGlzLmZhaWx1cmVDb3VudHMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mYWlsdXJlQ291bnRzW2Vycm9yQ29kZV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZEVycm9yQ29kZSA9IHRoaXMuZXJyb3JDb2RlTWFwRm4oZXJyb3JDb2RlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZm4odGhpcy5mYWlsdXJlQ291bnRzW2Vycm9yQ29kZV0sIHRyYWNrZWRFcnJvckNvZGUsIGVycm9yQ29kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsdXJlQ291bnRzW2Vycm9yQ29kZV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQW9CQTs7QUFwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUU8sTUFBTUEsaUJBQU4sQ0FBd0I7RUFHM0JDLFdBQVcsQ0FBaUJDLGFBQWpCLEVBQXdEQyxTQUF4RCxFQUEyRTtJQUFBLEtBQTFERCxhQUEwRCxHQUExREEsYUFBMEQ7SUFBQSxLQUFuQkMsU0FBbUIsR0FBbkJBLFNBQW1CO0lBQUE7SUFDbEYsS0FBS0MsRUFBTCxHQUFVQyxJQUFJLENBQUNDLEdBQUwsRUFBVjtFQUNIOztBQUwwQjs7OztBQWN4QixNQUFNQyx3QkFBTixDQUErQjtFQXdCbEM7RUFHQTtFQUdBO0VB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