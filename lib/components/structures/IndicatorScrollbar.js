"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _AutoHideScrollbar = _interopRequireDefault(require("./AutoHideScrollbar"));

var _UIStore = _interopRequireWildcard(require("../../stores/UIStore"));

const _excluded = ["children", "trackHorizontalOverflow", "verticalScrollsHorizontally"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class IndicatorScrollbar extends _react.default.Component {
  // ts in milliseconds to recheck this._likelyTrackpadUser
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "autoHideScrollbar", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "scrollElement", void 0);
    (0, _defineProperty2.default)(this, "likelyTrackpadUser", null);
    (0, _defineProperty2.default)(this, "checkAgainForTrackpad", 0);
    (0, _defineProperty2.default)(this, "collectScroller", scroller => {
      this.props.wrappedRef?.(scroller);

      if (scroller && !this.scrollElement) {
        this.scrollElement = scroller; // Using the passive option to not block the main thread
        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners

        this.scrollElement.addEventListener("scroll", this.checkOverflow, {
          passive: true
        });
        this.checkOverflow();
      }
    });
    (0, _defineProperty2.default)(this, "checkOverflow", () => {
      const hasTopOverflow = this.scrollElement.scrollTop > 0;
      const hasBottomOverflow = this.scrollElement.scrollHeight > this.scrollElement.scrollTop + this.scrollElement.clientHeight;
      const hasLeftOverflow = this.scrollElement.scrollLeft > 0;
      const hasRightOverflow = this.scrollElement.scrollWidth > this.scrollElement.scrollLeft + this.scrollElement.clientWidth;

      if (hasTopOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_topOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_topOverflow");
      }

      if (hasBottomOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_bottomOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_bottomOverflow");
      }

      if (hasLeftOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_leftOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_leftOverflow");
      }

      if (hasRightOverflow) {
        this.scrollElement.classList.add("mx_IndicatorScrollbar_rightOverflow");
      } else {
        this.scrollElement.classList.remove("mx_IndicatorScrollbar_rightOverflow");
      }

      if (this.props.trackHorizontalOverflow) {
        this.setState({
          // Offset from absolute position of the container
          leftIndicatorOffset: hasLeftOverflow ? `${this.scrollElement.scrollLeft}px` : '0',
          // Negative because we're coming from the right
          rightIndicatorOffset: hasRightOverflow ? `-${this.scrollElement.scrollLeft}px` : '0'
        });
      }
    });
    (0, _defineProperty2.default)(this, "onMouseWheel", e => {
      if (this.props.verticalScrollsHorizontally && this.scrollElement) {
        // xyThreshold is the amount of horizontal motion required for the component to
        // ignore the vertical delta in a scroll. Used to stop trackpads from acting in
        // strange ways. Should be positive.
        const xyThreshold = 0; // yRetention is the factor multiplied by the vertical delta to try and reduce
        // the harshness of the scroll behaviour. Should be a value between 0 and 1.

        const yRetention = 1.0; // whenever we see horizontal scrolling, assume the user is on a trackpad
        // for at least the next 1 minute.

        const now = new Date().getTime();

        if (Math.abs(e.deltaX) > 0) {
          this.likelyTrackpadUser = true;
          this.checkAgainForTrackpad = now + 1 * 60 * 1000;
        } else {
          // if we haven't seen any horizontal scrolling for a while, assume
          // the user might have plugged in a mousewheel
          if (this.likelyTrackpadUser && now >= this.checkAgainForTrackpad) {
            this.likelyTrackpadUser = false;
          }
        } // don't mess with the horizontal scroll for trackpad users
        // See https://github.com/vector-im/element-web/issues/10005


        if (this.likelyTrackpadUser) {
          return;
        }

        if (Math.abs(e.deltaX) <= xyThreshold) {
          // we are vertically scrolling.
          // HACK: We increase the amount of scroll to counteract smooth scrolling browsers.
          // Smooth scrolling browsers (Firefox) use the relative area to determine the scroll
          // amount, which means the likely small area of content results in a small amount of
          // movement - not what people expect. We pick arbitrary values for when to apply more
          // scroll, and how much to apply. On Windows 10, Chrome scrolls 100 units whereas
          // Firefox scrolls just 3 due to smooth scrolling.
          const additionalScroll = e.deltaY < 0 ? -50 : 50; // noinspection JSSuspiciousNameCombination

          const val = Math.abs(e.deltaY) < 25 ? e.deltaY + additionalScroll : e.deltaY;
          this.scrollElement.scrollLeft += val * yRetention;
        }
      }
    });
    this.state = {
      leftIndicatorOffset: '0',
      rightIndicatorOffset: '0'
    };
  }

  componentDidUpdate(prevProps) {
    const prevLen = _react.default.Children.count(prevProps.children);

    const curLen = _react.default.Children.count(this.props.children); // check overflow only if amount of children changes.
    // if we don't guard here, we end up with an infinite
    // render > componentDidUpdate > checkOverflow > setState > render loop


    if (prevLen !== curLen) {
      this.checkOverflow();
    }
  }

  componentDidMount() {
    this.checkOverflow();

    _UIStore.default.instance.on(_UIStore.UI_EVENTS.Resize, this.checkOverflow);
  }

  componentWillUnmount() {
    this.scrollElement?.removeEventListener("scroll", this.checkOverflow);

    _UIStore.default.instance.off(_UIStore.UI_EVENTS.Resize, this.checkOverflow);
  }

  render() {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _this$props = this.props,
          {
      children,
      trackHorizontalOverflow,
      verticalScrollsHorizontally
    } = _this$props,
          otherProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
    const leftIndicatorStyle = {
      left: this.state.leftIndicatorOffset
    };
    const rightIndicatorStyle = {
      right: this.state.rightIndicatorOffset
    };
    const leftOverflowIndicator = trackHorizontalOverflow ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_IndicatorScrollbar_leftOverflowIndicator",
      style: leftIndicatorStyle
    }) : null;
    const rightOverflowIndicator = trackHorizontalOverflow ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_IndicatorScrollbar_rightOverflowIndicator",
      style: rightIndicatorStyle
    }) : null;
    return /*#__PURE__*/_react.default.createElement(_AutoHideScrollbar.default, (0, _extends2.default)({}, otherProps, {
      ref: this.autoHideScrollbar,
      wrappedRef: this.collectScroller,
      onWheel: this.onMouseWheel
    }), leftOverflowIndicator, children, rightOverflowIndicator);
  }

}

exports.default = IndicatorScrollbar;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJJbmRpY2F0b3JTY3JvbGxiYXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjcmVhdGVSZWYiLCJzY3JvbGxlciIsIndyYXBwZWRSZWYiLCJzY3JvbGxFbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNoZWNrT3ZlcmZsb3ciLCJwYXNzaXZlIiwiaGFzVG9wT3ZlcmZsb3ciLCJzY3JvbGxUb3AiLCJoYXNCb3R0b21PdmVyZmxvdyIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImhhc0xlZnRPdmVyZmxvdyIsInNjcm9sbExlZnQiLCJoYXNSaWdodE92ZXJmbG93Iiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsInRyYWNrSG9yaXpvbnRhbE92ZXJmbG93Iiwic2V0U3RhdGUiLCJsZWZ0SW5kaWNhdG9yT2Zmc2V0IiwicmlnaHRJbmRpY2F0b3JPZmZzZXQiLCJlIiwidmVydGljYWxTY3JvbGxzSG9yaXpvbnRhbGx5IiwieHlUaHJlc2hvbGQiLCJ5UmV0ZW50aW9uIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJNYXRoIiwiYWJzIiwiZGVsdGFYIiwibGlrZWx5VHJhY2twYWRVc2VyIiwiY2hlY2tBZ2FpbkZvclRyYWNrcGFkIiwiYWRkaXRpb25hbFNjcm9sbCIsImRlbHRhWSIsInZhbCIsInN0YXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldkxlbiIsIkNoaWxkcmVuIiwiY291bnQiLCJjaGlsZHJlbiIsImN1ckxlbiIsImNvbXBvbmVudERpZE1vdW50IiwiVUlTdG9yZSIsImluc3RhbmNlIiwib24iLCJVSV9FVkVOVFMiLCJSZXNpemUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvZmYiLCJyZW5kZXIiLCJvdGhlclByb3BzIiwibGVmdEluZGljYXRvclN0eWxlIiwibGVmdCIsInJpZ2h0SW5kaWNhdG9yU3R5bGUiLCJyaWdodCIsImxlZnRPdmVyZmxvd0luZGljYXRvciIsInJpZ2h0T3ZlcmZsb3dJbmRpY2F0b3IiLCJhdXRvSGlkZVNjcm9sbGJhciIsImNvbGxlY3RTY3JvbGxlciIsIm9uTW91c2VXaGVlbCJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvSW5kaWNhdG9yU2Nyb2xsYmFyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTggTmV3IFZlY3RvciBMdGRcblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCBBdXRvSGlkZVNjcm9sbGJhciwgeyBJUHJvcHMgYXMgQXV0b0hpZGVTY3JvbGxiYXJQcm9wcyB9IGZyb20gXCIuL0F1dG9IaWRlU2Nyb2xsYmFyXCI7XG5pbXBvcnQgVUlTdG9yZSwgeyBVSV9FVkVOVFMgfSBmcm9tIFwiLi4vLi4vc3RvcmVzL1VJU3RvcmVcIjtcblxuZXhwb3J0IHR5cGUgSVByb3BzPFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHM+ID0gT21pdDxBdXRvSGlkZVNjcm9sbGJhclByb3BzPFQ+LCBcIm9uV2hlZWxcIj4gJiB7XG4gICAgLy8gSWYgdHJ1ZSwgdGhlIHNjcm9sbGJhciB3aWxsIGFwcGVuZCBteF9JbmRpY2F0b3JTY3JvbGxiYXJfbGVmdE92ZXJmbG93SW5kaWNhdG9yXG4gICAgLy8gYW5kIG14X0luZGljYXRvclNjcm9sbGJhcl9yaWdodE92ZXJmbG93SW5kaWNhdG9yIGVsZW1lbnRzIHRvIHRoZSBsaXN0IGZvciBwb3NpdGlvbmluZ1xuICAgIC8vIGJ5IHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICB0cmFja0hvcml6b250YWxPdmVyZmxvdz86IGJvb2xlYW47XG5cbiAgICAvLyBJZiB0cnVlLCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIHVzZSB0aGVpciBtb3VzZSB3aGVlbCBpbiB0aGUgY29tcG9uZW50IGl0IHdpbGxcbiAgICAvLyBzY3JvbGwgaG9yaXpvbnRhbGx5IHJhdGhlciB0aGFuIHZlcnRpY2FsbHkuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzXG4gICAgLy8gd2l0aCBubyB2ZXJ0aWNhbCBzY3JvbGwgb3Bwb3J0dW5pdHkuXG4gICAgdmVydGljYWxTY3JvbGxzSG9yaXpvbnRhbGx5PzogYm9vbGVhbjtcblxuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59O1xuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBsZWZ0SW5kaWNhdG9yT2Zmc2V0OiBzdHJpbmc7XG4gICAgcmlnaHRJbmRpY2F0b3JPZmZzZXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaWNhdG9yU2Nyb2xsYmFyPFxuICAgIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wczxUPiwgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSBhdXRvSGlkZVNjcm9sbGJhciA9IGNyZWF0ZVJlZjxBdXRvSGlkZVNjcm9sbGJhcjxhbnk+PigpO1xuICAgIHByaXZhdGUgc2Nyb2xsRWxlbWVudDogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBsaWtlbHlUcmFja3BhZFVzZXI6IGJvb2xlYW4gPSBudWxsO1xuICAgIHByaXZhdGUgY2hlY2tBZ2FpbkZvclRyYWNrcGFkID0gMDsgLy8gdHMgaW4gbWlsbGlzZWNvbmRzIHRvIHJlY2hlY2sgdGhpcy5fbGlrZWx5VHJhY2twYWRVc2VyXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSVByb3BzPFQ+KSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbGVmdEluZGljYXRvck9mZnNldDogJzAnLFxuICAgICAgICAgICAgcmlnaHRJbmRpY2F0b3JPZmZzZXQ6ICcwJyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbGxlY3RTY3JvbGxlciA9IChzY3JvbGxlcjogSFRNTERpdkVsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy53cmFwcGVkUmVmPy4oc2Nyb2xsZXIpO1xuICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgIXRoaXMuc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsZXI7XG4gICAgICAgICAgICAvLyBVc2luZyB0aGUgcGFzc2l2ZSBvcHRpb24gdG8gbm90IGJsb2NrIHRoZSBtYWluIHRocmVhZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjaW1wcm92aW5nX3Njcm9sbGluZ19wZXJmb3JtYW5jZV93aXRoX3Bhc3NpdmVfbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmNoZWNrT3ZlcmZsb3csIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tPdmVyZmxvdygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJUHJvcHM8VD4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcHJldkxlbiA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KHByZXZQcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGN1ckxlbiA9IFJlYWN0LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAvLyBjaGVjayBvdmVyZmxvdyBvbmx5IGlmIGFtb3VudCBvZiBjaGlsZHJlbiBjaGFuZ2VzLlxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBndWFyZCBoZXJlLCB3ZSBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZVxuICAgICAgICAvLyByZW5kZXIgPiBjb21wb25lbnREaWRVcGRhdGUgPiBjaGVja092ZXJmbG93ID4gc2V0U3RhdGUgPiByZW5kZXIgbG9vcFxuICAgICAgICBpZiAocHJldkxlbiAhPT0gY3VyTGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGVja092ZXJmbG93KCk7XG4gICAgICAgIFVJU3RvcmUuaW5zdGFuY2Uub24oVUlfRVZFTlRTLlJlc2l6ZSwgdGhpcy5jaGVja092ZXJmbG93KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNoZWNrT3ZlcmZsb3cgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1RvcE92ZXJmbG93ID0gdGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbFRvcCA+IDA7XG4gICAgICAgIGNvbnN0IGhhc0JvdHRvbU92ZXJmbG93ID0gdGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCA+XG4gICAgICAgICAgICAodGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbFRvcCArIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICBjb25zdCBoYXNMZWZ0T3ZlcmZsb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsTGVmdCA+IDA7XG4gICAgICAgIGNvbnN0IGhhc1JpZ2h0T3ZlcmZsb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQuc2Nyb2xsV2lkdGggPlxuICAgICAgICAgICAgKHRoaXMuc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0ICsgdGhpcy5zY3JvbGxFbGVtZW50LmNsaWVudFdpZHRoKTtcblxuICAgICAgICBpZiAoaGFzVG9wT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX3RvcE92ZXJmbG93XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfdG9wT3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JvdHRvbU92ZXJmbG93KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm14X0luZGljYXRvclNjcm9sbGJhcl9ib3R0b21PdmVyZmxvd1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2JvdHRvbU92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMZWZ0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2xlZnRPdmVyZmxvd1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2xlZnRPdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUmlnaHRPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfcmlnaHRPdmVyZmxvd1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX3JpZ2h0T3ZlcmZsb3dcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy50cmFja0hvcml6b250YWxPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gT2Zmc2V0IGZyb20gYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGxlZnRJbmRpY2F0b3JPZmZzZXQ6IGhhc0xlZnRPdmVyZmxvdyA/IGAke3RoaXMuc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0fXB4YCA6ICcwJyxcblxuICAgICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIGJlY2F1c2Ugd2UncmUgY29taW5nIGZyb20gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgcmlnaHRJbmRpY2F0b3JPZmZzZXQ6IGhhc1JpZ2h0T3ZlcmZsb3cgPyBgLSR7dGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbExlZnR9cHhgIDogJzAnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5jaGVja092ZXJmbG93KTtcbiAgICAgICAgVUlTdG9yZS5pbnN0YW5jZS5vZmYoVUlfRVZFTlRTLlJlc2l6ZSwgdGhpcy5jaGVja092ZXJmbG93KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uTW91c2VXaGVlbCA9IChlOiBSZWFjdC5XaGVlbEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZlcnRpY2FsU2Nyb2xsc0hvcml6b250YWxseSAmJiB0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHh5VGhyZXNob2xkIGlzIHRoZSBhbW91bnQgb2YgaG9yaXpvbnRhbCBtb3Rpb24gcmVxdWlyZWQgZm9yIHRoZSBjb21wb25lbnQgdG9cbiAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgdmVydGljYWwgZGVsdGEgaW4gYSBzY3JvbGwuIFVzZWQgdG8gc3RvcCB0cmFja3BhZHMgZnJvbSBhY3RpbmcgaW5cbiAgICAgICAgICAgIC8vIHN0cmFuZ2Ugd2F5cy4gU2hvdWxkIGJlIHBvc2l0aXZlLlxuICAgICAgICAgICAgY29uc3QgeHlUaHJlc2hvbGQgPSAwO1xuXG4gICAgICAgICAgICAvLyB5UmV0ZW50aW9uIGlzIHRoZSBmYWN0b3IgbXVsdGlwbGllZCBieSB0aGUgdmVydGljYWwgZGVsdGEgdG8gdHJ5IGFuZCByZWR1Y2VcbiAgICAgICAgICAgIC8vIHRoZSBoYXJzaG5lc3Mgb2YgdGhlIHNjcm9sbCBiZWhhdmlvdXIuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAgICAgIGNvbnN0IHlSZXRlbnRpb24gPSAxLjA7XG5cbiAgICAgICAgICAgIC8vIHdoZW5ldmVyIHdlIHNlZSBob3Jpem9udGFsIHNjcm9sbGluZywgYXNzdW1lIHRoZSB1c2VyIGlzIG9uIGEgdHJhY2twYWRcbiAgICAgICAgICAgIC8vIGZvciBhdCBsZWFzdCB0aGUgbmV4dCAxIG1pbnV0ZS5cbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUuZGVsdGFYKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpa2VseVRyYWNrcGFkVXNlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0FnYWluRm9yVHJhY2twYWQgPSBub3cgKyAoMSAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmVuJ3Qgc2VlbiBhbnkgaG9yaXpvbnRhbCBzY3JvbGxpbmcgZm9yIGEgd2hpbGUsIGFzc3VtZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIG1pZ2h0IGhhdmUgcGx1Z2dlZCBpbiBhIG1vdXNld2hlZWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saWtlbHlUcmFja3BhZFVzZXIgJiYgbm93ID49IHRoaXMuY2hlY2tBZ2FpbkZvclRyYWNrcGFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlrZWx5VHJhY2twYWRVc2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb24ndCBtZXNzIHdpdGggdGhlIGhvcml6b250YWwgc2Nyb2xsIGZvciB0cmFja3BhZCB1c2Vyc1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzEwMDA1XG4gICAgICAgICAgICBpZiAodGhpcy5saWtlbHlUcmFja3BhZFVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhlLmRlbHRhWCkgPD0geHlUaHJlc2hvbGQpIHsgLy8gd2UgYXJlIHZlcnRpY2FsbHkgc2Nyb2xsaW5nLlxuICAgICAgICAgICAgICAgIC8vIEhBQ0s6IFdlIGluY3JlYXNlIHRoZSBhbW91bnQgb2Ygc2Nyb2xsIHRvIGNvdW50ZXJhY3Qgc21vb3RoIHNjcm9sbGluZyBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAvLyBTbW9vdGggc2Nyb2xsaW5nIGJyb3dzZXJzIChGaXJlZm94KSB1c2UgdGhlIHJlbGF0aXZlIGFyZWEgdG8gZGV0ZXJtaW5lIHRoZSBzY3JvbGxcbiAgICAgICAgICAgICAgICAvLyBhbW91bnQsIHdoaWNoIG1lYW5zIHRoZSBsaWtlbHkgc21hbGwgYXJlYSBvZiBjb250ZW50IHJlc3VsdHMgaW4gYSBzbWFsbCBhbW91bnQgb2ZcbiAgICAgICAgICAgICAgICAvLyBtb3ZlbWVudCAtIG5vdCB3aGF0IHBlb3BsZSBleHBlY3QuIFdlIHBpY2sgYXJiaXRyYXJ5IHZhbHVlcyBmb3Igd2hlbiB0byBhcHBseSBtb3JlXG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsLCBhbmQgaG93IG11Y2ggdG8gYXBwbHkuIE9uIFdpbmRvd3MgMTAsIENocm9tZSBzY3JvbGxzIDEwMCB1bml0cyB3aGVyZWFzXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzY3JvbGxzIGp1c3QgMyBkdWUgdG8gc21vb3RoIHNjcm9sbGluZy5cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxTY3JvbGwgPSBlLmRlbHRhWSA8IDAgPyAtNTAgOiA1MDtcblxuICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1N1c3BpY2lvdXNOYW1lQ29tYmluYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBNYXRoLmFicyhlLmRlbHRhWSkgPCAyNSA/IChlLmRlbHRhWSArIGFkZGl0aW9uYWxTY3JvbGwpIDogZS5kZWx0YVk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgKz0gdmFsICogeVJldGVudGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IEpTWC5FbGVtZW50IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCB0cmFja0hvcml6b250YWxPdmVyZmxvdywgdmVydGljYWxTY3JvbGxzSG9yaXpvbnRhbGx5LCAuLi5vdGhlclByb3BzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGxlZnRJbmRpY2F0b3JTdHlsZSA9IHsgbGVmdDogdGhpcy5zdGF0ZS5sZWZ0SW5kaWNhdG9yT2Zmc2V0IH07XG4gICAgICAgIGNvbnN0IHJpZ2h0SW5kaWNhdG9yU3R5bGUgPSB7IHJpZ2h0OiB0aGlzLnN0YXRlLnJpZ2h0SW5kaWNhdG9yT2Zmc2V0IH07XG4gICAgICAgIGNvbnN0IGxlZnRPdmVyZmxvd0luZGljYXRvciA9IHRyYWNrSG9yaXpvbnRhbE92ZXJmbG93XG4gICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPVwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2xlZnRPdmVyZmxvd0luZGljYXRvclwiIHN0eWxlPXtsZWZ0SW5kaWNhdG9yU3R5bGV9IC8+IDogbnVsbDtcbiAgICAgICAgY29uc3QgcmlnaHRPdmVyZmxvd0luZGljYXRvciA9IHRyYWNrSG9yaXpvbnRhbE92ZXJmbG93XG4gICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPVwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX3JpZ2h0T3ZlcmZsb3dJbmRpY2F0b3JcIiBzdHlsZT17cmlnaHRJbmRpY2F0b3JTdHlsZX0gLz4gOiBudWxsO1xuXG4gICAgICAgIHJldHVybiAoPEF1dG9IaWRlU2Nyb2xsYmFyXG4gICAgICAgICAgICB7Li4ub3RoZXJQcm9wc31cbiAgICAgICAgICAgIHJlZj17dGhpcy5hdXRvSGlkZVNjcm9sbGJhcn1cbiAgICAgICAgICAgIHdyYXBwZWRSZWY9e3RoaXMuY29sbGVjdFNjcm9sbGVyfVxuICAgICAgICAgICAgb25XaGVlbD17dGhpcy5vbk1vdXNlV2hlZWx9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsgbGVmdE92ZXJmbG93SW5kaWNhdG9yIH1cbiAgICAgICAgICAgIHsgY2hpbGRyZW4gfVxuICAgICAgICAgICAgeyByaWdodE92ZXJmbG93SW5kaWNhdG9yIH1cbiAgICAgICAgPC9BdXRvSGlkZVNjcm9sbGJhcj4pO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUVBOztBQUNBOzs7Ozs7OztBQXFCZSxNQUFNQSxrQkFBTixTQUVMQyxjQUFBLENBQU1DLFNBRkQsQ0FFOEI7RUFJTjtFQUVuQ0MsV0FBVyxDQUFDQyxLQUFELEVBQW1CO0lBQzFCLE1BQU1BLEtBQU47SUFEMEIsc0VBTEYsSUFBQUMsZ0JBQUEsR0FLRTtJQUFBO0lBQUEsMERBSFEsSUFHUjtJQUFBLDZEQUZFLENBRUY7SUFBQSx1REFTSEMsUUFBRCxJQUFvQztNQUMxRCxLQUFLRixLQUFMLENBQVdHLFVBQVgsR0FBd0JELFFBQXhCOztNQUNBLElBQUlBLFFBQVEsSUFBSSxDQUFDLEtBQUtFLGFBQXRCLEVBQXFDO1FBQ2pDLEtBQUtBLGFBQUwsR0FBcUJGLFFBQXJCLENBRGlDLENBRWpDO1FBQ0E7O1FBQ0EsS0FBS0UsYUFBTCxDQUFtQkMsZ0JBQW5CLENBQW9DLFFBQXBDLEVBQThDLEtBQUtDLGFBQW5ELEVBQWtFO1VBQUVDLE9BQU8sRUFBRTtRQUFYLENBQWxFO1FBQ0EsS0FBS0QsYUFBTDtNQUNIO0lBQ0osQ0FsQjZCO0lBQUEscURBb0NOLE1BQVk7TUFDaEMsTUFBTUUsY0FBYyxHQUFHLEtBQUtKLGFBQUwsQ0FBbUJLLFNBQW5CLEdBQStCLENBQXREO01BQ0EsTUFBTUMsaUJBQWlCLEdB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