"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _FormattingUtils = require("../../../utils/FormattingUtils");

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

var _AccessibleButton = _interopRequireDefault(require("../elements/AccessibleButton"));

var _NotificationState = require("../../../stores/notifications/NotificationState");

var _Tooltip = _interopRequireDefault(require("../elements/Tooltip"));

var _languageHandler = require("../../../languageHandler");

var _NotificationColor = require("../../../stores/notifications/NotificationColor");

const _excluded = ["notification", "showUnsentTooltip", "forceCount", "roomId", "onClick"];

class NotificationBadge extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "countWatcherRef", void 0);
    (0, _defineProperty2.default)(this, "countPreferenceChanged", () => {
      this.setState({
        showCounts: _SettingsStore.default.getValue("Notifications.alwaysShowBadgeCounts", this.roomId)
      });
    });
    (0, _defineProperty2.default)(this, "onNotificationUpdate", () => {
      this.forceUpdate(); // notification state changed - update
    });
    (0, _defineProperty2.default)(this, "onMouseOver", e => {
      e.stopPropagation();
      this.setState({
        showTooltip: true
      });
    });
    (0, _defineProperty2.default)(this, "onMouseLeave", () => {
      this.setState({
        showTooltip: false
      });
    });
    this.props.notification.on(_NotificationState.NotificationStateEvents.Update, this.onNotificationUpdate);
    this.state = {
      showCounts: _SettingsStore.default.getValue("Notifications.alwaysShowBadgeCounts", this.roomId),
      showTooltip: false
    };
    this.countWatcherRef = _SettingsStore.default.watchSetting("Notifications.alwaysShowBadgeCounts", this.roomId, this.countPreferenceChanged);
  }

  get roomId() {
    // We should convert this to null for safety with the SettingsStore
    return this.props.roomId || null;
  }

  componentWillUnmount() {
    _SettingsStore.default.unwatchSetting(this.countWatcherRef);

    this.props.notification.off(_NotificationState.NotificationStateEvents.Update, this.onNotificationUpdate);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.notification) {
      prevProps.notification.off(_NotificationState.NotificationStateEvents.Update, this.onNotificationUpdate);
    }

    this.props.notification.on(_NotificationState.NotificationStateEvents.Update, this.onNotificationUpdate);
  }

  render() {
    /* eslint @typescript-eslint/no-unused-vars: ["error", { "ignoreRestSiblings": true }] */
    const _this$props = this.props,
          {
      notification,
      showUnsentTooltip,
      forceCount,
      roomId,
      onClick
    } = _this$props,
          props = (0, _objectWithoutProperties2.default)(_this$props, _excluded); // Don't show a badge if we don't need to

    if (notification.isIdle) return null; // TODO: Update these booleans for FTUE Notifications: https://github.com/vector-im/element-web/issues/14261
    // As of writing, that is "if red, show count always" and "optionally show counts instead of dots".
    // See git diff for what that boolean state looks like.
    // XXX: We ignore this.state.showCounts (the setting which controls counts vs dots).

    const hasAnySymbol = notification.symbol || notification.count > 0;
    let isEmptyBadge = !hasAnySymbol || !notification.hasUnreadCount;

    if (forceCount) {
      isEmptyBadge = false;
      if (!notification.hasUnreadCount) return null; // Can't render a badge
    }

    let symbol = notification.symbol || (0, _FormattingUtils.formatCount)(notification.count);
    if (isEmptyBadge) symbol = "";
    const classes = (0, _classnames.default)({
      'mx_NotificationBadge': true,
      'mx_NotificationBadge_visible': isEmptyBadge ? true : notification.hasUnreadCount,
      'mx_NotificationBadge_highlighted': notification.hasMentions,
      'mx_NotificationBadge_dot': isEmptyBadge,
      'mx_NotificationBadge_2char': symbol.length > 0 && symbol.length < 3,
      'mx_NotificationBadge_3char': symbol.length > 2
    });

    if (onClick) {
      let label;
      let tooltip;

      if (showUnsentTooltip && this.state.showTooltip && notification.color === _NotificationColor.NotificationColor.Unsent) {
        label = (0, _languageHandler._t)("Message didn't send. Click for info.");
        tooltip = /*#__PURE__*/_react.default.createElement(_Tooltip.default, {
          className: "mx_RoleButton_tooltip",
          label: label
        });
      }

      return /*#__PURE__*/_react.default.createElement(_AccessibleButton.default, (0, _extends2.default)({
        "aria-label": label
      }, props, {
        className: classes,
        onClick: onClick,
        onMouseOver: this.onMouseOver,
        onMouseLeave: this.onMouseLeave
      }), /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_NotificationBadge_count"
      }, symbol), tooltip);
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: classes
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "mx_NotificationBadge_count"
    }, symbol));
  }

}

exports.default = NotificationBadge;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOb3RpZmljYXRpb25CYWRnZSIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzZXRTdGF0ZSIsInNob3dDb3VudHMiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJyb29tSWQiLCJmb3JjZVVwZGF0ZSIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJzaG93VG9vbHRpcCIsIm5vdGlmaWNhdGlvbiIsIm9uIiwiTm90aWZpY2F0aW9uU3RhdGVFdmVudHMiLCJVcGRhdGUiLCJvbk5vdGlmaWNhdGlvblVwZGF0ZSIsInN0YXRlIiwiY291bnRXYXRjaGVyUmVmIiwid2F0Y2hTZXR0aW5nIiwiY291bnRQcmVmZXJlbmNlQ2hhbmdlZCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidW53YXRjaFNldHRpbmciLCJvZmYiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJyZW5kZXIiLCJzaG93VW5zZW50VG9vbHRpcCIsImZvcmNlQ291bnQiLCJvbkNsaWNrIiwiaXNJZGxlIiwiaGFzQW55U3ltYm9sIiwic3ltYm9sIiwiY291bnQiLCJpc0VtcHR5QmFkZ2UiLCJoYXNVbnJlYWRDb3VudCIsImZvcm1hdENvdW50IiwiY2xhc3NlcyIsImNsYXNzTmFtZXMiLCJoYXNNZW50aW9ucyIsImxlbmd0aCIsImxhYmVsIiwidG9vbHRpcCIsImNvbG9yIiwiTm90aWZpY2F0aW9uQ29sb3IiLCJVbnNlbnQiLCJfdCIsIm9uTW91c2VPdmVyIiwib25Nb3VzZUxlYXZlIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3Mvcm9vbXMvTm90aWZpY2F0aW9uQmFkZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBNb3VzZUV2ZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5pbXBvcnQgeyBmb3JtYXRDb3VudCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9Gb3JtYXR0aW5nVXRpbHNcIjtcbmltcG9ydCBTZXR0aW5nc1N0b3JlIGZyb20gXCIuLi8uLi8uLi9zZXR0aW5ncy9TZXR0aW5nc1N0b3JlXCI7XG5pbXBvcnQgQWNjZXNzaWJsZUJ1dHRvbiBmcm9tIFwiLi4vZWxlbWVudHMvQWNjZXNzaWJsZUJ1dHRvblwiO1xuaW1wb3J0IHsgWE9SIH0gZnJvbSBcIi4uLy4uLy4uL0B0eXBlcy9jb21tb25cIjtcbmltcG9ydCB7IE5vdGlmaWNhdGlvblN0YXRlLCBOb3RpZmljYXRpb25TdGF0ZUV2ZW50cyB9IGZyb20gXCIuLi8uLi8uLi9zdG9yZXMvbm90aWZpY2F0aW9ucy9Ob3RpZmljYXRpb25TdGF0ZVwiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2VsZW1lbnRzL1Rvb2x0aXBcIjtcbmltcG9ydCB7IF90IH0gZnJvbSBcIi4uLy4uLy4uL2xhbmd1YWdlSGFuZGxlclwiO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uQ29sb3IgfSBmcm9tIFwiLi4vLi4vLi4vc3RvcmVzL25vdGlmaWNhdGlvbnMvTm90aWZpY2F0aW9uQ29sb3JcIjtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb25TdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBiYWRnZSB3aWxsIHNob3cgYSBjb3VudCBpZiBhdCBhbGwgcG9zc2libGUuIFRoaXMgaXMgdHlwaWNhbGx5XG4gICAgICogdXNlZCB0byBvdmVycmlkZSB0aGUgdXNlcidzIHByZWZlcmVuY2UgZm9yIHRoaW5ncyBsaWtlIHJvb20gc3VibGlzdHMuXG4gICAgICovXG4gICAgZm9yY2VDb3VudD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vbSBJRCwgaWYgYW55LCB0aGUgYmFkZ2UgcmVwcmVzZW50cy5cbiAgICAgKi9cbiAgICByb29tSWQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJQ2xpY2thYmxlUHJvcHMgZXh0ZW5kcyBJUHJvcHMsIFJlYWN0LklucHV0SFRNTEF0dHJpYnV0ZXM8RWxlbWVudD4ge1xuICAgIHNob3dVbnNlbnRUb29sdGlwPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiBzcGVjaWZpZWQgd2lsbCByZXR1cm4gYW4gQWNjZXNzaWJsZUJ1dHRvbiBpbnN0ZWFkIG9mIGEgZGl2LlxuICAgICAqL1xuICAgIG9uQ2xpY2s/KGV2OiBSZWFjdC5Nb3VzZUV2ZW50KTtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgc2hvd0NvdW50czogYm9vbGVhbjsgLy8gd2hldGhlciBvciBub3QgdG8gc2hvdyBjb3VudHMuIEluZGVwZW5kZW50IG9mIHByb3BzLmZvcmNlQ291bnRcbiAgICBzaG93VG9vbHRpcDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm90aWZpY2F0aW9uQmFkZ2UgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFhPUjxJUHJvcHMsIElDbGlja2FibGVQcm9wcz4sIElTdGF0ZT4ge1xuICAgIHByaXZhdGUgY291bnRXYXRjaGVyUmVmOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSVByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5wcm9wcy5ub3RpZmljYXRpb24ub24oTm90aWZpY2F0aW9uU3RhdGVFdmVudHMuVXBkYXRlLCB0aGlzLm9uTm90aWZpY2F0aW9uVXBkYXRlKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hvd0NvdW50czogU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIk5vdGlmaWNhdGlvbnMuYWx3YXlzU2hvd0JhZGdlQ291bnRzXCIsIHRoaXMucm9vbUlkKSxcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvdW50V2F0Y2hlclJlZiA9IFNldHRpbmdzU3RvcmUud2F0Y2hTZXR0aW5nKFxuICAgICAgICAgICAgXCJOb3RpZmljYXRpb25zLmFsd2F5c1Nob3dCYWRnZUNvdW50c1wiLCB0aGlzLnJvb21JZCxcbiAgICAgICAgICAgIHRoaXMuY291bnRQcmVmZXJlbmNlQ2hhbmdlZCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCByb29tSWQoKTogc3RyaW5nIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbnZlcnQgdGhpcyB0byBudWxsIGZvciBzYWZldHkgd2l0aCB0aGUgU2V0dGluZ3NTdG9yZVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5yb29tSWQgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIFNldHRpbmdzU3RvcmUudW53YXRjaFNldHRpbmcodGhpcy5jb3VudFdhdGNoZXJSZWYpO1xuICAgICAgICB0aGlzLnByb3BzLm5vdGlmaWNhdGlvbi5vZmYoTm90aWZpY2F0aW9uU3RhdGVFdmVudHMuVXBkYXRlLCB0aGlzLm9uTm90aWZpY2F0aW9uVXBkYXRlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUmVhZG9ubHk8SVByb3BzPikge1xuICAgICAgICBpZiAocHJldlByb3BzLm5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgcHJldlByb3BzLm5vdGlmaWNhdGlvbi5vZmYoTm90aWZpY2F0aW9uU3RhdGVFdmVudHMuVXBkYXRlLCB0aGlzLm9uTm90aWZpY2F0aW9uVXBkYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMubm90aWZpY2F0aW9uLm9uKE5vdGlmaWNhdGlvblN0YXRlRXZlbnRzLlVwZGF0ZSwgdGhpcy5vbk5vdGlmaWNhdGlvblVwZGF0ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb3VudFByZWZlcmVuY2VDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2hvd0NvdW50czogU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcIk5vdGlmaWNhdGlvbnMuYWx3YXlzU2hvd0JhZGdlQ291bnRzXCIsIHRoaXMucm9vbUlkKSB9KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk5vdGlmaWNhdGlvblVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpOyAvLyBub3RpZmljYXRpb24gc3RhdGUgY2hhbmdlZCAtIHVwZGF0ZVxuICAgIH07XG5cbiAgICBwcml2YXRlIG9uTW91c2VPdmVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzaG93VG9vbHRpcDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25Nb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgICAgICAgLyogZXNsaW50IEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVJlc3RTaWJsaW5nc1wiOiB0cnVlIH1dICovXG4gICAgICAgIGNvbnN0IHsgbm90aWZpY2F0aW9uLCBzaG93VW5zZW50VG9vbHRpcCwgZm9yY2VDb3VudCwgcm9vbUlkLCBvbkNsaWNrLCAuLi5wcm9wcyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAvLyBEb24ndCBzaG93IGEgYmFkZ2UgaWYgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLmlzSWRsZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoZXNlIGJvb2xlYW5zIGZvciBGVFVFIE5vdGlmaWNhdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzE0MjYxXG4gICAgICAgIC8vIEFzIG9mIHdyaXRpbmcsIHRoYXQgaXMgXCJpZiByZWQsIHNob3cgY291bnQgYWx3YXlzXCIgYW5kIFwib3B0aW9uYWxseSBzaG93IGNvdW50cyBpbnN0ZWFkIG9mIGRvdHNcIi5cbiAgICAgICAgLy8gU2VlIGdpdCBkaWZmIGZvciB3aGF0IHRoYXQgYm9vbGVhbiBzdGF0ZSBsb29rcyBsaWtlLlxuICAgICAgICAvLyBYWFg6IFdlIGlnbm9yZSB0aGlzLnN0YXRlLnNob3dDb3VudHMgKHRoZSBzZXR0aW5nIHdoaWNoIGNvbnRyb2xzIGNvdW50cyB2cyBkb3RzKS5cbiAgICAgICAgY29uc3QgaGFzQW55U3ltYm9sID0gbm90aWZpY2F0aW9uLnN5bWJvbCB8fCBub3RpZmljYXRpb24uY291bnQgPiAwO1xuICAgICAgICBsZXQgaXNFbXB0eUJhZGdlID0gIWhhc0FueVN5bWJvbCB8fCAhbm90aWZpY2F0aW9uLmhhc1VucmVhZENvdW50O1xuICAgICAgICBpZiAoZm9yY2VDb3VudCkge1xuICAgICAgICAgICAgaXNFbXB0eUJhZGdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvbi5oYXNVbnJlYWRDb3VudCkgcmV0dXJuIG51bGw7IC8vIENhbid0IHJlbmRlciBhIGJhZGdlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3ltYm9sID0gbm90aWZpY2F0aW9uLnN5bWJvbCB8fCBmb3JtYXRDb3VudChub3RpZmljYXRpb24uY291bnQpO1xuICAgICAgICBpZiAoaXNFbXB0eUJhZGdlKSBzeW1ib2wgPSBcIlwiO1xuXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdteF9Ob3RpZmljYXRpb25CYWRnZSc6IHRydWUsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfdmlzaWJsZSc6IGlzRW1wdHlCYWRnZSA/IHRydWUgOiBub3RpZmljYXRpb24uaGFzVW5yZWFkQ291bnQsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfaGlnaGxpZ2h0ZWQnOiBub3RpZmljYXRpb24uaGFzTWVudGlvbnMsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfZG90JzogaXNFbXB0eUJhZGdlLFxuICAgICAgICAgICAgJ214X05vdGlmaWNhdGlvbkJhZGdlXzJjaGFyJzogc3ltYm9sLmxlbmd0aCA+IDAgJiYgc3ltYm9sLmxlbmd0aCA8IDMsXG4gICAgICAgICAgICAnbXhfTm90aWZpY2F0aW9uQmFkZ2VfM2NoYXInOiBzeW1ib2wubGVuZ3RoID4gMixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIGxldCBsYWJlbDogc3RyaW5nO1xuICAgICAgICAgICAgbGV0IHRvb2x0aXA6IEpTWC5FbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNob3dVbnNlbnRUb29sdGlwICYmIHRoaXMuc3RhdGUuc2hvd1Rvb2x0aXAgJiYgbm90aWZpY2F0aW9uLmNvbG9yID09PSBOb3RpZmljYXRpb25Db2xvci5VbnNlbnQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IF90KFwiTWVzc2FnZSBkaWRuJ3Qgc2VuZC4gQ2xpY2sgZm9yIGluZm8uXCIpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSA8VG9vbHRpcCBjbGFzc05hbWU9XCJteF9Sb2xlQnV0dG9uX3Rvb2x0aXBcIiBsYWJlbD17bGFiZWx9IC8+O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxBY2Nlc3NpYmxlQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2xhYmVsfVxuICAgICAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9e3RoaXMub25Nb3VzZU92ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5vbk1vdXNlTGVhdmV9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJteF9Ob3RpZmljYXRpb25CYWRnZV9jb3VudFwiPnsgc3ltYm9sIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIHsgdG9vbHRpcCB9XG4gICAgICAgICAgICAgICAgPC9BY2Nlc3NpYmxlQnV0dG9uPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibXhfTm90aWZpY2F0aW9uQmFkZ2VfY291bnRcIj57IHN5bWJvbCB9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUE4QmUsTUFBTUEsaUJBQU4sU0FBZ0NDLGNBQUEsQ0FBTUMsYUFBdEMsQ0FBMEY7RUFHckdDLFdBQVcsQ0FBQ0MsS0FBRCxFQUFnQjtJQUN2QixNQUFNQSxLQUFOO0lBRHVCO0lBQUEsOERBaUNNLE1BQU07TUFDbkMsS0FBS0MsUUFBTCxDQUFjO1FBQUVDLFVBQVUsRUFBRUMsc0JBQUEsQ0FBY0MsUUFBZCxDQUF1QixxQ0FBdkIsRUFBOEQsS0FBS0MsTUFBbkU7TUFBZCxDQUFkO0lBQ0gsQ0FuQzBCO0lBQUEsNERBcUNJLE1BQU07TUFDakMsS0FBS0MsV0FBTCxHQURpQyxDQUNiO0lBQ3ZCLENBdkMwQjtJQUFBLG1EQXlDSkMsQ0FBRCxJQUFtQjtNQUNyQ0EsQ0FBQyxDQUFDQyxlQUFGO01BQ0EsS0FBS1AsUUFBTCxDQUFjO1FBQ1ZRLFdBQVcsRUFBRTtNQURILENBQWQ7SUFHSCxDQTlDMEI7SUFBQSxvREFnREosTUFBTTtNQUN6QixLQUFLUixRQUFMLENBQWM7UUFDVlEsV0FBVyxFQUFFO01BREgsQ0FBZDtJQUdILENBcEQwQjtJQUV2QixLQUFLVCxLQUFMLENBQVdVLFlBQVgsQ0FBd0JDLEVBQXhCLENBQTJCQywwQ0FBQSxDQUF3QkMsTUFBbkQsRUFBMkQsS0FBS0Msb0JBQWhFO0lBRUEsS0FBS0MsS0FBTCxHQUFhO01BQ1RiLFVBQVUs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