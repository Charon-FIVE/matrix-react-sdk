"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _EmojiPicker = require("./EmojiPicker");

var _LazyRenderList = _interopRequireDefault(require("../elements/LazyRenderList"));

var _Emoji = _interopRequireDefault(require("./Emoji"));

/*
Copyright 2019 Tulir Asokan <tulir@maunium.net>
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const OVERFLOW_ROWS = 3;

class Category extends _react.default.PureComponent {
  constructor() {
    super(...arguments);
    (0, _defineProperty2.default)(this, "renderEmojiRow", rowIndex => {
      const {
        onClick,
        onMouseEnter,
        onMouseLeave,
        selectedEmojis,
        emojis
      } = this.props;
      const emojisForRow = emojis.slice(rowIndex * 8, (rowIndex + 1) * 8);
      return /*#__PURE__*/_react.default.createElement("div", {
        key: rowIndex
      }, emojisForRow.map(emoji => /*#__PURE__*/_react.default.createElement(_Emoji.default, {
        key: emoji.hexcode,
        emoji: emoji,
        selectedEmojis: selectedEmojis,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        disabled: this.props.isEmojiDisabled?.(emoji.unicode)
      })));
    });
  }

  render() {
    const {
      emojis,
      name,
      heightBefore,
      viewportHeight,
      scrollTop
    } = this.props;

    if (!emojis || emojis.length === 0) {
      return null;
    }

    const rows = new Array(Math.ceil(emojis.length / _EmojiPicker.EMOJIS_PER_ROW));

    for (let counter = 0; counter < rows.length; ++counter) {
      rows[counter] = counter;
    }

    const viewportTop = scrollTop;
    const viewportBottom = viewportTop + viewportHeight;
    const listTop = heightBefore + _EmojiPicker.CATEGORY_HEADER_HEIGHT;
    const listBottom = listTop + rows.length * _EmojiPicker.EMOJI_HEIGHT;
    const top = Math.max(viewportTop, listTop);
    const bottom = Math.min(viewportBottom, listBottom); // the viewport height and scrollTop passed to the LazyRenderList
    // is capped at the intersection with the real viewport, so lists
    // out of view are passed height 0, so they won't render any items.

    const localHeight = Math.max(0, bottom - top);
    const localScrollTop = Math.max(0, scrollTop - listTop);
    return /*#__PURE__*/_react.default.createElement("section", {
      id: `mx_EmojiPicker_category_${this.props.id}`,
      className: "mx_EmojiPicker_category",
      "data-category-id": this.props.id,
      role: "tabpanel",
      "aria-label": name
    }, /*#__PURE__*/_react.default.createElement("h2", {
      className: "mx_EmojiPicker_category_label"
    }, name), /*#__PURE__*/_react.default.createElement(_LazyRenderList.default, {
      element: "ul",
      className: "mx_EmojiPicker_list",
      itemHeight: _EmojiPicker.EMOJI_HEIGHT,
      items: rows,
      scrollTop: localScrollTop,
      height: localHeight,
      overflowItems: OVERFLOW_ROWS,
      overflowMargin: 0,
      renderItem: this.renderEmojiRow
    }));
  }

}

var _default = Category;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPVkVSRkxPV19ST1dTIiwiQ2F0ZWdvcnkiLCJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJyb3dJbmRleCIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJzZWxlY3RlZEVtb2ppcyIsImVtb2ppcyIsInByb3BzIiwiZW1vamlzRm9yUm93Iiwic2xpY2UiLCJtYXAiLCJlbW9qaSIsImhleGNvZGUiLCJpc0Vtb2ppRGlzYWJsZWQiLCJ1bmljb2RlIiwicmVuZGVyIiwibmFtZSIsImhlaWdodEJlZm9yZSIsInZpZXdwb3J0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwibGVuZ3RoIiwicm93cyIsIkFycmF5IiwiTWF0aCIsImNlaWwiLCJFTU9KSVNfUEVSX1JPVyIsImNvdW50ZXIiLCJ2aWV3cG9ydFRvcCIsInZpZXdwb3J0Qm90dG9tIiwibGlzdFRvcCIsIkNBVEVHT1JZX0hFQURFUl9IRUlHSFQiLCJsaXN0Qm90dG9tIiwiRU1PSklfSEVJR0hUIiwidG9wIiwibWF4IiwiYm90dG9tIiwibWluIiwibG9jYWxIZWlnaHQiLCJsb2NhbFNjcm9sbFRvcCIsImlkIiwicmVuZGVyRW1vamlSb3ciXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9lbW9qaXBpY2tlci9DYXRlZ29yeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IFR1bGlyIEFzb2thbiA8dHVsaXJAbWF1bml1bS5uZXQ+XG5Db3B5cmlnaHQgMjAyMCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBSZWZPYmplY3QgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENBVEVHT1JZX0hFQURFUl9IRUlHSFQsIEVNT0pJX0hFSUdIVCwgRU1PSklTX1BFUl9ST1cgfSBmcm9tIFwiLi9FbW9qaVBpY2tlclwiO1xuaW1wb3J0IExhenlSZW5kZXJMaXN0IGZyb20gXCIuLi9lbGVtZW50cy9MYXp5UmVuZGVyTGlzdFwiO1xuaW1wb3J0IHsgREFUQV9CWV9DQVRFR09SWSwgSUVtb2ppIH0gZnJvbSBcIi4uLy4uLy4uL2Vtb2ppXCI7XG5pbXBvcnQgRW1vamkgZnJvbSAnLi9FbW9qaSc7XG5cbmNvbnN0IE9WRVJGTE9XX1JPV1MgPSAzO1xuXG5leHBvcnQgdHlwZSBDYXRlZ29yeUtleSA9IChrZXlvZiB0eXBlb2YgREFUQV9CWV9DQVRFR09SWSkgfCBcInJlY2VudFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDYXRlZ29yeSB7XG4gICAgaWQ6IENhdGVnb3J5S2V5O1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIHZpc2libGU6IGJvb2xlYW47XG4gICAgcmVmOiBSZWZPYmplY3Q8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbW9qaXM6IElFbW9qaVtdO1xuICAgIHNlbGVjdGVkRW1vamlzOiBTZXQ8c3RyaW5nPjtcbiAgICBoZWlnaHRCZWZvcmU6IG51bWJlcjtcbiAgICB2aWV3cG9ydEhlaWdodDogbnVtYmVyO1xuICAgIHNjcm9sbFRvcDogbnVtYmVyO1xuICAgIG9uQ2xpY2soZW1vamk6IElFbW9qaSk6IHZvaWQ7XG4gICAgb25Nb3VzZUVudGVyKGVtb2ppOiBJRW1vamkpOiB2b2lkO1xuICAgIG9uTW91c2VMZWF2ZShlbW9qaTogSUVtb2ppKTogdm9pZDtcbiAgICBpc0Vtb2ppRGlzYWJsZWQ/OiAodW5pY29kZTogc3RyaW5nKSA9PiBib29sZWFuO1xufVxuXG5jbGFzcyBDYXRlZ29yeSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SVByb3BzPiB7XG4gICAgcHJpdmF0ZSByZW5kZXJFbW9qaVJvdyA9IChyb3dJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIHNlbGVjdGVkRW1vamlzLCBlbW9qaXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGVtb2ppc0ZvclJvdyA9IGVtb2ppcy5zbGljZShyb3dJbmRleCAqIDgsIChyb3dJbmRleCArIDEpICogOCk7XG4gICAgICAgIHJldHVybiAoPGRpdiBrZXk9e3Jvd0luZGV4fT57XG4gICAgICAgICAgICBlbW9qaXNGb3JSb3cubWFwKGVtb2ppID0+IChcbiAgICAgICAgICAgICAgICA8RW1vamlcbiAgICAgICAgICAgICAgICAgICAga2V5PXtlbW9qaS5oZXhjb2RlfVxuICAgICAgICAgICAgICAgICAgICBlbW9qaT17ZW1vaml9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRW1vamlzPXtzZWxlY3RlZEVtb2ppc31cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXtvbk1vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17b25Nb3VzZUxlYXZlfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5wcm9wcy5pc0Vtb2ppRGlzYWJsZWQ/LihlbW9qaS51bmljb2RlKX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKSlcbiAgICAgICAgfTwvZGl2Pik7XG4gICAgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBlbW9qaXMsIG5hbWUsIGhlaWdodEJlZm9yZSwgdmlld3BvcnRIZWlnaHQsIHNjcm9sbFRvcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFlbW9qaXMgfHwgZW1vamlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93cyA9IG5ldyBBcnJheShNYXRoLmNlaWwoZW1vamlzLmxlbmd0aCAvIEVNT0pJU19QRVJfUk9XKSk7XG4gICAgICAgIGZvciAobGV0IGNvdW50ZXIgPSAwOyBjb3VudGVyIDwgcm93cy5sZW5ndGg7ICsrY291bnRlcikge1xuICAgICAgICAgICAgcm93c1tjb3VudGVyXSA9IGNvdW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2aWV3cG9ydFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSB2aWV3cG9ydFRvcCArIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICBjb25zdCBsaXN0VG9wID0gaGVpZ2h0QmVmb3JlICsgQ0FURUdPUllfSEVBREVSX0hFSUdIVDtcbiAgICAgICAgY29uc3QgbGlzdEJvdHRvbSA9IGxpc3RUb3AgKyAocm93cy5sZW5ndGggKiBFTU9KSV9IRUlHSFQpO1xuICAgICAgICBjb25zdCB0b3AgPSBNYXRoLm1heCh2aWV3cG9ydFRvcCwgbGlzdFRvcCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWluKHZpZXdwb3J0Qm90dG9tLCBsaXN0Qm90dG9tKTtcbiAgICAgICAgLy8gdGhlIHZpZXdwb3J0IGhlaWdodCBhbmQgc2Nyb2xsVG9wIHBhc3NlZCB0byB0aGUgTGF6eVJlbmRlckxpc3RcbiAgICAgICAgLy8gaXMgY2FwcGVkIGF0IHRoZSBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgcmVhbCB2aWV3cG9ydCwgc28gbGlzdHNcbiAgICAgICAgLy8gb3V0IG9mIHZpZXcgYXJlIHBhc3NlZCBoZWlnaHQgMCwgc28gdGhleSB3b24ndCByZW5kZXIgYW55IGl0ZW1zLlxuICAgICAgICBjb25zdCBsb2NhbEhlaWdodCA9IE1hdGgubWF4KDAsIGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgc2Nyb2xsVG9wIC0gbGlzdFRvcCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzZWN0aW9uXG4gICAgICAgICAgICAgICAgaWQ9e2BteF9FbW9qaVBpY2tlcl9jYXRlZ29yeV8ke3RoaXMucHJvcHMuaWR9YH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteF9FbW9qaVBpY2tlcl9jYXRlZ29yeVwiXG4gICAgICAgICAgICAgICAgZGF0YS1jYXRlZ29yeS1pZD17dGhpcy5wcm9wcy5pZH1cbiAgICAgICAgICAgICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e25hbWV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cIm14X0Vtb2ppUGlja2VyX2NhdGVnb3J5X2xhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSB9XG4gICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICA8TGF6eVJlbmRlckxpc3RcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudD1cInVsXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXhfRW1vamlQaWNrZXJfbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1IZWlnaHQ9e0VNT0pJX0hFSUdIVH1cbiAgICAgICAgICAgICAgICAgICAgaXRlbXM9e3Jvd3N9XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcD17bG9jYWxTY3JvbGxUb3B9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17bG9jYWxIZWlnaHR9XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93SXRlbXM9e09WRVJGTE9XX1JPV1N9XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93TWFyZ2luPXswfVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJJdGVtPXt0aGlzLnJlbmRlckVtb2ppUm93fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXRlZ29yeTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0EsTUFBTUEsYUFBYSxHQUFHLENBQXRCOztBQTBCQSxNQUFNQyxRQUFOLFNBQXVCQyxjQUFBLENBQU1DLGFBQTdCLENBQW1EO0VBQUE7SUFBQTtJQUFBLHNEQUNyQkMsUUFBRCxJQUFzQjtNQUMzQyxNQUFNO1FBQUVDLE9BQUY7UUFBV0MsWUFBWDtRQUF5QkMsWUFBekI7UUFBdUNDLGNBQXZDO1FBQXVEQztNQUF2RCxJQUFrRSxLQUFLQyxLQUE3RTtNQUNBLE1BQU1DLFlBQVksR0FBR0YsTUFBTSxDQUFDRyxLQUFQLENBQWFSLFFBQVEsR0FBRyxDQUF4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