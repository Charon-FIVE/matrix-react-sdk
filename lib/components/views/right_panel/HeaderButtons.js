"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.HeaderKind = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _RightPanelStore = _interopRequireDefault(require("../../../stores/right-panel/RightPanelStore"));

var _AsyncStore = require("../../../stores/AsyncStore");

var _NotificationColor = require("../../../stores/notifications/NotificationColor");

/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2017 Vector Creations Ltd
Copyright 2017 New Vector Ltd
Copyright 2018 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
let HeaderKind;
exports.HeaderKind = HeaderKind;

(function (HeaderKind) {
  HeaderKind["Room"] = "room";
})(HeaderKind || (exports.HeaderKind = HeaderKind = {}));

class HeaderButtons extends _react.default.Component {
  constructor(props, kind) {
    super(props);
    (0, _defineProperty2.default)(this, "unmounted", false);
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "onRightPanelStoreUpdate", () => {
      if (this.unmounted) return;
      this.setState({
        phase: _RightPanelStore.default.instance.currentCard.phase
      });
    });
    const rps = _RightPanelStore.default.instance;
    this.state = {
      headerKind: kind,
      phase: rps.currentCard.phase,
      threadNotificationColor: _NotificationColor.NotificationColor.None
    };
  }

  componentDidMount() {
    _RightPanelStore.default.instance.on(_AsyncStore.UPDATE_EVENT, this.onRightPanelStoreUpdate);

    this.dispatcherRef = _dispatcher.default.register(this.onAction.bind(this)); // used by subclasses
  }

  componentWillUnmount() {
    this.unmounted = true;

    _RightPanelStore.default.instance.off(_AsyncStore.UPDATE_EVENT, this.onRightPanelStoreUpdate);

    if (this.dispatcherRef) _dispatcher.default.unregister(this.dispatcherRef);
  }

  setPhase(phase, cardState) {
    const rps = _RightPanelStore.default.instance;

    if (rps.currentCard.phase == phase && !cardState && rps.isOpen) {
      rps.togglePanel(null);
    } else {
      _RightPanelStore.default.instance.setCard({
        phase,
        state: cardState
      });

      if (!rps.isOpen) rps.togglePanel(null);
    }
  }

  isPhase(phases) {
    if (!_RightPanelStore.default.instance.isOpen) return false;

    if (Array.isArray(phases)) {
      return phases.includes(this.state.phase);
    } else {
      return phases === this.state.phase;
    }
  }

  render() {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_HeaderButtons",
      role: "tablist"
    }, this.renderButtons());
  }

}

exports.default = HeaderButtons;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJIZWFkZXJLaW5kIiwiSGVhZGVyQnV0dG9ucyIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImtpbmQiLCJ1bm1vdW50ZWQiLCJzZXRTdGF0ZSIsInBoYXNlIiwiUmlnaHRQYW5lbFN0b3JlIiwiaW5zdGFuY2UiLCJjdXJyZW50Q2FyZCIsInJwcyIsInN0YXRlIiwiaGVhZGVyS2luZCIsInRocmVhZE5vdGlmaWNhdGlvbkNvbG9yIiwiTm90aWZpY2F0aW9uQ29sb3IiLCJOb25lIiwiY29tcG9uZW50RGlkTW91bnQiLCJvbiIsIlVQREFURV9FVkVOVCIsIm9uUmlnaHRQYW5lbFN0b3JlVXBkYXRlIiwiZGlzcGF0Y2hlclJlZiIsImRpcyIsInJlZ2lzdGVyIiwib25BY3Rpb24iLCJiaW5kIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJvZmYiLCJ1bnJlZ2lzdGVyIiwic2V0UGhhc2UiLCJjYXJkU3RhdGUiLCJpc09wZW4iLCJ0b2dnbGVQYW5lbCIsInNldENhcmQiLCJpc1BoYXNlIiwicGhhc2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5jbHVkZXMiLCJyZW5kZXIiLCJyZW5kZXJCdXR0b25zIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvcmlnaHRfcGFuZWwvSGVhZGVyQnV0dG9ucy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE1LCAyMDE2IE9wZW5NYXJrZXQgTHRkXG5Db3B5cmlnaHQgMjAxNyBWZWN0b3IgQ3JlYXRpb25zIEx0ZFxuQ29weXJpZ2h0IDIwMTcgTmV3IFZlY3RvciBMdGRcbkNvcHlyaWdodCAyMDE4IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAxOSBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBkaXMgZnJvbSAnLi4vLi4vLi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyJztcbmltcG9ydCBSaWdodFBhbmVsU3RvcmUgZnJvbSBcIi4uLy4uLy4uL3N0b3Jlcy9yaWdodC1wYW5lbC9SaWdodFBhbmVsU3RvcmVcIjtcbmltcG9ydCB7IFJpZ2h0UGFuZWxQaGFzZXMgfSBmcm9tICcuLi8uLi8uLi9zdG9yZXMvcmlnaHQtcGFuZWwvUmlnaHRQYW5lbFN0b3JlUGhhc2VzJztcbmltcG9ydCB7IElSaWdodFBhbmVsQ2FyZFN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmVzL3JpZ2h0LXBhbmVsL1JpZ2h0UGFuZWxTdG9yZUlQYW5lbFN0YXRlJztcbmltcG9ydCB7IFVQREFURV9FVkVOVCB9IGZyb20gJy4uLy4uLy4uL3N0b3Jlcy9Bc3luY1N0b3JlJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkNvbG9yIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmVzL25vdGlmaWNhdGlvbnMvTm90aWZpY2F0aW9uQ29sb3InO1xuXG5leHBvcnQgZW51bSBIZWFkZXJLaW5kIHtcbiAgUm9vbSA9IFwicm9vbVwiLFxufVxuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICBoZWFkZXJLaW5kOiBIZWFkZXJLaW5kO1xuICAgIHBoYXNlOiBSaWdodFBhbmVsUGhhc2VzO1xuICAgIHRocmVhZE5vdGlmaWNhdGlvbkNvbG9yOiBOb3RpZmljYXRpb25Db2xvcjtcbn1cblxuaW50ZXJmYWNlIElQcm9wcyB7fVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBIZWFkZXJCdXR0b25zPFAgPSB7fT4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByb3BzICYgUCwgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSB1bm1vdW50ZWQgPSBmYWxzZTtcbiAgICBwcml2YXRlIGRpc3BhdGNoZXJSZWY6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBJUHJvcHMgJiBQLCBraW5kOiBIZWFkZXJLaW5kKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICBjb25zdCBycHMgPSBSaWdodFBhbmVsU3RvcmUuaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoZWFkZXJLaW5kOiBraW5kLFxuICAgICAgICAgICAgcGhhc2U6IHJwcy5jdXJyZW50Q2FyZC5waGFzZSxcbiAgICAgICAgICAgIHRocmVhZE5vdGlmaWNhdGlvbkNvbG9yOiBOb3RpZmljYXRpb25Db2xvci5Ob25lLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgUmlnaHRQYW5lbFN0b3JlLmluc3RhbmNlLm9uKFVQREFURV9FVkVOVCwgdGhpcy5vblJpZ2h0UGFuZWxTdG9yZVVwZGF0ZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlclJlZiA9IGRpcy5yZWdpc3Rlcih0aGlzLm9uQWN0aW9uLmJpbmQodGhpcykpOyAvLyB1c2VkIGJ5IHN1YmNsYXNzZXNcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgUmlnaHRQYW5lbFN0b3JlLmluc3RhbmNlLm9mZihVUERBVEVfRVZFTlQsIHRoaXMub25SaWdodFBhbmVsU3RvcmVVcGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5kaXNwYXRjaGVyUmVmKSBkaXMudW5yZWdpc3Rlcih0aGlzLmRpc3BhdGNoZXJSZWYpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBvbkFjdGlvbihwYXlsb2FkKTtcblxuICAgIHB1YmxpYyBzZXRQaGFzZShwaGFzZTogUmlnaHRQYW5lbFBoYXNlcywgY2FyZFN0YXRlPzogUGFydGlhbDxJUmlnaHRQYW5lbENhcmRTdGF0ZT4pIHtcbiAgICAgICAgY29uc3QgcnBzID0gUmlnaHRQYW5lbFN0b3JlLmluc3RhbmNlO1xuICAgICAgICBpZiAocnBzLmN1cnJlbnRDYXJkLnBoYXNlID09IHBoYXNlICYmICFjYXJkU3RhdGUgJiYgcnBzLmlzT3Blbikge1xuICAgICAgICAgICAgcnBzLnRvZ2dsZVBhbmVsKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmlnaHRQYW5lbFN0b3JlLmluc3RhbmNlLnNldENhcmQoeyBwaGFzZSwgc3RhdGU6IGNhcmRTdGF0ZSB9KTtcbiAgICAgICAgICAgIGlmICghcnBzLmlzT3BlbikgcnBzLnRvZ2dsZVBhbmVsKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGlzUGhhc2UocGhhc2VzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIVJpZ2h0UGFuZWxTdG9yZS5pbnN0YW5jZS5pc09wZW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGhhc2VzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBoYXNlcy5pbmNsdWRlcyh0aGlzLnN0YXRlLnBoYXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwaGFzZXMgPT09IHRoaXMuc3RhdGUucGhhc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUmlnaHRQYW5lbFN0b3JlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy51bm1vdW50ZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHBoYXNlOiBSaWdodFBhbmVsU3RvcmUuaW5zdGFuY2UuY3VycmVudENhcmQucGhhc2UgfSk7XG4gICAgfTtcblxuICAgIC8vIFhYWDogTWFrZSByZW5kZXJCdXR0b25zIGEgcHJvcFxuICAgIHB1YmxpYyBhYnN0cmFjdCByZW5kZXJCdXR0b25zKCk6IEpTWC5FbGVtZW50O1xuXG4gICAgcHVibGljIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibXhfSGVhZGVyQnV0dG9uc1wiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgICAgICB7IHRoaXMucmVuZGVyQnV0dG9ucygpIH1cbiAgICAgICAgPC9kaXY+O1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFvQkE7O0FBRUE7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBV1lBLFU7OztXQUFBQSxVO0VBQUFBLFU7R0FBQUEsVSwwQkFBQUEsVTs7QUFZRyxNQUFlQyxhQUFmLFNBQTZDQyxjQUFBLENBQU1DLFNBQW5ELENBQWlGO0VBSTVGQyxXQUFXLENBQUNDLEtBQUQsRUFBb0JDLElBQXBCLEVBQXNDO0lBQzdDLE1BQU1ELEtBQU47SUFENkMsaURBSDdCLEtBRzZC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