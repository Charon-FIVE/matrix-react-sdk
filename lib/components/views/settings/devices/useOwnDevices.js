"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useOwnDevices = exports.OwnDevicesError = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

var _logger = require("matrix-js-sdk/src/logger");

var _MatrixClientContext = _interopRequireDefault(require("../../../../contexts/MatrixClientContext"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const isDeviceVerified = (matrixClient, crossSigningInfo, device) => {
  try {
    const deviceInfo = matrixClient.getStoredDevice(matrixClient.getUserId(), device.device_id);
    return crossSigningInfo.checkDeviceTrust(crossSigningInfo, deviceInfo, false, true).isCrossSigningVerified();
  } catch (error) {
    _logger.logger.error("Error getting device cross-signing info", error);

    return null;
  }
};

const fetchDevicesWithVerification = async matrixClient => {
  const {
    devices
  } = await matrixClient.getDevices();
  const crossSigningInfo = matrixClient.getStoredCrossSigningForUser(matrixClient.getUserId());
  const devicesDict = devices.reduce((acc, device) => _objectSpread(_objectSpread({}, acc), {}, {
    [device.device_id]: _objectSpread(_objectSpread({}, device), {}, {
      isVerified: isDeviceVerified(matrixClient, crossSigningInfo, device)
    })
  }), {});
  return devicesDict;
};

let OwnDevicesError;
exports.OwnDevicesError = OwnDevicesError;

(function (OwnDevicesError) {
  OwnDevicesError["Unsupported"] = "Unsupported";
  OwnDevicesError["Default"] = "Default";
})(OwnDevicesError || (exports.OwnDevicesError = OwnDevicesError = {}));

const useOwnDevices = () => {
  const matrixClient = (0, _react.useContext)(_MatrixClientContext.default);
  const currentDeviceId = matrixClient.getDeviceId();
  const [devices, setDevices] = (0, _react.useState)({});
  const [isLoading, setIsLoading] = (0, _react.useState)(true);
  const [error, setError] = (0, _react.useState)();
  (0, _react.useEffect)(() => {
    const getDevicesAsync = async () => {
      setIsLoading(true);

      try {
        const devices = await fetchDevicesWithVerification(matrixClient);
        setDevices(devices);
        setIsLoading(false);
      } catch (error) {
        if (error.httpStatus == 404) {
          // 404 probably means the HS doesn't yet support the API.
          setError(OwnDevicesError.Unsupported);
        } else {
          _logger.logger.error("Error loading sessions:", error);

          setError(OwnDevicesError.Default);
        }

        setIsLoading(false);
      }
    };

    getDevicesAsync();
  }, [matrixClient]);
  return {
    devices,
    currentDeviceId,
    isLoading,
    error
  };
};

exports.useOwnDevices = useOwnDevices;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpc0RldmljZVZlcmlmaWVkIiwibWF0cml4Q2xpZW50IiwiY3Jvc3NTaWduaW5nSW5mbyIsImRldmljZSIsImRldmljZUluZm8iLCJnZXRTdG9yZWREZXZpY2UiLCJnZXRVc2VySWQiLCJkZXZpY2VfaWQiLCJjaGVja0RldmljZVRydXN0IiwiaXNDcm9zc1NpZ25pbmdWZXJpZmllZCIsImVycm9yIiwibG9nZ2VyIiwiZmV0Y2hEZXZpY2VzV2l0aFZlcmlmaWNhdGlvbiIsImRldmljZXMiLCJnZXREZXZpY2VzIiwiZ2V0U3RvcmVkQ3Jvc3NTaWduaW5nRm9yVXNlciIsImRldmljZXNEaWN0IiwicmVkdWNlIiwiYWNjIiwiaXNWZXJpZmllZCIsIk93bkRldmljZXNFcnJvciIsInVzZU93bkRldmljZXMiLCJ1c2VDb250ZXh0IiwiTWF0cml4Q2xpZW50Q29udGV4dCIsImN1cnJlbnREZXZpY2VJZCIsImdldERldmljZUlkIiwic2V0RGV2aWNlcyIsInVzZVN0YXRlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2V0RXJyb3IiLCJ1c2VFZmZlY3QiLCJnZXREZXZpY2VzQXN5bmMiLCJodHRwU3RhdHVzIiwiVW5zdXBwb3J0ZWQiLCJEZWZhdWx0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3Mvc2V0dGluZ3MvZGV2aWNlcy91c2VPd25EZXZpY2VzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAyMiBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IElNeURldmljZSwgTWF0cml4Q2xpZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21hdHJpeFwiO1xuaW1wb3J0IHsgQ3Jvc3NTaWduaW5nSW5mbyB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jcnlwdG8vQ3Jvc3NTaWduaW5nXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmltcG9ydCBNYXRyaXhDbGllbnRDb250ZXh0IGZyb20gXCIuLi8uLi8uLi8uLi9jb250ZXh0cy9NYXRyaXhDbGllbnRDb250ZXh0XCI7XG5pbXBvcnQgeyBEZXZpY2VzRGljdGlvbmFyeSB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmNvbnN0IGlzRGV2aWNlVmVyaWZpZWQgPSAoXG4gICAgbWF0cml4Q2xpZW50OiBNYXRyaXhDbGllbnQsXG4gICAgY3Jvc3NTaWduaW5nSW5mbzogQ3Jvc3NTaWduaW5nSW5mbyxcbiAgICBkZXZpY2U6IElNeURldmljZSxcbik6IGJvb2xlYW4gfCBudWxsID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkZXZpY2VJbmZvID0gbWF0cml4Q2xpZW50LmdldFN0b3JlZERldmljZShtYXRyaXhDbGllbnQuZ2V0VXNlcklkKCksIGRldmljZS5kZXZpY2VfaWQpO1xuICAgICAgICByZXR1cm4gY3Jvc3NTaWduaW5nSW5mby5jaGVja0RldmljZVRydXN0KFxuICAgICAgICAgICAgY3Jvc3NTaWduaW5nSW5mbyxcbiAgICAgICAgICAgIGRldmljZUluZm8sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICkuaXNDcm9zc1NpZ25pbmdWZXJpZmllZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGdldHRpbmcgZGV2aWNlIGNyb3NzLXNpZ25pbmcgaW5mb1wiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmNvbnN0IGZldGNoRGV2aWNlc1dpdGhWZXJpZmljYXRpb24gPSBhc3luYyAobWF0cml4Q2xpZW50OiBNYXRyaXhDbGllbnQpOiBQcm9taXNlPERldmljZXNTdGF0ZVsnZGV2aWNlcyddPiA9PiB7XG4gICAgY29uc3QgeyBkZXZpY2VzIH0gPSBhd2FpdCBtYXRyaXhDbGllbnQuZ2V0RGV2aWNlcygpO1xuICAgIGNvbnN0IGNyb3NzU2lnbmluZ0luZm8gPSBtYXRyaXhDbGllbnQuZ2V0U3RvcmVkQ3Jvc3NTaWduaW5nRm9yVXNlcihtYXRyaXhDbGllbnQuZ2V0VXNlcklkKCkpO1xuXG4gICAgY29uc3QgZGV2aWNlc0RpY3QgPSBkZXZpY2VzLnJlZHVjZSgoYWNjLCBkZXZpY2U6IElNeURldmljZSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbZGV2aWNlLmRldmljZV9pZF06IHtcbiAgICAgICAgICAgIC4uLmRldmljZSxcbiAgICAgICAgICAgIGlzVmVyaWZpZWQ6IGlzRGV2aWNlVmVyaWZpZWQobWF0cml4Q2xpZW50LCBjcm9zc1NpZ25pbmdJbmZvLCBkZXZpY2UpLFxuICAgICAgICB9LFxuICAgIH0pLCB7fSk7XG5cbiAgICByZXR1cm4gZGV2aWNlc0RpY3Q7XG59O1xuXG5leHBvcnQgZW51bSBPd25EZXZpY2VzRXJyb3Ige1xuICAgIFVuc3VwcG9ydGVkID0gJ1Vuc3VwcG9ydGVkJyxcbiAgICBEZWZhdWx0ID0gJ0RlZmF1bHQnLFxufVxudHlwZSBEZXZpY2VzU3RhdGUgPSB7XG4gICAgZGV2aWNlczogRGV2aWNlc0RpY3Rpb25hcnk7XG4gICAgY3VycmVudERldmljZUlkOiBzdHJpbmc7XG4gICAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAgIGVycm9yPzogT3duRGV2aWNlc0Vycm9yO1xufTtcbmV4cG9ydCBjb25zdCB1c2VPd25EZXZpY2VzID0gKCk6IERldmljZXNTdGF0ZSA9PiB7XG4gICAgY29uc3QgbWF0cml4Q2xpZW50ID0gdXNlQ29udGV4dChNYXRyaXhDbGllbnRDb250ZXh0KTtcblxuICAgIGNvbnN0IGN1cnJlbnREZXZpY2VJZCA9IG1hdHJpeENsaWVudC5nZXREZXZpY2VJZCgpO1xuXG4gICAgY29uc3QgW2RldmljZXMsIHNldERldmljZXNdID0gdXNlU3RhdGU8RGV2aWNlc1N0YXRlWydkZXZpY2VzJ10+KHt9KTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxPd25EZXZpY2VzRXJyb3I+KCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXREZXZpY2VzQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBmZXRjaERldmljZXNXaXRoVmVyaWZpY2F0aW9uKG1hdHJpeENsaWVudCk7XG4gICAgICAgICAgICAgICAgc2V0RGV2aWNlcyhkZXZpY2VzKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuaHR0cFN0YXR1cyA9PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNDA0IHByb2JhYmx5IG1lYW5zIHRoZSBIUyBkb2Vzbid0IHlldCBzdXBwb3J0IHRoZSBBUEkuXG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKE93bkRldmljZXNFcnJvci5VbnN1cHBvcnRlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgbG9hZGluZyBzZXNzaW9uczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihPd25EZXZpY2VzRXJyb3IuRGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGdldERldmljZXNBc3luYygpO1xuICAgIH0sIFttYXRyaXhDbGllbnRdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRldmljZXMsXG4gICAgICAgIGN1cnJlbnREZXZpY2VJZCxcbiAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICBlcnJvcixcbiAgICB9O1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBR0E7O0FBRUE7Ozs7OztBQUdBLE1BQU1BLGdCQUFnQixHQUFHLENBQ3JCQyxZQURxQixFQUVyQkMsZ0JBRnFCLEVBR3JCQyxNQUhxQixLQUlKO0VBQ2pCLElBQUk7SUFDQSxNQUFNQyxVQUFVLEdBQUdILFlBQVksQ0FBQ0ksZUFBYixDQUE2QkosWUFBWSxDQUFDSyxTQUFiLEVBQTdCLEVBQXVESCxNQUFNLENBQUNJ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