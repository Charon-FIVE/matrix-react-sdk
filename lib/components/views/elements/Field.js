"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = require("lodash");

var _Tooltip = _interopRequireDefault(require("./Tooltip"));

const _excluded = ["element", "inputRef", "prefixComponent", "postfixComponent", "className", "onValidate", "children", "tooltipContent", "forceValidity", "tooltipClassName", "list", "validateOnBlur", "validateOnChange", "validateOnFocus", "usePlaceholderAsHint", "forceTooltipVisible"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

// Invoke validation from user input (when typing, etc.) at most once every N ms.
const VALIDATION_THROTTLE_MS = 200;
const BASE_ID = "mx_Field";
let count = 1;

function getId() {
  return `${BASE_ID}_${count++}`;
}

class Field extends _react.default.PureComponent {
  /*
   * This was changed from throttle to debounce: this is more traditional for
   * form validation since it means that the validation doesn't happen at all
   * until the user stops typing for a bit (debounce defaults to not running on
   * the leading edge). If we're doing an HTTP hit on each validation, we have more
   * incentive to prevent validating input that's very unlikely to be valid.
   * We may find that we actually want different behaviour for registration
   * fields, in which case we can add some options to control it.
   */
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "inputRef", void 0);
    (0, _defineProperty2.default)(this, "validateOnChange", (0, _lodash.debounce)(() => {
      this.validate({
        focused: true
      });
    }, VALIDATION_THROTTLE_MS));
    (0, _defineProperty2.default)(this, "onFocus", ev => {
      this.setState({
        focused: true
      });

      if (this.props.validateOnFocus) {
        this.validate({
          focused: true
        });
      } // Parent component may have supplied its own `onFocus` as well


      if (this.props.onFocus) {
        this.props.onFocus(ev);
      }
    });
    (0, _defineProperty2.default)(this, "onChange", ev => {
      if (this.props.validateOnChange) {
        this.validateOnChange();
      } // Parent component may have supplied its own `onChange` as well


      if (this.props.onChange) {
        this.props.onChange(ev);
      }
    });
    (0, _defineProperty2.default)(this, "onBlur", ev => {
      this.setState({
        focused: false
      });

      if (this.props.validateOnBlur) {
        this.validate({
          focused: false
        });
      } // Parent component may have supplied its own `onBlur` as well


      if (this.props.onBlur) {
        this.props.onBlur(ev);
      }
    });
    this.state = {
      valid: undefined,
      feedback: undefined,
      feedbackVisible: false,
      focused: false
    };
    this.id = this.props.id || getId();
  }

  focus() {
    this.inputRef.current?.focus(); // programmatic does not fire onFocus handler

    this.setState({
      focused: true
    });
  }

  async validate(_ref) {
    let {
      focused,
      allowEmpty = true
    } = _ref;

    if (!this.props.onValidate) {
      return;
    }

    const value = this.inputRef.current?.value ?? null;
    const {
      valid,
      feedback
    } = await this.props.onValidate({
      value,
      focused,
      allowEmpty
    }); // this method is async and so we may have been blurred since the method was called
    // if we have then hide the feedback as withValidation does

    if (this.state.focused && feedback) {
      this.setState({
        valid,
        feedback,
        feedbackVisible: true
      });
    } else {
      // When we receive null `feedback`, we want to hide the tooltip.
      // We leave the previous `feedback` content in state without updating it,
      // so that we can hide the tooltip containing the most recent feedback
      // via CSS animation.
      this.setState({
        valid,
        feedbackVisible: false
      });
    }

    return valid;
  }

  render() {
    /* eslint @typescript-eslint/no-unused-vars: ["error", { "ignoreRestSiblings": true }] */
    const _this$props = this.props,
          {
      element,
      inputRef,
      prefixComponent,
      postfixComponent,
      className,
      onValidate,
      children,
      tooltipContent,
      forceValidity,
      tooltipClassName,
      list,
      validateOnBlur,
      validateOnChange,
      validateOnFocus,
      usePlaceholderAsHint,
      forceTooltipVisible
    } = _this$props,
          inputProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
    this.inputRef = inputRef || /*#__PURE__*/_react.default.createRef();
    inputProps.placeholder = inputProps.placeholder || inputProps.label;
    inputProps.id = this.id; // this overwrites the id from props

    inputProps.onFocus = this.onFocus;
    inputProps.onChange = this.onChange;
    inputProps.onBlur = this.onBlur; // Appease typescript's inference

    const inputProps_ = _objectSpread(_objectSpread({}, inputProps), {}, {
      ref: this.inputRef,
      list
    });

    const fieldInput = /*#__PURE__*/_react.default.createElement(this.props.element, inputProps_, children);

    let prefixContainer = null;

    if (prefixComponent) {
      prefixContainer = /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_Field_prefix"
      }, prefixComponent);
    }

    let postfixContainer = null;

    if (postfixComponent) {
      postfixContainer = /*#__PURE__*/_react.default.createElement("span", {
        className: "mx_Field_postfix"
      }, postfixComponent);
    }

    const hasValidationFlag = forceValidity !== null && forceValidity !== undefined;
    const fieldClasses = (0, _classnames.default)("mx_Field", `mx_Field_${this.props.element}`, className, {
      // If we have a prefix element, leave the label always at the top left and
      // don't animate it, as it looks a bit clunky and would add complexity to do
      // properly.
      mx_Field_labelAlwaysTopLeft: prefixComponent || usePlaceholderAsHint,
      mx_Field_placeholderIsHint: usePlaceholderAsHint,
      mx_Field_valid: hasValidationFlag ? forceValidity : onValidate && this.state.valid === true,
      mx_Field_invalid: hasValidationFlag ? !forceValidity : onValidate && this.state.valid === false
    }); // Handle displaying feedback on validity

    let fieldTooltip;

    if (tooltipContent || this.state.feedback) {
      fieldTooltip = /*#__PURE__*/_react.default.createElement(_Tooltip.default, {
        tooltipClassName: (0, _classnames.default)("mx_Field_tooltip", tooltipClassName),
        visible: this.state.focused && forceTooltipVisible || this.state.feedbackVisible,
        label: tooltipContent || this.state.feedback,
        alignment: _Tooltip.default.Alignment.Right
      });
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: fieldClasses
    }, prefixContainer, fieldInput, /*#__PURE__*/_react.default.createElement("label", {
      htmlFor: this.id
    }, this.props.label), postfixContainer, fieldTooltip);
  }

}

exports.default = Field;
(0, _defineProperty2.default)(Field, "defaultProps", {
  element: "input",
  type: "text",
  validateOnFocus: true,
  validateOnBlur: true,
  validateOnChange: true
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWQUxJREFUSU9OX1RIUk9UVExFX01TIiwiQkFTRV9JRCIsImNvdW50IiwiZ2V0SWQiLCJGaWVsZCIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJkZWJvdW5jZSIsInZhbGlkYXRlIiwiZm9jdXNlZCIsImV2Iiwic2V0U3RhdGUiLCJ2YWxpZGF0ZU9uRm9jdXMiLCJvbkZvY3VzIiwidmFsaWRhdGVPbkNoYW5nZSIsIm9uQ2hhbmdlIiwidmFsaWRhdGVPbkJsdXIiLCJvbkJsdXIiLCJzdGF0ZSIsInZhbGlkIiwidW5kZWZpbmVkIiwiZmVlZGJhY2siLCJmZWVkYmFja1Zpc2libGUiLCJpZCIsImZvY3VzIiwiaW5wdXRSZWYiLCJjdXJyZW50IiwiYWxsb3dFbXB0eSIsIm9uVmFsaWRhdGUiLCJ2YWx1ZSIsInJlbmRlciIsImVsZW1lbnQiLCJwcmVmaXhDb21wb25lbnQiLCJwb3N0Zml4Q29tcG9uZW50IiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJ0b29sdGlwQ29udGVudCIsImZvcmNlVmFsaWRpdHkiLCJ0b29sdGlwQ2xhc3NOYW1lIiwibGlzdCIsInVzZVBsYWNlaG9sZGVyQXNIaW50IiwiZm9yY2VUb29sdGlwVmlzaWJsZSIsImlucHV0UHJvcHMiLCJjcmVhdGVSZWYiLCJwbGFjZWhvbGRlciIsImxhYmVsIiwiaW5wdXRQcm9wc18iLCJyZWYiLCJmaWVsZElucHV0IiwiY3JlYXRlRWxlbWVudCIsInByZWZpeENvbnRhaW5lciIsInBvc3RmaXhDb250YWluZXIiLCJoYXNWYWxpZGF0aW9uRmxhZyIsImZpZWxkQ2xhc3NlcyIsImNsYXNzTmFtZXMiLCJteF9GaWVsZF9sYWJlbEFsd2F5c1RvcExlZnQiLCJteF9GaWVsZF9wbGFjZWhvbGRlcklzSGludCIsIm14X0ZpZWxkX3ZhbGlkIiwibXhfRmllbGRfaW52YWxpZCIsImZpZWxkVG9vbHRpcCIsIlRvb2x0aXAiLCJBbGlnbm1lbnQiLCJSaWdodCIsInR5cGUiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9GaWVsZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IE5ldyBWZWN0b3IgTHRkXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IElucHV0SFRNTEF0dHJpYnV0ZXMsIFNlbGVjdEhUTUxBdHRyaWJ1dGVzLCBUZXh0YXJlYUhUTUxBdHRyaWJ1dGVzLCBSZWZPYmplY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSBcImxvZGFzaFwiO1xuXG5pbXBvcnQgeyBJRmllbGRTdGF0ZSwgSVZhbGlkYXRpb25SZXN1bHQgfSBmcm9tIFwiLi9WYWxpZGF0aW9uXCI7XG5pbXBvcnQgVG9vbHRpcCBmcm9tIFwiLi9Ub29sdGlwXCI7XG5cbi8vIEludm9rZSB2YWxpZGF0aW9uIGZyb20gdXNlciBpbnB1dCAod2hlbiB0eXBpbmcsIGV0Yy4pIGF0IG1vc3Qgb25jZSBldmVyeSBOIG1zLlxuY29uc3QgVkFMSURBVElPTl9USFJPVFRMRV9NUyA9IDIwMDtcblxuY29uc3QgQkFTRV9JRCA9IFwibXhfRmllbGRcIjtcbmxldCBjb3VudCA9IDE7XG5mdW5jdGlvbiBnZXRJZCgpIHtcbiAgICByZXR1cm4gYCR7QkFTRV9JRH1fJHtjb3VudCsrfWA7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZhbGlkYXRlT3B0cyB7XG4gICAgZm9jdXNlZD86IGJvb2xlYW47XG4gICAgYWxsb3dFbXB0eT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBJUHJvcHMge1xuICAgIC8vIFRoZSBmaWVsZCdzIElELCB3aGljaCBiaW5kcyB0aGUgaW5wdXQgYW5kIGxhYmVsIHRvZ2V0aGVyLiBJbW11dGFibGUuXG4gICAgaWQ/OiBzdHJpbmc7XG4gICAgLy8gVGhlIGZpZWxkJ3MgdHlwZSAod2hlbiB1c2VkIGFzIGFuIDxpbnB1dD4pLiBEZWZhdWx0cyB0byBcInRleHRcIi5cbiAgICB0eXBlPzogc3RyaW5nO1xuICAgIC8vIGlkIG9mIGEgPGRhdGFsaXN0PiBlbGVtZW50IGZvciBzdWdnZXN0aW9uc1xuICAgIGxpc3Q/OiBzdHJpbmc7XG4gICAgLy8gVGhlIGZpZWxkJ3MgbGFiZWwgc3RyaW5nLlxuICAgIGxhYmVsPzogc3RyaW5nO1xuICAgIC8vIFRoZSBmaWVsZCdzIHBsYWNlaG9sZGVyIHN0cmluZy4gRGVmYXVsdHMgdG8gdGhlIGxhYmVsLlxuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIC8vIFdoZW4gdHJ1ZSAoZGVmYXVsdCBmYWxzZSksIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIHNob3duIGluc3RlYWQgb2YgdGhlIGxhYmVsIHdoZW5cbiAgICAvLyB0aGUgY29tcG9uZW50IGlzIHVuZm9jdXNlZCAmIGVtcHR5LlxuICAgIHVzZVBsYWNlaG9sZGVyQXNIaW50PzogYm9vbGVhbjtcbiAgICAvLyBPcHRpb25hbCBjb21wb25lbnQgdG8gaW5jbHVkZSBpbnNpZGUgdGhlIGZpZWxkIGJlZm9yZSB0aGUgaW5wdXQuXG4gICAgcHJlZml4Q29tcG9uZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIC8vIE9wdGlvbmFsIGNvbXBvbmVudCB0byBpbmNsdWRlIGluc2lkZSB0aGUgZmllbGQgYWZ0ZXIgdGhlIGlucHV0LlxuICAgIHBvc3RmaXhDb21wb25lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgLy8gVGhlIGNhbGxiYWNrIGNhbGxlZCB3aGVuZXZlciB0aGUgY29udGVudHMgb2YgdGhlIGZpZWxkXG4gICAgLy8gY2hhbmdlcy4gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHZhbGlkYCBib29sZWFuIGZpZWxkXG4gICAgLy8gYW5kIGEgYGZlZWRiYWNrYCByZWFjdCBjb21wb25lbnQgZmllbGQgdG8gcHJvdmlkZSBmZWVkYmFja1xuICAgIC8vIHRvIHRoZSB1c2VyLlxuICAgIG9uVmFsaWRhdGU/OiAoaW5wdXQ6IElGaWVsZFN0YXRlKSA9PiBQcm9taXNlPElWYWxpZGF0aW9uUmVzdWx0PjtcbiAgICAvLyBJZiBzcGVjaWZpZWQsIG92ZXJyaWRlcyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgb25WYWxpZGF0ZS5cbiAgICBmb3JjZVZhbGlkaXR5PzogYm9vbGVhbjtcbiAgICAvLyBJZiBzcGVjaWZpZWQsIGNvbnRlbnRzIHdpbGwgYXBwZWFyIGFzIGEgdG9vbHRpcCBvbiB0aGUgZWxlbWVudCBhbmRcbiAgICAvLyB2YWxpZGF0aW9uIGZlZWRiYWNrIHRvb2x0aXBzIHdpbGwgYmUgc3VwcHJlc3NlZC5cbiAgICB0b29sdGlwQ29udGVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICAvLyBJZiBzcGVjaWZpZWQgdGhlIHRvb2x0aXAgd2lsbCBiZSBzaG93biByZWdhcmRsZXNzIG9mIGZlZWRiYWNrXG4gICAgZm9yY2VUb29sdGlwVmlzaWJsZT86IGJvb2xlYW47XG4gICAgLy8gSWYgc3BlY2lmaWVkIGFsb25nc2lkZSB0b29sdGlwQ29udGVudCwgdGhlIGNsYXNzIG5hbWUgdG8gYXBwbHkgdG8gdGhlXG4gICAgLy8gdG9vbHRpcCBpdHNlbGYuXG4gICAgdG9vbHRpcENsYXNzTmFtZT86IHN0cmluZztcbiAgICAvLyBJZiBzcGVjaWZpZWQsIGFuIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSB0byBhcHBseSB0byB0aGUgZmllbGQgY29udGFpbmVyXG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIC8vIE9uIHdoYXQgZXZlbnRzIHNob3VsZCB2YWxpZGF0aW9uIG9jY3VyOyBieSBkZWZhdWx0IG9uIGFsbFxuICAgIHZhbGlkYXRlT25Gb2N1cz86IGJvb2xlYW47XG4gICAgdmFsaWRhdGVPbkJsdXI/OiBib29sZWFuO1xuICAgIHZhbGlkYXRlT25DaGFuZ2U/OiBib29sZWFuO1xuICAgIC8vIEFsbCBvdGhlciBwcm9wcyBwYXNzIHRocm91Z2ggdG8gdGhlIDxpbnB1dD4uXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUlucHV0UHJvcHMgZXh0ZW5kcyBJUHJvcHMsIElucHV0SFRNTEF0dHJpYnV0ZXM8SFRNTElucHV0RWxlbWVudD4ge1xuICAgIC8vIFRoZSByZWYgcGFzcyB0aHJvdWdoIHRvIHRoZSBpbnB1dFxuICAgIGlucHV0UmVmPzogUmVmT2JqZWN0PEhUTUxJbnB1dEVsZW1lbnQ+O1xuICAgIC8vIFRoZSBlbGVtZW50IHRvIGNyZWF0ZS4gRGVmYXVsdHMgdG8gXCJpbnB1dFwiLlxuICAgIGVsZW1lbnQ/OiBcImlucHV0XCI7XG4gICAgLy8gVGhlIGlucHV0J3MgdmFsdWUuIFRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgc28gdGhlIHZhbHVlIGlzIHJlcXVpcmVkLlxuICAgIHZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJU2VsZWN0UHJvcHMgZXh0ZW5kcyBJUHJvcHMsIFNlbGVjdEhUTUxBdHRyaWJ1dGVzPEhUTUxTZWxlY3RFbGVtZW50PiB7XG4gICAgLy8gVGhlIHJlZiBwYXNzIHRocm91Z2ggdG8gdGhlIHNlbGVjdFxuICAgIGlucHV0UmVmPzogUmVmT2JqZWN0PEhUTUxTZWxlY3RFbGVtZW50PjtcbiAgICAvLyBUbyBkZWZpbmUgb3B0aW9ucyBmb3IgYSBzZWxlY3QsIHVzZSA8RmllbGQ+PG9wdGlvbiAuLi4gLz48L0ZpZWxkPlxuICAgIGVsZW1lbnQ6IFwic2VsZWN0XCI7XG4gICAgLy8gVGhlIHNlbGVjdCdzIHZhbHVlLiBUaGlzIGlzIGEgY29udHJvbGxlZCBjb21wb25lbnQsIHNvIHRoZSB2YWx1ZSBpcyByZXF1aXJlZC5cbiAgICB2YWx1ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSVRleHRhcmVhUHJvcHMgZXh0ZW5kcyBJUHJvcHMsIFRleHRhcmVhSFRNTEF0dHJpYnV0ZXM8SFRNTFRleHRBcmVhRWxlbWVudD4ge1xuICAgIC8vIFRoZSByZWYgcGFzcyB0aHJvdWdoIHRvIHRoZSB0ZXh0YXJlYVxuICAgIGlucHV0UmVmPzogUmVmT2JqZWN0PEhUTUxUZXh0QXJlYUVsZW1lbnQ+O1xuICAgIGVsZW1lbnQ6IFwidGV4dGFyZWFcIjtcbiAgICAvLyBUaGUgdGV4dGFyZWEncyB2YWx1ZS4gVGhpcyBpcyBhIGNvbnRyb2xsZWQgY29tcG9uZW50LCBzbyB0aGUgdmFsdWUgaXMgcmVxdWlyZWQuXG4gICAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTmF0aXZlT25DaGFuZ2VJbnB1dFByb3BzIGV4dGVuZHMgSVByb3BzLCBJbnB1dEhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+IHtcbiAgICAvLyBUaGUgcmVmIHBhc3MgdGhyb3VnaCB0byB0aGUgaW5wdXRcbiAgICBpbnB1dFJlZj86IFJlZk9iamVjdDxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICBlbGVtZW50OiBcImlucHV0XCI7XG4gICAgLy8gVGhlIGlucHV0J3MgdmFsdWUuIFRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgc28gdGhlIHZhbHVlIGlzIHJlcXVpcmVkLlxuICAgIHZhbHVlOiBzdHJpbmc7XG59XG5cbnR5cGUgUHJvcFNoYXBlcyA9IElJbnB1dFByb3BzIHwgSVNlbGVjdFByb3BzIHwgSVRleHRhcmVhUHJvcHMgfCBJTmF0aXZlT25DaGFuZ2VJbnB1dFByb3BzO1xuXG5pbnRlcmZhY2UgSVN0YXRlIHtcbiAgICB2YWxpZDogYm9vbGVhbjtcbiAgICBmZWVkYmFjazogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGZlZWRiYWNrVmlzaWJsZTogYm9vbGVhbjtcbiAgICBmb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcFNoYXBlcywgSVN0YXRlPiB7XG4gICAgcHJpdmF0ZSBpZDogc3RyaW5nO1xuICAgIHByaXZhdGUgaW5wdXRSZWY6IFJlZk9iamVjdDxIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFNlbGVjdEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50PjtcblxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBlbGVtZW50OiBcImlucHV0XCIsXG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICB2YWxpZGF0ZU9uRm9jdXM6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlT25CbHVyOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZU9uQ2hhbmdlOiB0cnVlLFxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFRoaXMgd2FzIGNoYW5nZWQgZnJvbSB0aHJvdHRsZSB0byBkZWJvdW5jZTogdGhpcyBpcyBtb3JlIHRyYWRpdGlvbmFsIGZvclxuICAgICAqIGZvcm0gdmFsaWRhdGlvbiBzaW5jZSBpdCBtZWFucyB0aGF0IHRoZSB2YWxpZGF0aW9uIGRvZXNuJ3QgaGFwcGVuIGF0IGFsbFxuICAgICAqIHVudGlsIHRoZSB1c2VyIHN0b3BzIHR5cGluZyBmb3IgYSBiaXQgKGRlYm91bmNlIGRlZmF1bHRzIHRvIG5vdCBydW5uaW5nIG9uXG4gICAgICogdGhlIGxlYWRpbmcgZWRnZSkuIElmIHdlJ3JlIGRvaW5nIGFuIEhUVFAgaGl0IG9uIGVhY2ggdmFsaWRhdGlvbiwgd2UgaGF2ZSBtb3JlXG4gICAgICogaW5jZW50aXZlIHRvIHByZXZlbnQgdmFsaWRhdGluZyBpbnB1dCB0aGF0J3MgdmVyeSB1bmxpa2VseSB0byBiZSB2YWxpZC5cbiAgICAgKiBXZSBtYXkgZmluZCB0aGF0IHdlIGFjdHVhbGx5IHdhbnQgZGlmZmVyZW50IGJlaGF2aW91ciBmb3IgcmVnaXN0cmF0aW9uXG4gICAgICogZmllbGRzLCBpbiB3aGljaCBjYXNlIHdlIGNhbiBhZGQgc29tZSBvcHRpb25zIHRvIGNvbnRyb2wgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZU9uQ2hhbmdlID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH0sIFZBTElEQVRJT05fVEhST1RUTEVfTVMpO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmFsaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZlZWRiYWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmZWVkYmFja1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMucHJvcHMuaWQgfHwgZ2V0SWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRSZWYuY3VycmVudD8uZm9jdXMoKTtcbiAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGRvZXMgbm90IGZpcmUgb25Gb2N1cyBoYW5kbGVyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkZvY3VzID0gKGV2KSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZm9jdXNlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZhbGlkYXRlT25Gb2N1cykge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAgZm9jdXNlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcmVudCBjb21wb25lbnQgbWF5IGhhdmUgc3VwcGxpZWQgaXRzIG93biBgb25Gb2N1c2AgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRm9jdXMoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25DaGFuZ2UgPSAoZXYpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsaWRhdGVPbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZU9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyZW50IGNvbXBvbmVudCBtYXkgaGF2ZSBzdXBwbGllZCBpdHMgb3duIGBvbkNoYW5nZWAgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbkJsdXIgPSAoZXYpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZhbGlkYXRlT25CbHVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcmVudCBjb21wb25lbnQgbWF5IGhhdmUgc3VwcGxpZWQgaXRzIG93biBgb25CbHVyYCBhcyB3ZWxsXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQmx1cikge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkJsdXIoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBhc3luYyB2YWxpZGF0ZSh7IGZvY3VzZWQsIGFsbG93RW1wdHkgPSB0cnVlIH06IElWYWxpZGF0ZU9wdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLm9uVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXRSZWYuY3VycmVudD8udmFsdWUgPz8gbnVsbDtcbiAgICAgICAgY29uc3QgeyB2YWxpZCwgZmVlZGJhY2sgfSA9IGF3YWl0IHRoaXMucHJvcHMub25WYWxpZGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgICBhbGxvd0VtcHR5LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBpcyBhc3luYyBhbmQgc28gd2UgbWF5IGhhdmUgYmVlbiBibHVycmVkIHNpbmNlIHRoZSBtZXRob2Qgd2FzIGNhbGxlZFxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHRoZW4gaGlkZSB0aGUgZmVlZGJhY2sgYXMgd2l0aFZhbGlkYXRpb24gZG9lc1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5mb2N1c2VkICYmIGZlZWRiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB2YWxpZCxcbiAgICAgICAgICAgICAgICBmZWVkYmFjayxcbiAgICAgICAgICAgICAgICBmZWVkYmFja1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgcmVjZWl2ZSBudWxsIGBmZWVkYmFja2AsIHdlIHdhbnQgdG8gaGlkZSB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgIC8vIFdlIGxlYXZlIHRoZSBwcmV2aW91cyBgZmVlZGJhY2tgIGNvbnRlbnQgaW4gc3RhdGUgd2l0aG91dCB1cGRhdGluZyBpdCxcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIGhpZGUgdGhlIHRvb2x0aXAgY29udGFpbmluZyB0aGUgbW9zdCByZWNlbnQgZmVlZGJhY2tcbiAgICAgICAgICAgIC8vIHZpYSBDU1MgYW5pbWF0aW9uLlxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIC8qIGVzbGludCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJpZ25vcmVSZXN0U2libGluZ3NcIjogdHJ1ZSB9XSAqL1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGlucHV0UmVmLCBwcmVmaXhDb21wb25lbnQsIHBvc3RmaXhDb21wb25lbnQsIGNsYXNzTmFtZSwgb25WYWxpZGF0ZSwgY2hpbGRyZW4sXG4gICAgICAgICAgICB0b29sdGlwQ29udGVudCwgZm9yY2VWYWxpZGl0eSwgdG9vbHRpcENsYXNzTmFtZSwgbGlzdCwgdmFsaWRhdGVPbkJsdXIsIHZhbGlkYXRlT25DaGFuZ2UsIHZhbGlkYXRlT25Gb2N1cyxcbiAgICAgICAgICAgIHVzZVBsYWNlaG9sZGVyQXNIaW50LCBmb3JjZVRvb2x0aXBWaXNpYmxlLFxuICAgICAgICAgICAgLi4uaW5wdXRQcm9wcyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICB0aGlzLmlucHV0UmVmID0gaW5wdXRSZWYgfHwgUmVhY3QuY3JlYXRlUmVmKCk7XG5cbiAgICAgICAgaW5wdXRQcm9wcy5wbGFjZWhvbGRlciA9IGlucHV0UHJvcHMucGxhY2Vob2xkZXIgfHwgaW5wdXRQcm9wcy5sYWJlbDtcbiAgICAgICAgaW5wdXRQcm9wcy5pZCA9IHRoaXMuaWQ7IC8vIHRoaXMgb3ZlcndyaXRlcyB0aGUgaWQgZnJvbSBwcm9wc1xuXG4gICAgICAgIGlucHV0UHJvcHMub25Gb2N1cyA9IHRoaXMub25Gb2N1cztcbiAgICAgICAgaW5wdXRQcm9wcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2U7XG4gICAgICAgIGlucHV0UHJvcHMub25CbHVyID0gdGhpcy5vbkJsdXI7XG5cbiAgICAgICAgLy8gQXBwZWFzZSB0eXBlc2NyaXB0J3MgaW5mZXJlbmNlXG4gICAgICAgIGNvbnN0IGlucHV0UHJvcHNfID0geyAuLi5pbnB1dFByb3BzLCByZWY6IHRoaXMuaW5wdXRSZWYsIGxpc3QgfTtcblxuICAgICAgICBjb25zdCBmaWVsZElucHV0ID0gUmVhY3QuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmVsZW1lbnQsIGlucHV0UHJvcHNfLCBjaGlsZHJlbik7XG5cbiAgICAgICAgbGV0IHByZWZpeENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGlmIChwcmVmaXhDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHByZWZpeENvbnRhaW5lciA9IDxzcGFuIGNsYXNzTmFtZT1cIm14X0ZpZWxkX3ByZWZpeFwiPnsgcHJlZml4Q29tcG9uZW50IH08L3NwYW4+O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb3N0Zml4Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHBvc3RmaXhDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBvc3RmaXhDb250YWluZXIgPSA8c3BhbiBjbGFzc05hbWU9XCJteF9GaWVsZF9wb3N0Zml4XCI+eyBwb3N0Zml4Q29tcG9uZW50IH08L3NwYW4+O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzVmFsaWRhdGlvbkZsYWcgPSBmb3JjZVZhbGlkaXR5ICE9PSBudWxsICYmIGZvcmNlVmFsaWRpdHkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZmllbGRDbGFzc2VzID0gY2xhc3NOYW1lcyhcbiAgICAgICAgICAgIFwibXhfRmllbGRcIixcbiAgICAgICAgICAgIGBteF9GaWVsZF8ke3RoaXMucHJvcHMuZWxlbWVudH1gLFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcmVmaXggZWxlbWVudCwgbGVhdmUgdGhlIGxhYmVsIGFsd2F5cyBhdCB0aGUgdG9wIGxlZnQgYW5kXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYW5pbWF0ZSBpdCwgYXMgaXQgbG9va3MgYSBiaXQgY2x1bmt5IGFuZCB3b3VsZCBhZGQgY29tcGxleGl0eSB0byBkb1xuICAgICAgICAgICAgICAgIC8vIHByb3Blcmx5LlxuICAgICAgICAgICAgICAgIG14X0ZpZWxkX2xhYmVsQWx3YXlzVG9wTGVmdDogcHJlZml4Q29tcG9uZW50IHx8IHVzZVBsYWNlaG9sZGVyQXNIaW50LFxuICAgICAgICAgICAgICAgIG14X0ZpZWxkX3BsYWNlaG9sZGVySXNIaW50OiB1c2VQbGFjZWhvbGRlckFzSGludCxcbiAgICAgICAgICAgICAgICBteF9GaWVsZF92YWxpZDogaGFzVmFsaWRhdGlvbkZsYWcgPyBmb3JjZVZhbGlkaXR5IDogb25WYWxpZGF0ZSAmJiB0aGlzLnN0YXRlLnZhbGlkID09PSB0cnVlLFxuICAgICAgICAgICAgICAgIG14X0ZpZWxkX2ludmFsaWQ6IGhhc1ZhbGlkYXRpb25GbGFnXG4gICAgICAgICAgICAgICAgICAgID8gIWZvcmNlVmFsaWRpdHlcbiAgICAgICAgICAgICAgICAgICAgOiBvblZhbGlkYXRlICYmIHRoaXMuc3RhdGUudmFsaWQgPT09IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBIYW5kbGUgZGlzcGxheWluZyBmZWVkYmFjayBvbiB2YWxpZGl0eVxuICAgICAgICBsZXQgZmllbGRUb29sdGlwO1xuICAgICAgICBpZiAodG9vbHRpcENvbnRlbnQgfHwgdGhpcy5zdGF0ZS5mZWVkYmFjaykge1xuICAgICAgICAgICAgZmllbGRUb29sdGlwID0gPFRvb2x0aXBcbiAgICAgICAgICAgICAgICB0b29sdGlwQ2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibXhfRmllbGRfdG9vbHRpcFwiLCB0b29sdGlwQ2xhc3NOYW1lKX1cbiAgICAgICAgICAgICAgICB2aXNpYmxlPXsodGhpcy5zdGF0ZS5mb2N1c2VkICYmIGZvcmNlVG9vbHRpcFZpc2libGUpIHx8IHRoaXMuc3RhdGUuZmVlZGJhY2tWaXNpYmxlfVxuICAgICAgICAgICAgICAgIGxhYmVsPXt0b29sdGlwQ29udGVudCB8fCB0aGlzLnN0YXRlLmZlZWRiYWNrfVxuICAgICAgICAgICAgICAgIGFsaWdubWVudD17VG9vbHRpcC5BbGlnbm1lbnQuUmlnaHR9XG4gICAgICAgICAgICAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17ZmllbGRDbGFzc2VzfT5cbiAgICAgICAgICAgIHsgcHJlZml4Q29udGFpbmVyIH1cbiAgICAgICAgICAgIHsgZmllbGRJbnB1dCB9XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17dGhpcy5pZH0+eyB0aGlzLnByb3BzLmxhYmVsIH08L2xhYmVsPlxuICAgICAgICAgICAgeyBwb3N0Zml4Q29udGFpbmVyIH1cbiAgICAgICAgICAgIHsgZmllbGRUb29sdGlwIH1cbiAgICAgICAgPC9k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