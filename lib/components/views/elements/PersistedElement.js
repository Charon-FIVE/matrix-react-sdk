"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPersistKey = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _lodash = require("lodash");

var _utils = require("matrix-js-sdk/src/utils");

var _dispatcher = _interopRequireDefault(require("../../../dispatcher/dispatcher"));

var _MatrixClientContext = _interopRequireDefault(require("../../../contexts/MatrixClientContext"));

var _MatrixClientPeg = require("../../../MatrixClientPeg");

/*
Copyright 2018 New Vector Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const getPersistKey = appId => 'widget_' + appId; // Shamelessly ripped off Modal.js.  There's probably a better way
// of doing reusable widgets like dialog boxes & menus where we go and
// pass in a custom control as the actual body.


exports.getPersistKey = getPersistKey;

function getContainer(containerId) {
  return document.getElementById(containerId);
}

function getOrCreateContainer(containerId) {
  let container = getContainer(containerId);

  if (!container) {
    container = document.createElement("div");
    container.id = containerId;
    document.body.appendChild(container);
  }

  return container;
}

/**
 * Class of component that renders its children in a separate ReactDOM virtual tree
 * in a container element appended to document.body.
 *
 * This prevents the children from being unmounted when the parent of PersistedElement
 * unmounts, allowing them to persist.
 *
 * When PE is unmounted, it hides the children using CSS. When mounted or updated, the
 * children are made visible and are positioned into a div that is given the same
 * bounding rect as the parent of PE.
 */
class PersistedElement extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "resizeObserver", void 0);
    (0, _defineProperty2.default)(this, "dispatcherRef", void 0);
    (0, _defineProperty2.default)(this, "childContainer", void 0);
    (0, _defineProperty2.default)(this, "child", void 0);
    (0, _defineProperty2.default)(this, "collectChildContainer", ref => {
      if (this.childContainer) {
        this.resizeObserver.unobserve(this.childContainer);
      }

      this.childContainer = ref;

      if (ref) {
        this.resizeObserver.observe(ref);
      }
    });
    (0, _defineProperty2.default)(this, "collectChild", ref => {
      this.child = ref;
      this.updateChild();
    });
    (0, _defineProperty2.default)(this, "onAction", payload => {
      if (payload.action === 'timeline_resize') {
        this.repositionChild();
      } else if (payload.action === 'logout') {
        PersistedElement.destroyElement(this.props.persistKey);
      }
    });
    (0, _defineProperty2.default)(this, "repositionChild", () => {
      this.updateChildPosition(this.child, this.childContainer);
    });
    (0, _defineProperty2.default)(this, "updateChildPosition", (0, _lodash.throttle)((child, parent) => {
      if (!child || !parent) return;
      const parentRect = parent.getBoundingClientRect();
      Object.assign(child.style, {
        zIndex: (0, _utils.isNullOrUndefined)(this.props.zIndex) ? 9 : this.props.zIndex,
        position: 'absolute',
        top: '0',
        left: '0',
        transform: `translateX(${parentRect.left}px) translateY(${parentRect.top}px)`,
        width: parentRect.width + 'px',
        height: parentRect.height + 'px'
      });
    }, 16, {
      trailing: true,
      leading: true
    }));
    this.resizeObserver = new ResizeObserver(this.repositionChild); // Annoyingly, a resize observer is insufficient, since we also care
    // about when the element moves on the screen without changing its
    // dimensions. Doesn't look like there's a ResizeObserver equivalent
    // for this, so we bodge it by listening for document resize and
    // the timeline_resize action.

    window.addEventListener('resize', this.repositionChild);
    this.dispatcherRef = _dispatcher.default.register(this.onAction);
    if (this.props.moveRef) this.props.moveRef.current = this.repositionChild;
  }
  /**
   * Removes the DOM elements created when a PersistedElement with the given
   * persistKey was mounted. The DOM elements will be re-added if another
   * PersistedElement is mounted in the future.
   *
   * @param {string} persistKey Key used to uniquely identify this PersistedElement
   */


  static destroyElement(persistKey) {
    const container = getContainer('mx_persistedElement_' + persistKey);

    if (container) {
      container.remove();
    }
  }

  static isMounted(persistKey) {
    return Boolean(getContainer('mx_persistedElement_' + persistKey));
  }

  componentDidMount() {
    this.updateChild();
    this.renderApp();
  }

  componentDidUpdate() {
    this.updateChild();
    this.renderApp();
  }

  componentWillUnmount() {
    this.updateChildVisibility(this.child, false);
    this.resizeObserver.disconnect();
    window.removeEventListener('resize', this.repositionChild);

    _dispatcher.default.unregister(this.dispatcherRef);
  }

  updateChild() {
    this.updateChildPosition(this.child, this.childContainer);
    this.updateChildVisibility(this.child, true);
  }

  renderApp() {
    const content = /*#__PURE__*/_react.default.createElement(_MatrixClientContext.default.Provider, {
      value: _MatrixClientPeg.MatrixClientPeg.get()
    }, /*#__PURE__*/_react.default.createElement("div", {
      ref: this.collectChild,
      style: this.props.style
    }, this.props.children));

    _reactDom.default.render(content, getOrCreateContainer('mx_persistedElement_' + this.props.persistKey));
  }

  updateChildVisibility(child, visible) {
    if (!child) return;
    child.style.display = visible ? 'block' : 'none';
  }

  render() {
    return /*#__PURE__*/_react.default.createElement("div", {
      ref: this.collectChildContainer
    });
  }

}

exports.default = PersistedElement;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRQZXJzaXN0S2V5IiwiYXBwSWQiLCJnZXRDb250YWluZXIiLCJjb250YWluZXJJZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRPckNyZWF0ZUNvbnRhaW5lciIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJpZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIlBlcnNpc3RlZEVsZW1lbnQiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJyZWYiLCJjaGlsZENvbnRhaW5lciIsInJlc2l6ZU9ic2VydmVyIiwidW5vYnNlcnZlIiwib2JzZXJ2ZSIsImNoaWxkIiwidXBkYXRlQ2hpbGQiLCJwYXlsb2FkIiwiYWN0aW9uIiwicmVwb3NpdGlvbkNoaWxkIiwiZGVzdHJveUVsZW1lbnQiLCJwZXJzaXN0S2V5IiwidXBkYXRlQ2hpbGRQb3NpdGlvbiIsInRocm90dGxlIiwicGFyZW50IiwicGFyZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk9iamVjdCIsImFzc2lnbiIsInN0eWxlIiwiekluZGV4IiwiaXNOdWxsT3JVbmRlZmluZWQiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ0cmFuc2Zvcm0iLCJ3aWR0aCIsImhlaWdodCIsInRyYWlsaW5nIiwibGVhZGluZyIsIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc3BhdGNoZXJSZWYiLCJkaXMiLCJyZWdpc3RlciIsIm9uQWN0aW9uIiwibW92ZVJlZiIsImN1cnJlbnQiLCJyZW1vdmUiLCJpc01vdW50ZWQiLCJCb29sZWFuIiwiY29tcG9uZW50RGlkTW91bnQiLCJyZW5kZXJBcHAiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInVwZGF0ZUNoaWxkVmlzaWJpbGl0eSIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidW5yZWdpc3RlciIsImNvbnRlbnQiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJjb2xsZWN0Q2hpbGQiLCJjaGlsZHJlbiIsIlJlYWN0RE9NIiwicmVuZGVyIiwidmlzaWJsZSIsImRpc3BsYXkiLCJjb2xsZWN0Q2hpbGRDb250YWluZXIiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9lbGVtZW50cy9QZXJzaXN0ZWRFbGVtZW50LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTggTmV3IFZlY3RvciBMdGQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0LCB7IE11dGFibGVSZWZPYmplY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgaXNOdWxsT3JVbmRlZmluZWQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvdXRpbHNcIjtcblxuaW1wb3J0IGRpcyBmcm9tICcuLi8uLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInO1xuaW1wb3J0IE1hdHJpeENsaWVudENvbnRleHQgZnJvbSBcIi4uLy4uLy4uL2NvbnRleHRzL01hdHJpeENsaWVudENvbnRleHRcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuLi8uLi8uLi9NYXRyaXhDbGllbnRQZWdcIjtcbmltcG9ydCB7IEFjdGlvblBheWxvYWQgfSBmcm9tIFwiLi4vLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0UGVyc2lzdEtleSA9IChhcHBJZDogc3RyaW5nKSA9PiAnd2lkZ2V0XycgKyBhcHBJZDtcblxuLy8gU2hhbWVsZXNzbHkgcmlwcGVkIG9mZiBNb2RhbC5qcy4gIFRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5XG4vLyBvZiBkb2luZyByZXVzYWJsZSB3aWRnZXRzIGxpa2UgZGlhbG9nIGJveGVzICYgbWVudXMgd2hlcmUgd2UgZ28gYW5kXG4vLyBwYXNzIGluIGEgY3VzdG9tIGNvbnRyb2wgYXMgdGhlIGFjdHVhbCBib2R5LlxuXG5mdW5jdGlvbiBnZXRDb250YWluZXIoY29udGFpbmVySWQ6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVySWQpIGFzIEhUTUxEaXZFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJZDogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQge1xuICAgIGxldCBjb250YWluZXIgPSBnZXRDb250YWluZXIoY29udGFpbmVySWQpO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY29udGFpbmVyLmlkID0gY29udGFpbmVySWQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBQZXJzaXN0ZWRFbGVtZW50IGluc3RhbmNlXG4gICAgLy8gQW55IFBlcnNpc3RlZEVsZW1lbnRzIHdpdGggdGhlIHNhbWUgcGVyc2lzdEtleSB3aWxsIHVzZVxuICAgIC8vIHRoZSBzYW1lIERPTSBjb250YWluZXIuXG4gICAgcGVyc2lzdEtleTogc3RyaW5nO1xuXG4gICAgLy8gei1pbmRleCBmb3IgdGhlIGVsZW1lbnQuIERlZmF1bHRzIHRvIDkuXG4gICAgekluZGV4PzogbnVtYmVyO1xuXG4gICAgc3R5bGU/OiBSZWFjdC5TdHlsZUhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PjtcblxuICAgIC8vIEhhbmRsZSB0byBtYW51YWxseSBub3RpZnkgdGhpcyBQZXJzaXN0ZWRFbGVtZW50IHRoYXQgaXQgbmVlZHMgdG8gbW92ZVxuICAgIG1vdmVSZWY/OiBNdXRhYmxlUmVmT2JqZWN0PCgpID0+IHZvaWQ+O1xufVxuXG4vKipcbiAqIENsYXNzIG9mIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgaXRzIGNoaWxkcmVuIGluIGEgc2VwYXJhdGUgUmVhY3RET00gdmlydHVhbCB0cmVlXG4gKiBpbiBhIGNvbnRhaW5lciBlbGVtZW50IGFwcGVuZGVkIHRvIGRvY3VtZW50LmJvZHkuXG4gKlxuICogVGhpcyBwcmV2ZW50cyB0aGUgY2hpbGRyZW4gZnJvbSBiZWluZyB1bm1vdW50ZWQgd2hlbiB0aGUgcGFyZW50IG9mIFBlcnNpc3RlZEVsZW1lbnRcbiAqIHVubW91bnRzLCBhbGxvd2luZyB0aGVtIHRvIHBlcnNpc3QuXG4gKlxuICogV2hlbiBQRSBpcyB1bm1vdW50ZWQsIGl0IGhpZGVzIHRoZSBjaGlsZHJlbiB1c2luZyBDU1MuIFdoZW4gbW91bnRlZCBvciB1cGRhdGVkLCB0aGVcbiAqIGNoaWxkcmVuIGFyZSBtYWRlIHZpc2libGUgYW5kIGFyZSBwb3NpdGlvbmVkIGludG8gYSBkaXYgdGhhdCBpcyBnaXZlbiB0aGUgc2FtZVxuICogYm91bmRpbmcgcmVjdCBhcyB0aGUgcGFyZW50IG9mIFBFLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzaXN0ZWRFbGVtZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm9wcz4ge1xuICAgIHByaXZhdGUgcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xuICAgIHByaXZhdGUgZGlzcGF0Y2hlclJlZjogc3RyaW5nO1xuICAgIHByaXZhdGUgY2hpbGRDb250YWluZXI6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgY2hpbGQ6IEhUTUxEaXZFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLnJlcG9zaXRpb25DaGlsZCk7XG4gICAgICAgIC8vIEFubm95aW5nbHksIGEgcmVzaXplIG9ic2VydmVyIGlzIGluc3VmZmljaWVudCwgc2luY2Ugd2UgYWxzbyBjYXJlXG4gICAgICAgIC8vIGFib3V0IHdoZW4gdGhlIGVsZW1lbnQgbW92ZXMgb24gdGhlIHNjcmVlbiB3aXRob3V0IGNoYW5naW5nIGl0c1xuICAgICAgICAvLyBkaW1lbnNpb25zLiBEb2Vzbid0IGxvb2sgbGlrZSB0aGVyZSdzIGEgUmVzaXplT2JzZXJ2ZXIgZXF1aXZhbGVudFxuICAgICAgICAvLyBmb3IgdGhpcywgc28gd2UgYm9kZ2UgaXQgYnkgbGlzdGVuaW5nIGZvciBkb2N1bWVudCByZXNpemUgYW5kXG4gICAgICAgIC8vIHRoZSB0aW1lbGluZV9yZXNpemUgYWN0aW9uLlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXBvc2l0aW9uQ2hpbGQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXJSZWYgPSBkaXMucmVnaXN0ZXIodGhpcy5vbkFjdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMubW92ZVJlZikgdGhpcy5wcm9wcy5tb3ZlUmVmLmN1cnJlbnQgPSB0aGlzLnJlcG9zaXRpb25DaGlsZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBET00gZWxlbWVudHMgY3JlYXRlZCB3aGVuIGEgUGVyc2lzdGVkRWxlbWVudCB3aXRoIHRoZSBnaXZlblxuICAgICAqIHBlcnNpc3RLZXkgd2FzIG1vdW50ZWQuIFRoZSBET00gZWxlbWVudHMgd2lsbCBiZSByZS1hZGRlZCBpZiBhbm90aGVyXG4gICAgICogUGVyc2lzdGVkRWxlbWVudCBpcyBtb3VudGVkIGluIHRoZSBmdXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGVyc2lzdEtleSBLZXkgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIFBlcnNpc3RlZEVsZW1lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGRlc3Ryb3lFbGVtZW50KHBlcnNpc3RLZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoJ214X3BlcnNpc3RlZEVsZW1lbnRfJyArIHBlcnNpc3RLZXkpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaXNNb3VudGVkKHBlcnNpc3RLZXkpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0Q29udGFpbmVyKCdteF9wZXJzaXN0ZWRFbGVtZW50XycgKyBwZXJzaXN0S2V5KSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb2xsZWN0Q2hpbGRDb250YWluZXIgPSAocmVmOiBIVE1MRGl2RWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5jaGlsZENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5jaGlsZENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZENvbnRhaW5lciA9IHJlZjtcbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBjb2xsZWN0Q2hpbGQgPSAocmVmOiBIVE1MRGl2RWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmNoaWxkID0gcmVmO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkKCk7XG4gICAgfTtcblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZCgpO1xuICAgICAgICB0aGlzLnJlbmRlckFwcCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJBcHAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRWaXNpYmlsaXR5KHRoaXMuY2hpbGQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlcG9zaXRpb25DaGlsZCk7XG4gICAgICAgIGRpcy51bnJlZ2lzdGVyKHRoaXMuZGlzcGF0Y2hlclJlZik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkFjdGlvbiA9IChwYXlsb2FkOiBBY3Rpb25QYXlsb2FkKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChwYXlsb2FkLmFjdGlvbiA9PT0gJ3RpbWVsaW5lX3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvbkNoaWxkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICdsb2dvdXQnKSB7XG4gICAgICAgICAgICBQZXJzaXN0ZWRFbGVtZW50LmRlc3Ryb3lFbGVtZW50KHRoaXMucHJvcHMucGVyc2lzdEtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSByZXBvc2l0aW9uQ2hpbGQgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRQb3NpdGlvbih0aGlzLmNoaWxkLCB0aGlzLmNoaWxkQ29udGFpbmVyKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSB1cGRhdGVDaGlsZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZFBvc2l0aW9uKHRoaXMuY2hpbGQsIHRoaXMuY2hpbGRDb250YWluZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkVmlzaWJpbGl0eSh0aGlzLmNoaWxkLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlckFwcCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IDxNYXRyaXhDbGllbnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtNYXRyaXhDbGllbnRQZWcuZ2V0KCl9PlxuICAgICAgICAgICAgPGRpdiByZWY9e3RoaXMuY29sbGVjdENoaWxkfSBzdHlsZT17dGhpcy5wcm9wcy5zdHlsZX0+XG4gICAgICAgICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L01hdHJpeENsaWVudENvbnRleHQuUHJvdmlkZXI+O1xuXG4gICAgICAgIFJlYWN0RE9NLnJlbmRlcihjb250ZW50LCBnZXRPckNyZWF0ZUNvbnRhaW5lcignbXhfcGVyc2lzdGVkRWxlbWVudF8nK3RoaXMucHJvcHMucGVyc2lzdEtleSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ2hpbGRWaXNpYmlsaXR5KGNoaWxkOiBIVE1MRGl2RWxlbWVudCwgdmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAoIWNoaWxkKSByZXR1cm47XG4gICAgICAgIGNoaWxkLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUNoaWxkUG9zaXRpb24gPSB0aHJvdHRsZSgoY2hpbGQ6IEhUTUxEaXZFbGVtZW50LCBwYXJlbnQ6IEhUTUxEaXZFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghY2hpbGQgfHwgIXBhcmVudCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2hpbGQuc3R5bGUsIHtcbiAgICAgICAgICAgIHpJbmRleDogaXNOdWxsT3JVbmRlZmluZWQodGhpcy5wcm9wcy56SW5kZXgpID8gOSA6IHRoaXMucHJvcHMuekluZGV4LFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtwYXJlbnRSZWN0LmxlZnR9cHgpIHRyYW5zbGF0ZVkoJHtwYXJlbnRSZWN0LnRvcH1weClgLFxuICAgICAgICAgICAgd2lkdGg6IHBhcmVudFJlY3Qud2lkdGggKyAncHgnLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnRSZWN0LmhlaWdodCArICdweCcsXG4gICAgICAgIH0pO1xuICAgIH0sIDE2LCB7IHRyYWlsaW5nOiB0cnVlLCBsZWFkaW5nOiB0cnVlIH0pO1xuXG4gICAgcHVibGljIHJlbmRlcigpOiBKU1guRWxlbWVudCB7XG4gICAgICAgIHJldHVybiA8ZGl2IHJlZj17dGhpcy5jb2xsZWN0Q2hpbGRDb250YWluZXJ9IC8+O1xuICAgIH1cbn1cblxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUF2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWU8sTUFBTUEsYUFBYSxHQUFJQyxLQUFELElBQW1CLFlBQVlBLEtBQXJELEMsQ0FFUDtBQUNBO0FBQ0E7Ozs7O0FBRUEsU0FBU0MsWUFBVCxDQUFzQkMsV0FBdEIsRUFBMkQ7RUFDdkQsT0FBT0MsUUFBUSxDQUFDQyxjQUFULENBQXdCRixXQUF4QixDQUFQO0FBQ0g7O0FBRUQsU0FBU0csb0JBQVQsQ0FBOEJILFdBQTlCLEVBQW1FO0VBQy9ELElBQUlJLFNBQVMsR0FBR0wsWUFBWSxDQUFDQyxXQUFELENBQTVCOztFQUVBLElBQUksQ0FBQ0ksU0FBTCxFQUFnQjtJQUNaQSxTQUFTLEdBQUdILFFBQVEsQ0FBQ0ksYUFBVCxDQUF1QixLQUF2QixDQUFaO0lBQ0FELFNBQVMsQ0FBQ0UsRUFBVixHQUFlTixXQUFmO0lBQ0FDLFFBQVEsQ0FBQ00sSUFBVCxDQUFjQyxXQUFkLENBQTBCSixTQUExQjtFQUNIOztFQUVELE9BQU9BLFNBQVA7QUFDSDs7QUFpQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU1LLGdCQUFOLFNBQStCQyxjQUFBLENBQU1DLFNBQXJDLENBQXVEO0VBTWxFQyxXQUFXLENBQUNDLEtBQUQsRUFBZ0I7SUFDdkIsTUFBTUEsS0FBTjtJQUR1QjtJQUFBO0lBQUE7SUFBQTtJQUFBLDZEQWlDTUMsR0FBRCxJQUErQjtN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