"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _UIStore = _interopRequireWildcard(require("../../../stores/UIStore"));

var _AnimationUtils = require("../../../utils/AnimationUtils");

var _MarkedExecution = require("../../../utils/MarkedExecution");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2021-2022 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const PIP_VIEW_WIDTH = 336;
const PIP_VIEW_HEIGHT = 232;
const MOVING_AMT = 0.2;
const SNAPPING_AMT = 0.1;
const PADDING = {
  top: 58,
  bottom: 58,
  left: 76,
  right: 8
};

/**
 * PictureInPictureDragger shows a small version of CallView hovering over the UI in 'picture-in-picture'
 * (PiP mode). It displays the call(s) which is *not* in the room the user is currently viewing.
 */
class PictureInPictureDragger extends _react.default.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;
    (0, _defineProperty2.default)(this, "callViewWrapper", /*#__PURE__*/(0, _react.createRef)());
    (0, _defineProperty2.default)(this, "initX", 0);
    (0, _defineProperty2.default)(this, "initY", 0);
    (0, _defineProperty2.default)(this, "desiredTranslationX", _UIStore.default.instance.windowWidth - PADDING.right - PIP_VIEW_WIDTH);
    (0, _defineProperty2.default)(this, "desiredTranslationY", _UIStore.default.instance.windowHeight - PADDING.bottom - PIP_VIEW_HEIGHT);
    (0, _defineProperty2.default)(this, "translationX", this.desiredTranslationX);
    (0, _defineProperty2.default)(this, "translationY", this.desiredTranslationY);
    (0, _defineProperty2.default)(this, "moving", false);
    (0, _defineProperty2.default)(this, "scheduledUpdate", new _MarkedExecution.MarkedExecution(() => this.animationCallback(), () => requestAnimationFrame(() => this.scheduledUpdate.trigger())));
    (0, _defineProperty2.default)(this, "animationCallback", () => {
      if (!this.moving && Math.abs(this.translationX - this.desiredTranslationX) <= 1 && Math.abs(this.translationY - this.desiredTranslationY) <= 1) {
        // Break the loop by settling the element into its final position
        this.translationX = this.desiredTranslationX;
        this.translationY = this.desiredTranslationY;
        this.setStyle();
      } else {
        const amt = this.moving ? MOVING_AMT : SNAPPING_AMT;
        this.translationX = (0, _AnimationUtils.lerp)(this.translationX, this.desiredTranslationX, amt);
        this.translationY = (0, _AnimationUtils.lerp)(this.translationY, this.desiredTranslationY, amt);
        this.setStyle();
        this.scheduledUpdate.mark();
      }

      this.props.onMove?.();
    });
    (0, _defineProperty2.default)(this, "setStyle", () => {
      if (!this.callViewWrapper.current) return; // Set the element's style directly, bypassing React for efficiency

      this.callViewWrapper.current.style.transform = `translateX(${this.translationX}px) translateY(${this.translationY}px)`;
    });
    (0, _defineProperty2.default)(this, "onResize", () => {
      this.snap(false);
    });
    (0, _defineProperty2.default)(this, "snap", function () {
      let animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const translationX = _this.desiredTranslationX;
      const translationY = _this.desiredTranslationY; // We subtract the PiP size from the window size in order to calculate
      // the position to snap to from the PiP center and not its top-left
      // corner

      const windowWidth = _UIStore.default.instance.windowWidth - (_this.callViewWrapper.current?.clientWidth || PIP_VIEW_WIDTH);
      const windowHeight = _UIStore.default.instance.windowHeight - (_this.callViewWrapper.current?.clientHeight || PIP_VIEW_HEIGHT);

      if (translationX >= windowWidth / 2 && translationY >= windowHeight / 2) {
        _this.desiredTranslationX = windowWidth - PADDING.right;
        _this.desiredTranslationY = windowHeight - PADDING.bottom;
      } else if (translationX >= windowWidth / 2 && translationY <= windowHeight / 2) {
        _this.desiredTranslationX = windowWidth - PADDING.right;
        _this.desiredTranslationY = PADDING.top;
      } else if (translationX <= windowWidth / 2 && translationY >= windowHeight / 2) {
        _this.desiredTranslationX = PADDING.left;
        _this.desiredTranslationY = windowHeight - PADDING.bottom;
      } else {
        _this.desiredTranslationX = PADDING.left;
        _this.desiredTranslationY = PADDING.top;
      }

      if (!animate) {
        _this.translationX = _this.desiredTranslationX;
        _this.translationY = _this.desiredTranslationY;
      } // We start animating here because we want the PiP to move when we're
      // resizing the window


      _this.scheduledUpdate.mark();
    });
    (0, _defineProperty2.default)(this, "onStartMoving", event => {
      event.preventDefault();
      event.stopPropagation();
      this.moving = true;
      this.initX = event.pageX - this.desiredTranslationX;
      this.initY = event.pageY - this.desiredTranslationY;
      this.scheduledUpdate.mark();
    });
    (0, _defineProperty2.default)(this, "onMoving", event => {
      if (!this.moving) return;
      event.preventDefault();
      event.stopPropagation();
      this.setTranslation(event.pageX - this.initX, event.pageY - this.initY);
    });
    (0, _defineProperty2.default)(this, "onEndMoving", () => {
      this.moving = false;
      this.snap(true);
    });
  }

  componentDidMount() {
    document.addEventListener("mousemove", this.onMoving);
    document.addEventListener("mouseup", this.onEndMoving);

    _UIStore.default.instance.on(_UIStore.UI_EVENTS.Resize, this.onResize);
  }

  componentWillUnmount() {
    document.removeEventListener("mousemove", this.onMoving);
    document.removeEventListener("mouseup", this.onEndMoving);

    _UIStore.default.instance.off(_UIStore.UI_EVENTS.Resize, this.onResize);
  }

  setTranslation(inTranslationX, inTranslationY) {
    const width = this.callViewWrapper.current?.clientWidth || PIP_VIEW_WIDTH;
    const height = this.callViewWrapper.current?.clientHeight || PIP_VIEW_HEIGHT; // Avoid overflow on the x axis

    if (inTranslationX + width >= _UIStore.default.instance.windowWidth) {
      this.desiredTranslationX = _UIStore.default.instance.windowWidth - width;
    } else if (inTranslationX <= 0) {
      this.desiredTranslationX = 0;
    } else {
      this.desiredTranslationX = inTranslationX;
    } // Avoid overflow on the y axis


    if (inTranslationY + height >= _UIStore.default.instance.windowHeight) {
      this.desiredTranslationY = _UIStore.default.instance.windowHeight - height;
    } else if (inTranslationY <= 0) {
      this.desiredTranslationY = 0;
    } else {
      this.desiredTranslationY = inTranslationY;
    }
  }

  render() {
    const style = {
      transform: `translateX(${this.translationX}px) translateY(${this.translationY}px)`
    };
    return /*#__PURE__*/_react.default.createElement("div", {
      className: this.props.className,
      style: style,
      ref: this.callViewWrapper,
      onDoubleClick: this.props.onDoubleClick
    }, this.props.children({
      onStartMoving: this.onStartMoving,
      onResize: this.onResize
    }));
  }

}

exports.default = PictureInPictureDragger;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQSVBfVklFV19XSURUSCIsIlBJUF9WSUVXX0hFSUdIVCIsIk1PVklOR19BTVQiLCJTTkFQUElOR19BTVQiLCJQQURESU5HIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiUGljdHVyZUluUGljdHVyZURyYWdnZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNyZWF0ZVJlZiIsIlVJU3RvcmUiLCJpbnN0YW5jZSIsIndpbmRvd1dpZHRoIiwid2luZG93SGVpZ2h0IiwiZGVzaXJlZFRyYW5zbGF0aW9uWCIsImRlc2lyZWRUcmFuc2xhdGlvblkiLCJNYXJrZWRFeGVjdXRpb24iLCJhbmltYXRpb25DYWxsYmFjayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNjaGVkdWxlZFVwZGF0ZSIsInRyaWdnZXIiLCJtb3ZpbmciLCJNYXRoIiwiYWJzIiwidHJhbnNsYXRpb25YIiwidHJhbnNsYXRpb25ZIiwic2V0U3R5bGUiLCJhbXQiLCJsZXJwIiwibWFyayIsInByb3BzIiwib25Nb3ZlIiwiY2FsbFZpZXdXcmFwcGVyIiwiY3VycmVudCIsInN0eWxlIiwidHJhbnNmb3JtIiwic25hcCIsImFuaW1hdGUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJpbml0WCIsInBhZ2VYIiwiaW5pdFkiLCJwYWdlWSIsInNldFRyYW5zbGF0aW9uIiwiY29tcG9uZW50RGlkTW91bnQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbk1vdmluZyIsIm9uRW5kTW92aW5nIiwib24iLCJVSV9FVkVOVFMiLCJSZXNpemUiLCJvblJlc2l6ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZiIsImluVHJhbnNsYXRpb25YIiwiaW5UcmFuc2xhdGlvblkiLCJ3aWR0aCIsImhlaWdodCIsInJlbmRlciIsImNsYXNzTmFtZSIsIm9uRG91YmxlQ2xpY2siLCJjaGlsZHJlbiIsIm9uU3RhcnRNb3ZpbmciXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy92b2lwL1BpY3R1cmVJblBpY3R1cmVEcmFnZ2VyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMjEtMjAyMiBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBVSVN0b3JlLCB7IFVJX0VWRU5UUyB9IGZyb20gJy4uLy4uLy4uL3N0b3Jlcy9VSVN0b3JlJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9BbmltYXRpb25VdGlscyc7XG5pbXBvcnQgeyBNYXJrZWRFeGVjdXRpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy9NYXJrZWRFeGVjdXRpb24nO1xuXG5jb25zdCBQSVBfVklFV19XSURUSCA9IDMzNjtcbmNvbnN0IFBJUF9WSUVXX0hFSUdIVCA9IDIzMjtcblxuY29uc3QgTU9WSU5HX0FNVCA9IDAuMjtcbmNvbnN0IFNOQVBQSU5HX0FNVCA9IDAuMTtcblxuY29uc3QgUEFERElORyA9IHtcbiAgICB0b3A6IDU4LFxuICAgIGJvdHRvbTogNTgsXG4gICAgbGVmdDogNzYsXG4gICAgcmlnaHQ6IDgsXG59O1xuXG5pbnRlcmZhY2UgSUNoaWxkcmVuT3B0aW9ucyB7XG4gICAgb25TdGFydE1vdmluZzogKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEVsZW1lbnQsIE1vdXNlRXZlbnQ+KSA9PiB2b2lkO1xuICAgIG9uUmVzaXplOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgSVByb3BzIHtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgY2hpbGRyZW46ICh7IG9uU3RhcnRNb3ZpbmcsIG9uUmVzaXplIH06IElDaGlsZHJlbk9wdGlvbnMpID0+IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBkcmFnZ2FibGU6IGJvb2xlYW47XG4gICAgb25Eb3VibGVDbGljaz86ICgpID0+IHZvaWQ7XG4gICAgb25Nb3ZlPzogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBQaWN0dXJlSW5QaWN0dXJlRHJhZ2dlciBzaG93cyBhIHNtYWxsIHZlcnNpb24gb2YgQ2FsbFZpZXcgaG92ZXJpbmcgb3ZlciB0aGUgVUkgaW4gJ3BpY3R1cmUtaW4tcGljdHVyZSdcbiAqIChQaVAgbW9kZSkuIEl0IGRpc3BsYXlzIHRoZSBjYWxsKHMpIHdoaWNoIGlzICpub3QqIGluIHRoZSByb29tIHRoZSB1c2VyIGlzIGN1cnJlbnRseSB2aWV3aW5nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWN0dXJlSW5QaWN0dXJlRHJhZ2dlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUHJvcHM+IHtcbiAgICBwcml2YXRlIGNhbGxWaWV3V3JhcHBlciA9IGNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcbiAgICBwcml2YXRlIGluaXRYID0gMDtcbiAgICBwcml2YXRlIGluaXRZID0gMDtcbiAgICBwcml2YXRlIGRlc2lyZWRUcmFuc2xhdGlvblggPSBVSVN0b3JlLmluc3RhbmNlLndpbmRvd1dpZHRoIC0gUEFERElORy5yaWdodCAtIFBJUF9WSUVXX1dJRFRIO1xuICAgIHByaXZhdGUgZGVzaXJlZFRyYW5zbGF0aW9uWSA9IFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0IC0gUEFERElORy5ib3R0b20gLSBQSVBfVklFV19IRUlHSFQ7XG4gICAgcHJpdmF0ZSB0cmFuc2xhdGlvblggPSB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblg7XG4gICAgcHJpdmF0ZSB0cmFuc2xhdGlvblkgPSB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblk7XG4gICAgcHJpdmF0ZSBtb3ZpbmcgPSBmYWxzZTtcbiAgICBwcml2YXRlIHNjaGVkdWxlZFVwZGF0ZSA9IG5ldyBNYXJrZWRFeGVjdXRpb24oXG4gICAgICAgICgpID0+IHRoaXMuYW5pbWF0aW9uQ2FsbGJhY2soKSxcbiAgICAgICAgKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuc2NoZWR1bGVkVXBkYXRlLnRyaWdnZXIoKSksXG4gICAgKTtcblxuICAgIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW92aW5nKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vbkVuZE1vdmluZyk7XG4gICAgICAgIFVJU3RvcmUuaW5zdGFuY2Uub24oVUlfRVZFTlRTLlJlc2l6ZSwgdGhpcy5vblJlc2l6ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3ZpbmcpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uRW5kTW92aW5nKTtcbiAgICAgICAgVUlTdG9yZS5pbnN0YW5jZS5vZmYoVUlfRVZFTlRTLlJlc2l6ZSwgdGhpcy5vblJlc2l6ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhbmltYXRpb25DYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMubW92aW5nICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLnRyYW5zbGF0aW9uWCAtIHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWCkgPD0gMSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy50cmFuc2xhdGlvblkgLSB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblkpIDw9IDFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBCcmVhayB0aGUgbG9vcCBieSBzZXR0bGluZyB0aGUgZWxlbWVudCBpbnRvIGl0cyBmaW5hbCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvblggPSB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblg7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFtdCA9IHRoaXMubW92aW5nID8gTU9WSU5HX0FNVCA6IFNOQVBQSU5HX0FNVDtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25YID0gbGVycCh0aGlzLnRyYW5zbGF0aW9uWCwgdGhpcy5kZXNpcmVkVHJhbnNsYXRpb25YLCBhbXQpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvblkgPSBsZXJwKHRoaXMudHJhbnNsYXRpb25ZLCB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblksIGFtdCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVkVXBkYXRlLm1hcmsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcHMub25Nb3ZlPy4oKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBzZXRTdHlsZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxWaWV3V3JhcHBlci5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIC8vIFNldCB0aGUgZWxlbWVudCdzIHN0eWxlIGRpcmVjdGx5LCBieXBhc3NpbmcgUmVhY3QgZm9yIGVmZmljaWVuY3lcbiAgICAgICAgdGhpcy5jYWxsVmlld1dyYXBwZXIuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAgICAgYHRyYW5zbGF0ZVgoJHt0aGlzLnRyYW5zbGF0aW9uWH1weCkgdHJhbnNsYXRlWSgke3RoaXMudHJhbnNsYXRpb25ZfXB4KWA7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc2V0VHJhbnNsYXRpb24oaW5UcmFuc2xhdGlvblg6IG51bWJlciwgaW5UcmFuc2xhdGlvblk6IG51bWJlcikge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FsbFZpZXdXcmFwcGVyLmN1cnJlbnQ/LmNsaWVudFdpZHRoIHx8IFBJUF9WSUVXX1dJRFRIO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNhbGxWaWV3V3JhcHBlci5jdXJyZW50Py5jbGllbnRIZWlnaHQgfHwgUElQX1ZJRVdfSEVJR0hUO1xuXG4gICAgICAgIC8vIEF2b2lkIG92ZXJmbG93IG9uIHRoZSB4IGF4aXNcbiAgICAgICAgaWYgKGluVHJhbnNsYXRpb25YICsgd2lkdGggPj0gVUlTdG9yZS5pbnN0YW5jZS53aW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXNpcmVkVHJhbnNsYXRpb25YID0gVUlTdG9yZS5pbnN0YW5jZS53aW5kb3dXaWR0aCAtIHdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGluVHJhbnNsYXRpb25YIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblggPSBpblRyYW5zbGF0aW9uWDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIG92ZXJmbG93IG9uIHRoZSB5IGF4aXNcbiAgICAgICAgaWYgKGluVHJhbnNsYXRpb25ZICsgaGVpZ2h0ID49IFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblkgPSBVSVN0b3JlLmluc3RhbmNlLndpbmRvd0hlaWdodCAtIGhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChpblRyYW5zbGF0aW9uWSA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblkgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXNpcmVkVHJhbnNsYXRpb25ZID0gaW5UcmFuc2xhdGlvblk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUmVzaXplID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnNuYXAoZmFsc2UpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIHNuYXAgPSAoYW5pbWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWCA9IHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWDtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25ZID0gdGhpcy5kZXNpcmVkVHJhbnNsYXRpb25ZO1xuICAgICAgICAvLyBXZSBzdWJ0cmFjdCB0aGUgUGlQIHNpemUgZnJvbSB0aGUgd2luZG93IHNpemUgaW4gb3JkZXIgdG8gY2FsY3VsYXRlXG4gICAgICAgIC8vIHRoZSBwb3NpdGlvbiB0byBzbmFwIHRvIGZyb20gdGhlIFBpUCBjZW50ZXIgYW5kIG5vdCBpdHMgdG9wLWxlZnRcbiAgICAgICAgLy8gY29ybmVyXG4gICAgICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gKFxuICAgICAgICAgICAgVUlTdG9yZS5pbnN0YW5jZS53aW5kb3dXaWR0aCAtXG4gICAgICAgICAgICAodGhpcy5jYWxsVmlld1dyYXBwZXIuY3VycmVudD8uY2xpZW50V2lkdGggfHwgUElQX1ZJRVdfV0lEVEgpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IChcbiAgICAgICAgICAgIFVJU3RvcmUuaW5zdGFuY2Uud2luZG93SGVpZ2h0IC1cbiAgICAgICAgICAgICh0aGlzLmNhbGxWaWV3V3JhcHBlci5jdXJyZW50Py5jbGllbnRIZWlnaHQgfHwgUElQX1ZJRVdfSEVJR0hUKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0cmFuc2xhdGlvblggPj0gd2luZG93V2lkdGggLyAyICYmIHRyYW5zbGF0aW9uWSA+PSB3aW5kb3dIZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblggPSB3aW5kb3dXaWR0aCAtIFBBRERJTkcucmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblkgPSB3aW5kb3dIZWlnaHQgLSBQQURESU5HLmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGlvblggPj0gd2luZG93V2lkdGggLyAyICYmIHRyYW5zbGF0aW9uWSA8PSB3aW5kb3dIZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblggPSB3aW5kb3dXaWR0aCAtIFBBRERJTkcucmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblkgPSBQQURESU5HLnRvcDtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGlvblggPD0gd2luZG93V2lkdGggLyAyICYmIHRyYW5zbGF0aW9uWSA+PSB3aW5kb3dIZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblggPSBQQURESU5HLmxlZnQ7XG4gICAgICAgICAgICB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblkgPSB3aW5kb3dIZWlnaHQgLSBQQURESU5HLmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWCA9IFBBRERJTkcubGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWSA9IFBBRERJTkcudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IHRoaXMuZGVzaXJlZFRyYW5zbGF0aW9uWDtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25ZID0gdGhpcy5kZXNpcmVkVHJhbnNsYXRpb25ZO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc3RhcnQgYW5pbWF0aW5nIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRoZSBQaVAgdG8gbW92ZSB3aGVuIHdlJ3JlXG4gICAgICAgIC8vIHJlc2l6aW5nIHRoZSB3aW5kb3dcbiAgICAgICAgdGhpcy5zY2hlZHVsZWRVcGRhdGUubWFyaygpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uU3RhcnRNb3ZpbmcgPSAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQgfCBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbml0WCA9IGV2ZW50LnBhZ2VYIC0gdGhpcy5kZXNpcmVkVHJhbnNsYXRpb25YO1xuICAgICAgICB0aGlzLmluaXRZID0gZXZlbnQucGFnZVkgLSB0aGlzLmRlc2lyZWRUcmFuc2xhdGlvblk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkVXBkYXRlLm1hcmsoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBvbk1vdmluZyA9IChldmVudDogUmVhY3QuTW91c2VFdmVudCB8IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdmluZykgcmV0dXJuO1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuc2V0VHJhbnNsYXRpb24oZXZlbnQucGFnZVggLSB0aGlzLmluaXRYLCBldmVudC5wYWdlWSAtIHRoaXMuaW5pdFkpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIG9uRW5kTW92aW5nID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNuYXAodHJ1ZSk7XG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke3RoaXMudHJhbnNsYXRpb25YfXB4KSB0cmFuc2xhdGVZKCR7dGhpcy50cmFuc2xhdGlvbll9cHgpYCxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgICAgIHJlZj17dGhpcy5jYWxsVmlld1dyYXBwZXJ9XG4gICAgICAgICAgICAgICAgb25Eb3VibGVDbGljaz17dGhpcy5wcm9wcy5vbkRvdWJsZUNsaWNrfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsgdGhpcy5wcm9wcy5jaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICAgIG9uU3RhcnRNb3Zpbmc6IHRoaXMub25TdGFydE1vdmluZyxcbiAgICAgICAgICAgICAgICAgICAgb25SZXNpemU6IHRoaXMub25SZXNpemUsXG4gICAgICAgICAgICAgICAgfSkgfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFFQTs7QUFDQTs7QUFDQTs7Ozs7O0FBcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBLE1BQU1BLGNBQWMsR0FBRyxHQUF2QjtBQUNBLE1BQU1DLGVBQWUsR0FBRyxHQUF4QjtBQUVBLE1BQU1DLFVBQVUsR0FBRyxHQUFuQjtBQUNBLE1BQU1DLFlBQVksR0FBRyxHQUFyQjtBQUVBLE1BQU1DLE9BQU8sR0FBRztFQUNaQyxHQUFHLEVBQUUsRUFETztFQUVaQyxNQUFNLEVBQUUsRUFGSTtFQUdaQyxJQUFJLEVBQUUsRUFITTtFQUlaQyxLQUFLLEVBQUU7QUFKSyxDQUFoQjs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDZSxNQUFNQyx1QkFBTixTQUFzQ0MsY0FBQSxDQUFNQyxTQUE1QyxDQUE4RDtFQUFBO0lBQUE7O0lBQUE7SUFBQTtJQUFBLG9FQUMvQyxJQUFBQyxnQkFBQSxHQUQrQztJQUFBLDZDQUV6RCxDQUZ5RDtJQUFBLDZDQUd6RCxDQUh5RDtJQUFBLDJEQUkzQ0MsZ0JBQUEsQ0FBUUMsUUFBUixDQUFpQkMsV0FBakIsR0FBK0JYLE9BQU8sQ0FBQ0ksS0FBdkMsR0FBK0NSLGNBSko7SUFBQSwyREFLM0NhLGdCQUFBLENBQVFDLFFBQVIsQ0FBaUJFLFlBQWpCLEdBQWdDWixPQUFPLENBQUNFLE1BQXhDLEdBQWlETCxlQUxOO0lBQUEsb0RBTWxELEtBQUtnQixtQkFONkM7SUFBQSxvREFPbEQsS0FBS0MsbUJBUDZDO0lBQUEsOENBUXhELEtBUndEO0lBQUEsdURBUy9DLElBQUlDLGdDQUFKLENB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