"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initSentry = initSentry;
exports.sendSentryReport = sendSentryReport;
exports.setSentryUser = setSentryUser;

var Sentry = _interopRequireWildcard(require("@sentry/browser"));

var _SdkConfig = _interopRequireDefault(require("./SdkConfig"));

var _MatrixClientPeg = require("./MatrixClientPeg");

var _SettingsStore = _interopRequireDefault(require("./settings/SettingsStore"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* eslint-enable camelcase */
async function getStorageContext() {
  const result = {}; // add storage persistence/quota information

  if (navigator.storage && navigator.storage.persisted) {
    try {
      result["storageManager_persisted"] = String(await navigator.storage.persisted());
    } catch (e) {}
  } else if (document.hasStorageAccess) {
    // Safari
    try {
      result["storageManager_persisted"] = String(await document.hasStorageAccess());
    } catch (e) {}
  }

  if (navigator.storage && navigator.storage.estimate) {
    try {
      const estimate = await navigator.storage.estimate();
      result["storageManager_quota"] = String(estimate.quota);
      result["storageManager_usage"] = String(estimate.usage);

      if (estimate.usageDetails) {
        const usageDetails = [];
        Object.keys(estimate.usageDetails).forEach(k => {
          usageDetails.push(`${k}: ${String(estimate.usageDetails[k])}`);
        });
        result[`storageManager_usage`] = usageDetails.join(", ");
      }
    } catch (e) {}
  }

  return result;
}

function getUserContext(client) {
  return {
    "username": client.credentials.userId,
    "enabled_labs": getEnabledLabs(),
    "low_bandwidth": _SettingsStore.default.getValue("lowBandwidth") ? "enabled" : "disabled"
  };
}

function getEnabledLabs() {
  const enabledLabs = _SettingsStore.default.getFeatureSettingNames().filter(f => _SettingsStore.default.getValue(f));

  if (enabledLabs.length) {
    return enabledLabs.join(", ");
  }

  return "";
}

async function getCryptoContext(client) {
  if (!client.isCryptoEnabled()) {
    return {};
  }

  const keys = [`ed25519:${client.getDeviceEd25519Key()}`];

  if (client.getDeviceCurve25519Key) {
    keys.push(`curve25519:${client.getDeviceCurve25519Key()}`);
  }

  const crossSigning = client.crypto.crossSigningInfo;
  const secretStorage = client.crypto.secretStorage;
  const pkCache = client.getCrossSigningCacheCallbacks();
  const sessionBackupKeyFromCache = await client.crypto.getSessionBackupPrivateKey();
  return {
    "device_keys": keys.join(', '),
    "cross_signing_ready": String(await client.isCrossSigningReady()),
    "cross_signing_supported_by_hs": String(await client.doesServerSupportUnstableFeature("org.matrix.e2e_cross_signing")),
    "cross_signing_key": crossSigning.getId(),
    "cross_signing_privkey_in_secret_storage": String(!!(await crossSigning.isStoredInSecretStorage(secretStorage))),
    "cross_signing_master_privkey_cached": String(!!(pkCache && (await pkCache.getCrossSigningKeyCache("master")))),
    "cross_signing_user_signing_privkey_cached": String(!!(pkCache && (await pkCache.getCrossSigningKeyCache("user_signing")))),
    "secret_storage_ready": String(await client.isSecretStorageReady()),
    "secret_storage_key_in_account": String(!!(await secretStorage.hasKey())),
    "session_backup_key_in_secret_storage": String(!!(await client.isKeyBackupKeyStored())),
    "session_backup_key_cached": String(!!sessionBackupKeyFromCache),
    "session_backup_key_well_formed": String(sessionBackupKeyFromCache instanceof Uint8Array)
  };
}

function getDeviceContext(client) {
  const result = {
    "device_id": client?.deviceId,
    "mx_local_settings": localStorage.getItem('mx_local_settings')
  };

  if (window.Modernizr) {
    const missingFeatures = Object.keys(window.Modernizr).filter(key => window.Modernizr[key] === false);

    if (missingFeatures.length > 0) {
      result["modernizr_missing_features"] = missingFeatures.join(", ");
    }
  }

  return result;
}

async function getContexts() {
  const client = _MatrixClientPeg.MatrixClientPeg.get();

  return {
    "user": getUserContext(client),
    "crypto": await getCryptoContext(client),
    "device": getDeviceContext(client),
    "storage": await getStorageContext()
  };
}

async function sendSentryReport(userText, issueUrl, error) {
  const sentryConfig = _SdkConfig.default.getObject("sentry");

  if (!sentryConfig) return;
  const captureContext = {
    "contexts": await getContexts(),
    "extra": {
      "user_text": userText,
      "issue_url": issueUrl
    }
  }; // If there's no error and no issueUrl, the report will just produce non-grouped noise in Sentry, so don't
  // upload it

  if (error) {
    Sentry.captureException(error, captureContext);
  } else if (issueUrl) {
    Sentry.captureMessage(`Issue: ${issueUrl}`, captureContext);
  }
}

function setSentryUser(mxid) {
  if (!_SdkConfig.default.get().sentry || !_SettingsStore.default.getValue("automaticErrorReporting")) return;
  Sentry.setUser({
    username: mxid
  });
}

async function initSentry(sentryConfig) {
  if (!sentryConfig) return; // Only enable Integrations.GlobalHandlers, which hooks uncaught exceptions, if automaticErrorReporting is true

  const integrations = [new Sentry.Integrations.InboundFilters(), new Sentry.Integrations.FunctionToString(), new Sentry.Integrations.Breadcrumbs(), new Sentry.Integrations.UserAgent(), new Sentry.Integrations.Dedupe()];

  if (_SettingsStore.default.getValue("automaticErrorReporting")) {
    integrations.push(new Sentry.Integrations.GlobalHandlers({
      onerror: false,
      onunhandledrejection: true
    }));
    integrations.push(new Sentry.Integrations.TryCatch());
  }

  Sentry.init({
    dsn: sentryConfig.dsn,
    release: process.env.VERSION,
    environment: sentryConfig.environment,
    defaultIntegrations: false,
    autoSessionTracking: false,
    integrations,
    // Set to 1.0 which is reasonable if we're only submitting Rageshakes; will need to be set < 1.0
    // if we collect more frequently.
    tracesSampleRate: 1.0
  });
}

window.mxSendSentryReport = sendSentryReport;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRTdG9yYWdlQ29udGV4dCIsInJlc3VsdCIsIm5hdmlnYXRvciIsInN0b3JhZ2UiLCJwZXJzaXN0ZWQiLCJTdHJpbmciLCJlIiwiZG9jdW1lbnQiLCJoYXNTdG9yYWdlQWNjZXNzIiwiZXN0aW1hdGUiLCJxdW90YSIsInVzYWdlIiwidXNhZ2VEZXRhaWxzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrIiwicHVzaCIsImpvaW4iLCJnZXRVc2VyQ29udGV4dCIsImNsaWVudCIsImNyZWRlbnRpYWxzIiwidXNlcklkIiwiZ2V0RW5hYmxlZExhYnMiLCJTZXR0aW5nc1N0b3JlIiwiZ2V0VmFsdWUiLCJlbmFibGVkTGFicyIsImdldEZlYXR1cmVTZXR0aW5nTmFtZXMiLCJmaWx0ZXIiLCJmIiwibGVuZ3RoIiwiZ2V0Q3J5cHRvQ29udGV4dCIsImlzQ3J5cHRvRW5hYmxlZCIsImdldERldmljZUVkMjU1MTlLZXkiLCJnZXREZXZpY2VDdXJ2ZTI1NTE5S2V5IiwiY3Jvc3NTaWduaW5nIiwiY3J5cHRvIiwiY3Jvc3NTaWduaW5nSW5mbyIsInNlY3JldFN0b3JhZ2UiLCJwa0NhY2hlIiwiZ2V0Q3Jvc3NTaWduaW5nQ2FjaGVDYWxsYmFja3MiLCJzZXNzaW9uQmFja3VwS2V5RnJvbUNhY2hlIiwiZ2V0U2Vzc2lvbkJhY2t1cFByaXZhdGVLZXkiLCJpc0Nyb3NzU2lnbmluZ1JlYWR5IiwiZG9lc1NlcnZlclN1cHBvcnRVbnN0YWJsZUZlYXR1cmUiLCJnZXRJZCIsImlzU3RvcmVkSW5TZWNyZXRTdG9yYWdlIiwiZ2V0Q3Jvc3NTaWduaW5nS2V5Q2FjaGUiLCJpc1NlY3JldFN0b3JhZ2VSZWFkeSIsImhhc0tleSIsImlzS2V5QmFja3VwS2V5U3RvcmVkIiwiVWludDhBcnJheSIsImdldERldmljZUNvbnRleHQiLCJkZXZpY2VJZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ3aW5kb3ciLCJNb2Rlcm5penIiLCJtaXNzaW5nRmVhdHVyZXMiLCJrZXkiLCJnZXRDb250ZXh0cyIsIk1hdHJpeENsaWVudFBlZyIsImdldCIsInNlbmRTZW50cnlSZXBvcnQiLCJ1c2VyVGV4dCIsImlzc3VlVXJsIiwiZXJyb3IiLCJzZW50cnlDb25maWciLCJTZGtDb25maWciLCJnZXRPYmplY3QiLCJjYXB0dXJlQ29udGV4dCIsIlNlbnRyeSIsImNhcHR1cmVFeGNlcHRpb24iLCJjYXB0dXJlTWVzc2FnZSIsInNldFNlbnRyeVVzZXIiLCJteGlkIiwic2VudHJ5Iiwic2V0VXNlciIsInVzZXJuYW1lIiwiaW5pdFNlbnRyeSIsImludGVncmF0aW9ucyIsIkludGVncmF0aW9ucyIsIkluYm91bmRGaWx0ZXJzIiwiRnVuY3Rpb25Ub1N0cmluZyIsIkJyZWFkY3J1bWJzIiwiVXNlckFnZW50IiwiRGVkdXBlIiwiR2xvYmFsSGFuZGxlcnMiLCJvbmVycm9yIiwib251bmhhbmRsZWRyZWplY3Rpb24iLCJUcnlDYXRjaCIsImluaXQiLCJkc24iLCJyZWxlYXNlIiwicHJvY2VzcyIsImVudiIsIlZFUlNJT04iLCJlbnZpcm9ubWVudCIsImRlZmF1bHRJbnRlZ3JhdGlvbnMiLCJhdXRvU2Vzc2lvblRyYWNraW5nIiwidHJhY2VzU2FtcGxlUmF0ZSIsIm14U2VuZFNlbnRyeVJlcG9ydCJdLCJzb3VyY2VzIjpbIi4uL3NyYy9zZW50cnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0ICogYXMgU2VudHJ5IGZyb20gXCJAc2VudHJ5L2Jyb3dzZXJcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudCB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jbGllbnRcIjtcblxuaW1wb3J0IFNka0NvbmZpZyBmcm9tIFwiLi9TZGtDb25maWdcIjtcbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gXCIuL01hdHJpeENsaWVudFBlZ1wiO1xuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZVwiO1xuaW1wb3J0IHsgSUNvbmZpZ09wdGlvbnMgfSBmcm9tIFwiLi9JQ29uZmlnT3B0aW9uc1wiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxudHlwZSBTdG9yYWdlQ29udGV4dCA9IHtcbiAgICBzdG9yYWdlTWFuYWdlcl9wZXJzaXN0ZWQ/OiBzdHJpbmc7XG4gICAgc3RvcmFnZU1hbmFnZXJfcXVvdGE/OiBzdHJpbmc7XG4gICAgc3RvcmFnZU1hbmFnZXJfdXNhZ2U/OiBzdHJpbmc7XG4gICAgc3RvcmFnZU1hbmFnZXJfdXNhZ2VEZXRhaWxzPzogc3RyaW5nO1xufTtcblxudHlwZSBVc2VyQ29udGV4dCA9IHtcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIGVuYWJsZWRfbGFiczogc3RyaW5nO1xuICAgIGxvd19iYW5kd2lkdGg6IHN0cmluZztcbn07XG5cbnR5cGUgQ3J5cHRvQ29udGV4dCA9IHtcbiAgICBkZXZpY2Vfa2V5cz86IHN0cmluZztcbiAgICBjcm9zc19zaWduaW5nX3JlYWR5Pzogc3RyaW5nO1xuICAgIGNyb3NzX3NpZ25pbmdfc3VwcG9ydGVkX2J5X2hzPzogc3RyaW5nO1xuICAgIGNyb3NzX3NpZ25pbmdfa2V5Pzogc3RyaW5nO1xuICAgIGNyb3NzX3NpZ25pbmdfcHJpdmtleV9pbl9zZWNyZXRfc3RvcmFnZT86IHN0cmluZztcbiAgICBjcm9zc19zaWduaW5nX21hc3Rlcl9wcml2a2V5X2NhY2hlZD86IHN0cmluZztcbiAgICBjcm9zc19zaWduaW5nX3VzZXJfc2lnbmluZ19wcml2a2V5X2NhY2hlZD86IHN0cmluZztcbiAgICBzZWNyZXRfc3RvcmFnZV9yZWFkeT86IHN0cmluZztcbiAgICBzZWNyZXRfc3RvcmFnZV9rZXlfaW5fYWNjb3VudD86IHN0cmluZztcbiAgICBzZXNzaW9uX2JhY2t1cF9rZXlfaW5fc2VjcmV0X3N0b3JhZ2U/OiBzdHJpbmc7XG4gICAgc2Vzc2lvbl9iYWNrdXBfa2V5X2NhY2hlZD86IHN0cmluZztcbiAgICBzZXNzaW9uX2JhY2t1cF9rZXlfd2VsbF9mb3JtZWQ/OiBzdHJpbmc7XG59O1xuXG50eXBlIERldmljZUNvbnRleHQgPSB7XG4gICAgZGV2aWNlX2lkOiBzdHJpbmc7XG4gICAgbXhfbG9jYWxfc2V0dGluZ3M6IHN0cmluZztcbiAgICBtb2Rlcm5penJfbWlzc2luZ19mZWF0dXJlcz86IHN0cmluZztcbn07XG5cbnR5cGUgQ29udGV4dHMgPSB7XG4gICAgdXNlcjogVXNlckNvbnRleHQ7XG4gICAgY3J5cHRvOiBDcnlwdG9Db250ZXh0O1xuICAgIGRldmljZTogRGV2aWNlQ29udGV4dDtcbiAgICBzdG9yYWdlOiBTdG9yYWdlQ29udGV4dDtcbn07XG5cbi8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2VDb250ZXh0KCk6IFByb21pc2U8U3RvcmFnZUNvbnRleHQ+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIC8vIGFkZCBzdG9yYWdlIHBlcnNpc3RlbmNlL3F1b3RhIGluZm9ybWF0aW9uXG4gICAgaWYgKG5hdmlnYXRvci5zdG9yYWdlICYmIG5hdmlnYXRvci5zdG9yYWdlLnBlcnNpc3RlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0W1wic3RvcmFnZU1hbmFnZXJfcGVyc2lzdGVkXCJdID0gU3RyaW5nKGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLnBlcnNpc3RlZCgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lmhhc1N0b3JhZ2VBY2Nlc3MpIHsgLy8gU2FmYXJpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHRbXCJzdG9yYWdlTWFuYWdlcl9wZXJzaXN0ZWRcIl0gPSBTdHJpbmcoYXdhaXQgZG9jdW1lbnQuaGFzU3RvcmFnZUFjY2VzcygpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgaWYgKG5hdmlnYXRvci5zdG9yYWdlICYmIG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmVzdGltYXRlKCk7XG4gICAgICAgICAgICByZXN1bHRbXCJzdG9yYWdlTWFuYWdlcl9xdW90YVwiXSA9IFN0cmluZyhlc3RpbWF0ZS5xdW90YSk7XG4gICAgICAgICAgICByZXN1bHRbXCJzdG9yYWdlTWFuYWdlcl91c2FnZVwiXSA9IFN0cmluZyhlc3RpbWF0ZS51c2FnZSk7XG4gICAgICAgICAgICBpZiAoZXN0aW1hdGUudXNhZ2VEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNhZ2VEZXRhaWxzID0gW107XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXN0aW1hdGUudXNhZ2VEZXRhaWxzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1c2FnZURldGFpbHMucHVzaChgJHtrfTogJHtTdHJpbmcoZXN0aW1hdGUudXNhZ2VEZXRhaWxzW2tdKX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHRbYHN0b3JhZ2VNYW5hZ2VyX3VzYWdlYF0gPSB1c2FnZURldGFpbHMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJDb250ZXh0KGNsaWVudDogTWF0cml4Q2xpZW50KTogVXNlckNvbnRleHQge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwidXNlcm5hbWVcIjogY2xpZW50LmNyZWRlbnRpYWxzLnVzZXJJZCxcbiAgICAgICAgXCJlbmFibGVkX2xhYnNcIjogZ2V0RW5hYmxlZExhYnMoKSxcbiAgICAgICAgXCJsb3dfYmFuZHdpZHRoXCI6IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJsb3dCYW5kd2lkdGhcIikgPyBcImVuYWJsZWRcIiA6IFwiZGlzYWJsZWRcIixcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbmFibGVkTGFicygpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVuYWJsZWRMYWJzID0gU2V0dGluZ3NTdG9yZS5nZXRGZWF0dXJlU2V0dGluZ05hbWVzKCkuZmlsdGVyKGYgPT4gU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShmKSk7XG4gICAgaWYgKGVuYWJsZWRMYWJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZW5hYmxlZExhYnMuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3J5cHRvQ29udGV4dChjbGllbnQ6IE1hdHJpeENsaWVudCk6IFByb21pc2U8Q3J5cHRvQ29udGV4dD4ge1xuICAgIGlmICghY2xpZW50LmlzQ3J5cHRvRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IFtgZWQyNTUxOToke2NsaWVudC5nZXREZXZpY2VFZDI1NTE5S2V5KCl9YF07XG4gICAgaWYgKGNsaWVudC5nZXREZXZpY2VDdXJ2ZTI1NTE5S2V5KSB7XG4gICAgICAgIGtleXMucHVzaChgY3VydmUyNTUxOToke2NsaWVudC5nZXREZXZpY2VDdXJ2ZTI1NTE5S2V5KCl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNyb3NzU2lnbmluZyA9IGNsaWVudC5jcnlwdG8uY3Jvc3NTaWduaW5nSW5mbztcbiAgICBjb25zdCBzZWNyZXRTdG9yYWdlID0gY2xpZW50LmNyeXB0by5zZWNyZXRTdG9yYWdlO1xuICAgIGNvbnN0IHBrQ2FjaGUgPSBjbGllbnQuZ2V0Q3Jvc3NTaWduaW5nQ2FjaGVDYWxsYmFja3MoKTtcbiAgICBjb25zdCBzZXNzaW9uQmFja3VwS2V5RnJvbUNhY2hlID0gYXdhaXQgY2xpZW50LmNyeXB0by5nZXRTZXNzaW9uQmFja3VwUHJpdmF0ZUtleSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJkZXZpY2Vfa2V5c1wiOiBrZXlzLmpvaW4oJywgJyksXG4gICAgICAgIFwiY3Jvc3Nfc2lnbmluZ19yZWFkeVwiOiBTdHJpbmcoYXdhaXQgY2xpZW50LmlzQ3Jvc3NTaWduaW5nUmVhZHkoKSksXG4gICAgICAgIFwiY3Jvc3Nfc2lnbmluZ19zdXBwb3J0ZWRfYnlfaHNcIjpcbiAgICAgICAgICAgIFN0cmluZyhhd2FpdCBjbGllbnQuZG9lc1NlcnZlclN1cHBvcnRVbnN0YWJsZUZlYXR1cmUoXCJvcmcubWF0cml4LmUyZV9jcm9zc19zaWduaW5nXCIpKSxcbiAgICAgICAgXCJjcm9zc19zaWduaW5nX2tleVwiOiBjcm9zc1NpZ25pbmcuZ2V0SWQoKSxcbiAgICAgICAgXCJjcm9zc19zaWduaW5nX3ByaXZrZXlfaW5fc2VjcmV0X3N0b3JhZ2VcIjogU3RyaW5nKFxuICAgICAgICAgICAgISEoYXdhaXQgY3Jvc3NTaWduaW5nLmlzU3RvcmVkSW5TZWNyZXRTdG9yYWdlKHNlY3JldFN0b3JhZ2UpKSksXG4gICAgICAgIFwiY3Jvc3Nfc2lnbmluZ19tYXN0ZXJfcHJpdmtleV9jYWNoZWRcIjogU3RyaW5nKFxuICAgICAgICAgICAgISEocGtDYWNoZSAmJiAoYXdhaXQgcGtDYWNoZS5nZXRDcm9zc1NpZ25pbmdLZXlDYWNoZShcIm1hc3RlclwiKSkpKSxcbiAgICAgICAgXCJjcm9zc19zaWduaW5nX3VzZXJfc2lnbmluZ19wcml2a2V5X2NhY2hlZFwiOiBTdHJpbmcoXG4gICAgICAgICAgICAhIShwa0NhY2hlICYmIChhd2FpdCBwa0NhY2hlLmdldENyb3NzU2lnbmluZ0tleUNhY2hlKFwidXNlcl9zaWduaW5nXCIpKSkpLFxuICAgICAgICBcInNlY3JldF9zdG9yYWdlX3JlYWR5XCI6IFN0cmluZyhhd2FpdCBjbGllbnQuaXNTZWNyZXRTdG9yYWdlUmVhZHkoKSksXG4gICAgICAgIFwic2VjcmV0X3N0b3JhZ2Vfa2V5X2luX2FjY291bnRcIjogU3RyaW5nKCEhKGF3YWl0IHNlY3JldFN0b3JhZ2UuaGFzS2V5KCkpKSxcbiAgICAgICAgXCJzZXNzaW9uX2JhY2t1cF9rZXlfaW5fc2VjcmV0X3N0b3JhZ2VcIjogU3RyaW5nKCEhKGF3YWl0IGNsaWVudC5pc0tleUJhY2t1cEtleVN0b3JlZCgpKSksXG4gICAgICAgIFwic2Vzc2lvbl9iYWNrdXBfa2V5X2NhY2hlZFwiOiBTdHJpbmcoISFzZXNzaW9uQmFja3VwS2V5RnJvbUNhY2hlKSxcbiAgICAgICAgXCJzZXNzaW9uX2JhY2t1cF9rZXlfd2VsbF9mb3JtZWRcIjogU3RyaW5nKHNlc3Npb25CYWNrdXBLZXlGcm9tQ2FjaGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXREZXZpY2VDb250ZXh0KGNsaWVudDogTWF0cml4Q2xpZW50KTogRGV2aWNlQ29udGV4dCB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBcImRldmljZV9pZFwiOiBjbGllbnQ/LmRldmljZUlkLFxuICAgICAgICBcIm14X2xvY2FsX3NldHRpbmdzXCI6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdteF9sb2NhbF9zZXR0aW5ncycpLFxuICAgIH07XG5cbiAgICBpZiAod2luZG93Lk1vZGVybml6cikge1xuICAgICAgICBjb25zdCBtaXNzaW5nRmVhdHVyZXMgPSBPYmplY3Qua2V5cyh3aW5kb3cuTW9kZXJuaXpyKS5maWx0ZXIoa2V5ID0+IHdpbmRvdy5Nb2Rlcm5penJba2V5XSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAobWlzc2luZ0ZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdFtcIm1vZGVybml6cl9taXNzaW5nX2ZlYXR1cmVzXCJdID0gbWlzc2luZ0ZlYXR1cmVzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbnRleHRzKCk6IFByb21pc2U8Q29udGV4dHM+IHtcbiAgICBjb25zdCBjbGllbnQgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJ1c2VyXCI6IGdldFVzZXJDb250ZXh0KGNsaWVudCksXG4gICAgICAgIFwiY3J5cHRvXCI6IGF3YWl0IGdldENyeXB0b0NvbnRleHQoY2xpZW50KSxcbiAgICAgICAgXCJkZXZpY2VcIjogZ2V0RGV2aWNlQ29udGV4dChjbGllbnQpLFxuICAgICAgICBcInN0b3JhZ2VcIjogYXdhaXQgZ2V0U3RvcmFnZUNvbnRleHQoKSxcbiAgICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFNlbnRyeVJlcG9ydCh1c2VyVGV4dDogc3RyaW5nLCBpc3N1ZVVybDogc3RyaW5nLCBlcnJvcjogRXJyb3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzZW50cnlDb25maWcgPSBTZGtDb25maWcuZ2V0T2JqZWN0KFwic2VudHJ5XCIpO1xuICAgIGlmICghc2VudHJ5Q29uZmlnKSByZXR1cm47XG5cbiAgICBjb25zdCBjYXB0dXJlQ29udGV4dCA9IHtcbiAgICAgICAgXCJjb250ZXh0c1wiOiBhd2FpdCBnZXRDb250ZXh0cygpLFxuICAgICAgICBcImV4dHJhXCI6IHtcbiAgICAgICAgICAgIFwidXNlcl90ZXh0XCI6IHVzZXJUZXh0LFxuICAgICAgICAgICAgXCJpc3N1ZV91cmxcIjogaXNzdWVVcmwsXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZXJyb3IgYW5kIG5vIGlzc3VlVXJsLCB0aGUgcmVwb3J0IHdpbGwganVzdCBwcm9kdWNlIG5vbi1ncm91cGVkIG5vaXNlIGluIFNlbnRyeSwgc28gZG9uJ3RcbiAgICAvLyB1cGxvYWQgaXRcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oZXJyb3IsIGNhcHR1cmVDb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGlzc3VlVXJsKSB7XG4gICAgICAgIFNlbnRyeS5jYXB0dXJlTWVzc2FnZShgSXNzdWU6ICR7aXNzdWVVcmx9YCwgY2FwdHVyZUNvbnRleHQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNlbnRyeVVzZXIobXhpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFTZGtDb25maWcuZ2V0KCkuc2VudHJ5IHx8ICFTZXR0aW5nc1N0b3JlLmdldFZhbHVlKFwiYXV0b21hdGljRXJyb3JSZXBvcnRpbmdcIikpIHJldHVybjtcbiAgICBTZW50cnkuc2V0VXNlcih7IHVzZXJuYW1lOiBteGlkIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdFNlbnRyeShzZW50cnlDb25maWc6IElDb25maWdPcHRpb25zW1wic2VudHJ5XCJdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFzZW50cnlDb25maWcpIHJldHVybjtcbiAgICAvLyBPbmx5IGVuYWJsZSBJbnRlZ3JhdGlvbnMuR2xvYmFsSGFuZGxlcnMsIHdoaWNoIGhvb2tzIHVuY2F1Z2h0IGV4Y2VwdGlvbnMsIGlmIGF1dG9tYXRpY0Vycm9yUmVwb3J0aW5nIGlzIHRydWVcbiAgICBjb25zdCBpbnRlZ3JhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBTZW50cnkuSW50ZWdyYXRpb25zLkluYm91bmRGaWx0ZXJzKCksXG4gICAgICAgIG5ldyBTZW50cnkuSW50ZWdyYXRpb25zLkZ1bmN0aW9uVG9TdHJpbmcoKSxcbiAgICAgICAgbmV3IFNlbnRyeS5JbnRlZ3JhdGlvbnMuQnJlYWRjcnVtYnMoKSxcbiAgICAgICAgbmV3IFNlbnRyeS5JbnRlZ3JhdGlvbnMuVXNlckFnZW50KCksXG4gICAgICAgIG5ldyBTZW50cnkuSW50ZWdyYXRpb25zLkRlZHVwZSgpLFxuICAgIF07XG5cbiAgICBpZiAoU2V0dGluZ3NTdG9yZS5nZXRWYWx1ZShcImF1dG9tYXRpY0Vycm9yUmVwb3J0aW5nXCIpKSB7XG4gICAgICAgIGludGVncmF0aW9ucy5wdXNoKG5ldyBTZW50cnkuSW50ZWdyYXRpb25zLkdsb2JhbEhhbmRsZXJzKFxuICAgICAgICAgICAgeyBvbmVycm9yOiBmYWxzZSwgb251bmhhbmRsZWRyZWplY3Rpb246IHRydWUgfSkpO1xuICAgICAgICBpbnRlZ3JhdGlvbnMucHVzaChuZXcgU2VudHJ5LkludGVncmF0aW9ucy5UcnlDYXRjaCgpKTtcbiAgICB9XG5cbiAgICBTZW50cnkuaW5pdCh7XG4gICAgICAgIGRzbjogc2VudHJ5Q29uZmlnLmRzbixcbiAgICAgICAgcmVsZWFzZTogcHJvY2Vzcy5lbnYuVkVSU0lPTixcbiAgICAgICAgZW52aXJvbm1lbnQ6IHNlbnRyeUNvbmZpZy5lbnZpcm9ubWVudCxcbiAgICAgICAgZGVmYXVsdEludGVncmF0aW9uczogZmFsc2UsXG4gICAgICAgIGF1dG9TZXNzaW9uVHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICBpbnRlZ3JhdGlvbnMsXG4gICAgICAgIC8vIFNldCB0byAxLjAgd2hpY2ggaXMgcmVhc29uYWJsZSBpZiB3ZSdyZSBvbmx5IHN1Ym1pdHRpbmcgUmFnZXNoYWtlczsgd2lsbCBuZWVkIHRvIGJlIHNldCA8IDEuMFxuICAgICAgICAvLyBpZiB3ZSBjb2xsZWN0IG1vcmUgZnJlcXVlbnRseS5cbiAgICAgICAgdHJhY2VzU2FtcGxlUmF0ZTogMS4wLFxuICAgIH0pO1xufVxuXG53aW5kb3cubXhTZW5kU2VudHJ5UmVwb3J0ID0gc2VuZFNlbnRyeVJlcG9ydDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBR0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcURBO0FBRUEsZUFBZUEsaUJBQWYsR0FBNEQ7RUFDeEQsTUFBTUMsTUFBTSxHQUFHLEVBQWYsQ0FEd0QsQ0FHeEQ7O0VBQ0EsSUFBSUMsU0FBUyxDQUFDQyxPQUFWLElBQXFCRCxTQUFTLENBQUNDLE9BQVYsQ0FBa0JDLFNBQTNDLEVBQXNEO0lBQ2xELElBQUk7TUFDQUgsTUFBTSxDQUFDLDBCQUFELENBQU4sR0FBcUNJLE1BQU0sQ0FBQyxNQUFNSCxTQUFTLENBQUNDLE9BQVYsQ0FBa0JDLFNBQWxCLEVBQVAsQ0FBM0M7SUFDSCxDQUZELENBRUUsT0FBT0UsQ0FBUCxFQUFVLENBQUU7RUFDakIsQ0FKRCxNQUlPLElBQUlDLFFBQVEsQ0FBQ0MsZ0JBQWIsRUFBK0I7SUFBRTtJQUNwQyxJQUFJO01BQ0FQLE1BQU0sQ0FBQywwQkFBRCxDQUFOLEdBQXFDSSxNQUFNLENBQUMsTUFBTUUsUUFBUSxDQUFDQyxnQkFBVCxFQUFQLENBQTNDO0lBQ0gsQ0FGRCxDQUVFLE9BQU9GLENBQVAsRUFBVSxDQUFFO0VBQ2pCOztFQUNELElBQUlKLFNBQVMsQ0FBQ0MsT0FBVixJQUFx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