"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSmoothAnimation = useSmoothAnimation;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _logger = require("matrix-js-sdk/src/logger");

var _react = require("react");

var _SettingsStore = _interopRequireDefault(require("../settings/SettingsStore"));

var _useAnimation = require("./useAnimation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const debuglog = function () {
  if (_SettingsStore.default.getValue("debug_animation")) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _logger.logger.log.call(console, "Animation debuglog:", ...args);
  }
};
/**
 * Utility function to smoothly animate to a certain target value
 * @param initialValue Initial value to be used as initial starting point
 * @param targetValue Desired value to animate to (can be changed repeatedly to whatever is current at that time)
 * @param duration Duration that each animation should take, specify 0 to skip animating
 */


function useSmoothAnimation(initialValue, targetValue, duration) {
  const state = (0, _react.useRef)({
    timestamp: null,
    value: initialValue
  });
  const [currentValue, setCurrentValue] = (0, _react.useState)(initialValue);
  const [currentStepSize, setCurrentStepSize] = (0, _react.useState)(0);
  (0, _react.useEffect)(() => {
    const totalDelta = targetValue - state.current.value;
    setCurrentStepSize(totalDelta / duration);
    state.current = _objectSpread(_objectSpread({}, state.current), {}, {
      timestamp: null
    });
  }, [duration, targetValue]);
  const update = (0, _react.useCallback)(timestamp => {
    if (!state.current.timestamp) {
      state.current = _objectSpread(_objectSpread({}, state.current), {}, {
        timestamp
      });
      return true;
    }

    if (Math.abs(currentStepSize) < Number.EPSILON) {
      return false;
    }

    const timeDelta = timestamp - state.current.timestamp;
    const valueDelta = currentStepSize * timeDelta;
    const maxValueDelta = targetValue - state.current.value;
    const clampedValueDelta = Math.sign(valueDelta) * Math.min(Math.abs(maxValueDelta), Math.abs(valueDelta));
    const value = state.current.value + clampedValueDelta;
    debuglog(`Animating to ${targetValue} at ${value} timeDelta=${timeDelta}, valueDelta=${valueDelta}`);
    setCurrentValue(value);
    state.current = {
      value,
      timestamp
    };
    return Math.abs(maxValueDelta) > Number.EPSILON;
  }, [currentStepSize, targetValue]);
  (0, _useAnimation.useAnimation)(duration > 0, update);
  return duration > 0 ? currentValue : targetValue;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1Z2xvZyIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsImFyZ3MiLCJsb2dnZXIiLCJsb2ciLCJjYWxsIiwiY29uc29sZSIsInVzZVNtb290aEFuaW1hdGlvbiIsImluaXRpYWxWYWx1ZSIsInRhcmdldFZhbHVlIiwiZHVyYXRpb24iLCJzdGF0ZSIsInVzZVJlZiIsInRpbWVzdGFtcCIsInZhbHVlIiwiY3VycmVudFZhbHVlIiwic2V0Q3VycmVudFZhbHVlIiwidXNlU3RhdGUiLCJjdXJyZW50U3RlcFNpemUiLCJzZXRDdXJyZW50U3RlcFNpemUiLCJ1c2VFZmZlY3QiLCJ0b3RhbERlbHRhIiwiY3VycmVudCIsInVwZGF0ZSIsInVzZUNhbGxiYWNrIiwiTWF0aCIsImFicyIsIk51bWJlciIsIkVQU0lMT04iLCJ0aW1lRGVsdGEiLCJ2YWx1ZURlbHRhIiwibWF4VmFsdWVEZWx0YSIsImNsYW1wZWRWYWx1ZURlbHRhIiwic2lnbiIsIm1pbiIsInVzZUFuaW1hdGlvbiJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ob29rcy91c2VTbW9vdGhBbmltYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIyIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2xvZ2dlclwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgU2V0dGluZ3NTdG9yZSBmcm9tIFwiLi4vc2V0dGluZ3MvU2V0dGluZ3NTdG9yZVwiO1xuaW1wb3J0IHsgdXNlQW5pbWF0aW9uIH0gZnJvbSBcIi4vdXNlQW5pbWF0aW9uXCI7XG5cbmNvbnN0IGRlYnVnbG9nID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJkZWJ1Z19hbmltYXRpb25cIikpIHtcbiAgICAgICAgbG9nZ2VyLmxvZy5jYWxsKGNvbnNvbGUsIFwiQW5pbWF0aW9uIGRlYnVnbG9nOlwiLCAuLi5hcmdzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gc21vb3RobHkgYW5pbWF0ZSB0byBhIGNlcnRhaW4gdGFyZ2V0IHZhbHVlXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIEluaXRpYWwgdmFsdWUgdG8gYmUgdXNlZCBhcyBpbml0aWFsIHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0gdGFyZ2V0VmFsdWUgRGVzaXJlZCB2YWx1ZSB0byBhbmltYXRlIHRvIChjYW4gYmUgY2hhbmdlZCByZXBlYXRlZGx5IHRvIHdoYXRldmVyIGlzIGN1cnJlbnQgYXQgdGhhdCB0aW1lKVxuICogQHBhcmFtIGR1cmF0aW9uIER1cmF0aW9uIHRoYXQgZWFjaCBhbmltYXRpb24gc2hvdWxkIHRha2UsIHNwZWNpZnkgMCB0byBza2lwIGFuaW1hdGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU21vb3RoQW5pbWF0aW9uKFxuICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyLFxuICAgIHRhcmdldFZhbHVlOiBudW1iZXIsXG4gICAgZHVyYXRpb246IG51bWJlcixcbik6IG51bWJlciB7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VSZWY8eyB0aW1lc3RhbXA6IERPTUhpZ2hSZXNUaW1lU3RhbXAgfCBudWxsLCB2YWx1ZTogbnVtYmVyIH0+KHtcbiAgICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgIH0pO1xuICAgIGNvbnN0IFtjdXJyZW50VmFsdWUsIHNldEN1cnJlbnRWYWx1ZV0gPSB1c2VTdGF0ZTxudW1iZXI+KGluaXRpYWxWYWx1ZSk7XG4gICAgY29uc3QgW2N1cnJlbnRTdGVwU2l6ZSwgc2V0Q3VycmVudFN0ZXBTaXplXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0b3RhbERlbHRhID0gdGFyZ2V0VmFsdWUgLSBzdGF0ZS5jdXJyZW50LnZhbHVlO1xuICAgICAgICBzZXRDdXJyZW50U3RlcFNpemUodG90YWxEZWx0YSAvIGR1cmF0aW9uKTtcbiAgICAgICAgc3RhdGUuY3VycmVudCA9IHsgLi4uc3RhdGUuY3VycmVudCwgdGltZXN0YW1wOiBudWxsIH07XG4gICAgfSwgW2R1cmF0aW9uLCB0YXJnZXRWYWx1ZV0pO1xuXG4gICAgY29uc3QgdXBkYXRlID0gdXNlQ2FsbGJhY2soXG4gICAgICAgICh0aW1lc3RhbXA6IERPTUhpZ2hSZXNUaW1lU3RhbXApOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuY3VycmVudC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50ID0geyAuLi5zdGF0ZS5jdXJyZW50LCB0aW1lc3RhbXAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnRTdGVwU2l6ZSkgPCBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGltZURlbHRhID0gdGltZXN0YW1wIC0gc3RhdGUuY3VycmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURlbHRhID0gY3VycmVudFN0ZXBTaXplICogdGltZURlbHRhO1xuICAgICAgICAgICAgY29uc3QgbWF4VmFsdWVEZWx0YSA9IHRhcmdldFZhbHVlIC0gc3RhdGUuY3VycmVudC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRWYWx1ZURlbHRhID0gTWF0aC5zaWduKHZhbHVlRGVsdGEpICogTWF0aC5taW4oTWF0aC5hYnMobWF4VmFsdWVEZWx0YSksIE1hdGguYWJzKHZhbHVlRGVsdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3RhdGUuY3VycmVudC52YWx1ZSArIGNsYW1wZWRWYWx1ZURlbHRhO1xuXG4gICAgICAgICAgICBkZWJ1Z2xvZyhgQW5pbWF0aW5nIHRvICR7dGFyZ2V0VmFsdWV9IGF0ICR7dmFsdWV9IHRpbWVEZWx0YT0ke3RpbWVEZWx0YX0sIHZhbHVlRGVsdGE9JHt2YWx1ZURlbHRhfWApO1xuXG4gICAgICAgICAgICBzZXRDdXJyZW50VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudCA9IHsgdmFsdWUsIHRpbWVzdGFtcCB9O1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobWF4VmFsdWVEZWx0YSkgPiBOdW1iZXIuRVBTSUxPTjtcbiAgICAgICAgfSxcbiAgICAgICAgW2N1cnJlbnRTdGVwU2l6ZSwgdGFyZ2V0VmFsdWVdLFxuICAgICk7XG5cbiAgICB1c2VBbmltYXRpb24oZHVyYXRpb24gPiAwLCB1cGRhdGUpO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uID4gMCA/IGN1cnJlbnRWYWx1ZSA6IHRhcmdldFZhbHVlO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsUUFBUSxHQUFHLFlBQW9CO0VBQ2pDLElBQUlDLHNCQUFBLENBQWNDLFFBQWQsQ0FBdUIsaUJBQXZCLENBQUosRUFBK0M7SUFBQSxrQ0FEOUJDLElBQzhCO01BRDlCQSxJQUM4QjtJQUFBOztJQUMzQ0MsY0FBQSxDQUFPQyxHQUFQLENBQVdDLElBQVgsQ0FBZ0JDLE9BQWhCLEVBQXlCLHFCQUF6QixFQUFnRCxHQUFHSixJQUFuRDtFQUNIO0FBQ0osQ0FKRDtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0ssa0JBQVQsQ0FDSEMsWUFERyxFQUVIQyxXQUZHLEVBR0hDLFFBSEcsRUFJRztFQUNOLE1BQU1DLEtBQUssR0FBRyxJQUFBQyxhQUFBLEVBQWlFO0lBQzNFQyxTQUFTLEVBQUUsSUFEZ0U7SUFFM0VDLEtBQUssRUFBRU47RUFGb0UsQ0FBakUsQ0FBZDtFQUlBLE1BQU0sQ0FBQ08sWUFBRCxFQUFlQyxlQUFmLElBQWtDLElBQUFDLGVBQUEsRUFBaUJULFlBQWpCLENBQXhDO0VBQ0EsTUFBTSxDQUFDVSxlQUFELEVBQWtCQyxrQkFBbEIsSUFBd0MsSUFBQUYsZUFBQSxFQUFpQixDQUFqQixDQUE5QztFQUVBLElBQUFHLGdCQUFBLEVBQVUsTUFBTTtJQUNaLE1BQU1DLFVBQVUsR0FBR1osV0FBVyxHQUFHRSxLQUFLLENBQUNXLE9BQU4sQ0FBY1IsS0FBL0M7SUFDQUssa0JBQWtCLENBQUNFLFVBQVUsR0FBR1gsUUFBZCxDQUFsQjtJQUNBQyxLQUFLLENBQUNXLE9BQU4sbUNBQXFCWCxLQUFLLENBQUNXLE9BQTNCO01BQW9DVCxTQUFTLEVBQUU7SUFBL0M7RUFDSCxDQUpELEVBSUcsQ0FBQ0gsUUFBRCxFQUFXRCxXQUFYLENBSkg7RUFNQSxNQUFNYyxNQUFNLEdBQUcsSUFBQUMsa0JBQUEsRUFDVlgsU0FBRCxJQUE2QztJQUN6QyxJQUFJLENBQUNGLEtBQUssQ0FBQ1csT0FBTixDQUFjVCxTQUFuQixFQUE4QjtNQUMxQkYsS0FBSyxDQUFDVyxPQUFOLG1DQUFxQlgsS0FBSyxDQUFDVyxPQUEzQjtRQUFvQ1Q7TUFBcEM7TUFDQSxPQUFPLElBQVA7SUFDSDs7SUFFRCxJQUFJWSxJQUFJLENBQUNDLEdBQUwsQ0FBU1IsZUFBVCxJQUE0QlMsTUFBTSxDQUFDQyxPQUF2QyxFQUFnRDtNQUM1QyxPQUFPLEtBQVA7SUFDSDs7SUFFRCxNQUFNQyxTQUFTLEdBQUdoQixTQUFTLEdBQUdGLEtBQUssQ0FBQ1csT0FBTixDQUFjVCxTQUE1QztJQUNBLE1BQU1pQixVQUFVLEdBQUdaLGVBQWUsR0FBR1csU0FBckM7SUFDQSxNQUFNRSxhQUFhLEdBQUd0QixXQUFXLEdBQUdFLEtBQUssQ0FBQ1csT0FBTixDQUFjUixLQUFsRDtJQUNBLE1BQU1rQixpQkFBaUIsR0FBR1AsSUFBSSxDQUFDUSxJQUFMLENBQVVILFVBQVYsSUFBd0JMLElBQUksQ0FBQ1MsR0FBTCxDQUFTVCxJQUFJLENBQUNDLEdBQUwsQ0FBU0ssYUFBVCxDQUFULEVBQWtDTixJQUFJLENBQUNDLEdBQUwsQ0FBU0ksVUFBVCxDQUFsQyxDQUFsRDtJQUNBLE1BQU1oQixLQUFLLEdBQUdILEtBQUssQ0FBQ1csT0FBTixDQUFjUixLQUFkLEdBQXNCa0IsaUJBQXBDO0lBRUFqQyxRQUFRLENBQUUsZ0JBQWVVLFdBQVksT0FBTUssS0FBTSxjQUFhZSxTQUFVLGdCQUFlQyxVQUFXLEVBQTFGLENBQVI7SUFFQWQsZUFBZSxDQUFDRixLQUFELENBQWY7SUFDQUgsS0FBSyxDQUFDVyxPQUFOLEdBQWdCO01BQUVSLEtBQUY7TUFBU0Q7SUFBVCxDQUFoQjtJQUVBLE9BQU9ZLElBQUksQ0FBQ0MsR0FBTCxDQUFTSyxhQUFULElBQTBCSixNQUFNLENBQUNDLE9BQXhDO0VBQ0gsQ0F2QlUsRUF3QlgsQ0FBQ1YsZUFBRCxFQUFrQlQsV0FBbEIsQ0F4QlcsQ0FBZjtFQTJCQSxJQUFBMEIsMEJBQUEsRUFBYXpCLFFBQVEsR0FBRyxDQUF4QixFQUEyQmEsTUFBM0I7RUFFQSxPQUFPYixRQUFRLEdBQUcsQ0FBWCxHQUFlSyxZQUFmLEdBQThCTixXQUFyQztBQUNIIn0=