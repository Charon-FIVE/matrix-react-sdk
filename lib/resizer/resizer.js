"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

/*
Copyright 2018 - 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class Resizer {
  // TODO move vertical/horizontal to config option/container class
  // as it doesn't make sense to mix them within one container/Resizer
  constructor(container, distributorCtor, config) {
    this.container = container;
    this.distributorCtor = distributorCtor;
    this.config = config;
    (0, _defineProperty2.default)(this, "classNames", void 0);
    (0, _defineProperty2.default)(this, "onMouseDown", event => {
      // use closest in case the resize handle contains
      // child dom nodes that can be the target
      const resizeHandle = event.target && event.target.closest(`.${this.classNames.handle}`);
      const hasHandler = this?.config?.handler; // prevent that stacked resizer's are both activated with one mouse event
      // (this is possible because the mouse events are connected to the containers not the handles)

      if (!resizeHandle || // if no resizeHandle exist / mouse event hit the container not the handle
      !hasHandler && resizeHandle.parentElement !== this.container || // no handler from config -> check if the containers match
      hasHandler && resizeHandle !== hasHandler) {
        // handler from config -> check if the handlers match
        return;
      } // prevent starting a drag operation


      event.preventDefault(); // mark as currently resizing

      if (this.classNames.resizing) {
        this.container?.classList?.add(this.classNames.resizing);
      }

      if (this.config.onResizeStart) {
        this.config.onResizeStart();
      }

      const {
        sizer,
        distributor
      } = this.createSizerAndDistributor(resizeHandle);
      distributor.start();

      const onMouseMove = event => {
        const offset = sizer.offsetFromEvent(event);
        distributor.resizeFromContainerOffset(offset);
      };

      const body = document.body;

      const finishResize = () => {
        if (this.classNames.resizing) {
          this.container?.classList?.remove(this.classNames.resizing);
        }

        distributor.finish();

        if (this.config.onResizeStop) {
          this.config.onResizeStop();
        }

        body.removeEventListener("mouseup", finishResize, false);
        document.removeEventListener("mouseleave", finishResize, false);
        body.removeEventListener("mousemove", onMouseMove, false);
      };

      body.addEventListener("mouseup", finishResize, false);
      document.addEventListener("mouseleave", finishResize, false);
      body.addEventListener("mousemove", onMouseMove, false);
    });
    (0, _defineProperty2.default)(this, "onResize", (0, _lodash.throttle)(() => {
      const distributors = this.getDistributors(); // relax all items if they had any overconstrained flexboxes

      distributors.forEach(d => d.start());
      distributors.forEach(d => d.finish());
    }, 100, {
      trailing: true,
      leading: true
    }));
    (0, _defineProperty2.default)(this, "getDistributors", () => {
      return this.getResizeHandles().map(handle => {
        const {
          distributor
        } = this.createSizerAndDistributor(handle);
        return distributor;
      });
    });
    this.classNames = {
      handle: "resizer-handle",
      reverse: "resizer-reverse",
      vertical: "resizer-vertical",
      resizing: "resizer-resizing"
    };
  }

  setClassNames(classNames) {
    this.classNames = classNames;
  }

  attach() {
    const attachment = this?.config?.handler?.parentElement ?? this.container;
    attachment.addEventListener("mousedown", this.onMouseDown, false);
    window.addEventListener("resize", this.onResize);
  }

  detach() {
    const attachment = this?.config?.handler?.parentElement ?? this.container;
    attachment.removeEventListener("mousedown", this.onMouseDown, false);
    window.removeEventListener("resize", this.onResize);
  }
  /**
  Gives the distributor for a specific resize handle, as if you would have started
  to drag that handle. Can be used to manipulate the size of an item programmatically.
  @param {number} handleIndex the index of the resize handle in the container
  @return {FixedDistributor} a new distributor for the given handle
  */


  forHandleAt(handleIndex) {
    const handles = this.getResizeHandles();
    const handle = handles[handleIndex];

    if (handle) {
      const {
        distributor
      } = this.createSizerAndDistributor(handle);
      return distributor;
    }
  }

  forHandleWithId(id) {
    const handles = this.getResizeHandles();
    const handle = handles.find(h => h.getAttribute("data-id") === id);

    if (handle) {
      const {
        distributor
      } = this.createSizerAndDistributor(handle);
      return distributor;
    }
  }

  isReverseResizeHandle(el) {
    return el && el.classList.contains(this.classNames.reverse);
  }

  isResizeHandle(el) {
    return el && el.classList.contains(this.classNames.handle);
  }

  createSizerAndDistributor(resizeHandle) {
    const vertical = resizeHandle.classList.contains(this.classNames.vertical);
    const reverse = this.isReverseResizeHandle(resizeHandle);
    const Distributor = this.distributorCtor;
    const useItemContainer = this.config && this.config.handler ? this.container : undefined;
    const sizer = Distributor.createSizer(this.container, vertical, reverse);
    const item = Distributor.createItem(resizeHandle, this, sizer, useItemContainer);
    const distributor = new Distributor(item);
    return {
      sizer,
      distributor
    };
  }

  getResizeHandles() {
    if (this?.config?.handler) {
      return [this.config.handler];
    }

    if (!this.container?.children) return [];
    return Array.from(this.container.querySelectorAll(`.${this.classNames.handle}`));
  }

}

exports.default = Resizer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSZXNpemVyIiwiY29uc3RydWN0b3IiLCJjb250YWluZXIiLCJkaXN0cmlidXRvckN0b3IiLCJjb25maWciLCJldmVudCIsInJlc2l6ZUhhbmRsZSIsInRhcmdldCIsImNsb3Nlc3QiLCJjbGFzc05hbWVzIiwiaGFuZGxlIiwiaGFzSGFuZGxlciIsImhhbmRsZXIiLCJwYXJlbnRFbGVtZW50IiwicHJldmVudERlZmF1bHQiLCJyZXNpemluZyIsImNsYXNzTGlzdCIsImFkZCIsIm9uUmVzaXplU3RhcnQiLCJzaXplciIsImRpc3RyaWJ1dG9yIiwiY3JlYXRlU2l6ZXJBbmREaXN0cmlidXRvciIsInN0YXJ0Iiwib25Nb3VzZU1vdmUiLCJvZmZzZXQiLCJvZmZzZXRGcm9tRXZlbnQiLCJyZXNpemVGcm9tQ29udGFpbmVyT2Zmc2V0IiwiYm9keSIsImRvY3VtZW50IiwiZmluaXNoUmVzaXplIiwicmVtb3ZlIiwiZmluaXNoIiwib25SZXNpemVTdG9wIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0aHJvdHRsZSIsImRpc3RyaWJ1dG9ycyIsImdldERpc3RyaWJ1dG9ycyIsImZvckVhY2giLCJkIiwidHJhaWxpbmciLCJsZWFkaW5nIiwiZ2V0UmVzaXplSGFuZGxlcyIsIm1hcCIsInJldmVyc2UiLCJ2ZXJ0aWNhbCIsInNldENsYXNzTmFtZXMiLCJhdHRhY2giLCJhdHRhY2htZW50Iiwib25Nb3VzZURvd24iLCJ3aW5kb3ciLCJvblJlc2l6ZSIsImRldGFjaCIsImZvckhhbmRsZUF0IiwiaGFuZGxlSW5kZXgiLCJoYW5kbGVzIiwiZm9ySGFuZGxlV2l0aElkIiwiaWQiLCJmaW5kIiwiaCIsImdldEF0dHJpYnV0ZSIsImlzUmV2ZXJzZVJlc2l6ZUhhbmRsZSIsImVsIiwiY29udGFpbnMiLCJpc1Jlc2l6ZUhhbmRsZSIsIkRpc3RyaWJ1dG9yIiwidXNlSXRlbUNvbnRhaW5lciIsInVuZGVmaW5lZCIsImNyZWF0ZVNpemVyIiwiaXRlbSIsImNyZWF0ZUl0ZW0iLCJjaGlsZHJlbiIsIkFycmF5IiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvcmVzaXplci9yZXNpemVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOCAtIDIwMjAgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gXCJsb2Rhc2hcIjtcblxuaW1wb3J0IEZpeGVkRGlzdHJpYnV0b3IgZnJvbSBcIi4vZGlzdHJpYnV0b3JzL2ZpeGVkXCI7XG5pbXBvcnQgUmVzaXplSXRlbSBmcm9tIFwiLi9pdGVtXCI7XG5pbXBvcnQgU2l6ZXIgZnJvbSBcIi4vc2l6ZXJcIjtcblxuaW50ZXJmYWNlIElDbGFzc05hbWVzIHtcbiAgICAvLyBjbGFzcyBvbiByZXNpemUtaGFuZGxlXG4gICAgaGFuZGxlPzogc3RyaW5nO1xuICAgIC8vIGNsYXNzIG9uIHJlc2l6ZS1oYW5kbGVcbiAgICByZXZlcnNlPzogc3RyaW5nO1xuICAgIC8vIGNsYXNzIG9uIHJlc2l6ZS1oYW5kbGVcbiAgICB2ZXJ0aWNhbD86IHN0cmluZztcbiAgICAvLyBjbGFzcyBvbiBjb250YWluZXJcbiAgICByZXNpemluZz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ29uZmlnIHtcbiAgICBvblJlc2l6ZVN0YXJ0PygpOiB2b2lkO1xuICAgIG9uUmVzaXplU3RvcD8oKTogdm9pZDtcbiAgICBvblJlc2l6ZWQ/KHNpemU6IG51bWJlciwgaWQ6IHN0cmluZywgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuICAgIGhhbmRsZXI/OiBIVE1MRGl2RWxlbWVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzaXplcjxDIGV4dGVuZHMgSUNvbmZpZyA9IElDb25maWc+IHtcbiAgICBwcml2YXRlIGNsYXNzTmFtZXM6IElDbGFzc05hbWVzO1xuXG4gICAgLy8gVE9ETyBtb3ZlIHZlcnRpY2FsL2hvcml6b250YWwgdG8gY29uZmlnIG9wdGlvbi9jb250YWluZXIgY2xhc3NcbiAgICAvLyBhcyBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gbWl4IHRoZW0gd2l0aGluIG9uZSBjb250YWluZXIvUmVzaXplclxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBkaXN0cmlidXRvckN0b3I6IHtcbiAgICAgICAgICAgIG5ldyhpdGVtOiBSZXNpemVJdGVtKTogRml4ZWREaXN0cmlidXRvcjxDLCBhbnk+O1xuICAgICAgICAgICAgY3JlYXRlSXRlbShcbiAgICAgICAgICAgICAgICByZXNpemVIYW5kbGU6IEhUTUxEaXZFbGVtZW50LFxuICAgICAgICAgICAgICAgIHJlc2l6ZXI6IFJlc2l6ZXIsXG4gICAgICAgICAgICAgICAgc2l6ZXI6IFNpemVyLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICk6IFJlc2l6ZUl0ZW07XG4gICAgICAgICAgICBjcmVhdGVTaXplcihcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBib29sZWFuXG4gICAgICAgICAgICApOiBTaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGNvbmZpZz86IEMsXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyA9IHtcbiAgICAgICAgICAgIGhhbmRsZTogXCJyZXNpemVyLWhhbmRsZVwiLFxuICAgICAgICAgICAgcmV2ZXJzZTogXCJyZXNpemVyLXJldmVyc2VcIixcbiAgICAgICAgICAgIHZlcnRpY2FsOiBcInJlc2l6ZXItdmVydGljYWxcIixcbiAgICAgICAgICAgIHJlc2l6aW5nOiBcInJlc2l6ZXItcmVzaXppbmdcIixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzOiBJQ2xhc3NOYW1lcykge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhdHRhY2goKSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzPy5jb25maWc/LmhhbmRsZXI/LnBhcmVudEVsZW1lbnQgPz8gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGF0dGFjaG1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXRhY2goKSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzPy5jb25maWc/LmhhbmRsZXI/LnBhcmVudEVsZW1lbnQgPz8gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGF0dGFjaG1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgIEdpdmVzIHRoZSBkaXN0cmlidXRvciBmb3IgYSBzcGVjaWZpYyByZXNpemUgaGFuZGxlLCBhcyBpZiB5b3Ugd291bGQgaGF2ZSBzdGFydGVkXG4gICAgdG8gZHJhZyB0aGF0IGhhbmRsZS4gQ2FuIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSB0aGUgc2l6ZSBvZiBhbiBpdGVtIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgQHBhcmFtIHtudW1iZXJ9IGhhbmRsZUluZGV4IHRoZSBpbmRleCBvZiB0aGUgcmVzaXplIGhhbmRsZSBpbiB0aGUgY29udGFpbmVyXG4gICAgQHJldHVybiB7Rml4ZWREaXN0cmlidXRvcn0gYSBuZXcgZGlzdHJpYnV0b3IgZm9yIHRoZSBnaXZlbiBoYW5kbGVcbiAgICAqL1xuICAgIHB1YmxpYyBmb3JIYW5kbGVBdChoYW5kbGVJbmRleDogbnVtYmVyKTogRml4ZWREaXN0cmlidXRvcjxDPiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXMgPSB0aGlzLmdldFJlc2l6ZUhhbmRsZXMoKTtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gaGFuZGxlc1toYW5kbGVJbmRleF07XG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGlzdHJpYnV0b3IgfSA9IHRoaXMuY3JlYXRlU2l6ZXJBbmREaXN0cmlidXRvcig8SFRNTERpdkVsZW1lbnQ+aGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0cmlidXRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBmb3JIYW5kbGVXaXRoSWQoaWQ6IHN0cmluZyk6IEZpeGVkRGlzdHJpYnV0b3I8Qz4ge1xuICAgICAgICBjb25zdCBoYW5kbGVzID0gdGhpcy5nZXRSZXNpemVIYW5kbGVzKCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGhhbmRsZXMuZmluZCgoaCkgPT4gaC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpID09PSBpZCk7XG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGlzdHJpYnV0b3IgfSA9IHRoaXMuY3JlYXRlU2l6ZXJBbmREaXN0cmlidXRvcig8SFRNTERpdkVsZW1lbnQ+aGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0cmlidXRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpc1JldmVyc2VSZXNpemVIYW5kbGUoZWw6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBlbCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jbGFzc05hbWVzLnJldmVyc2UpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpc1Jlc2l6ZUhhbmRsZShlbDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGVsICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNsYXNzTmFtZXMuaGFuZGxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uTW91c2VEb3duID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIC8vIHVzZSBjbG9zZXN0IGluIGNhc2UgdGhlIHJlc2l6ZSBoYW5kbGUgY29udGFpbnNcbiAgICAgICAgLy8gY2hpbGQgZG9tIG5vZGVzIHRoYXQgY2FuIGJlIHRoZSB0YXJnZXRcbiAgICAgICAgY29uc3QgcmVzaXplSGFuZGxlID0gZXZlbnQudGFyZ2V0ICYmICg8SFRNTERpdkVsZW1lbnQ+ZXZlbnQudGFyZ2V0KS5jbG9zZXN0KGAuJHt0aGlzLmNsYXNzTmFtZXMuaGFuZGxlfWApO1xuICAgICAgICBjb25zdCBoYXNIYW5kbGVyID0gdGhpcz8uY29uZmlnPy5oYW5kbGVyO1xuICAgICAgICAvLyBwcmV2ZW50IHRoYXQgc3RhY2tlZCByZXNpemVyJ3MgYXJlIGJvdGggYWN0aXZhdGVkIHdpdGggb25lIG1vdXNlIGV2ZW50XG4gICAgICAgIC8vICh0aGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgdGhlIG1vdXNlIGV2ZW50cyBhcmUgY29ubmVjdGVkIHRvIHRoZSBjb250YWluZXJzIG5vdCB0aGUgaGFuZGxlcylcbiAgICAgICAgaWYgKCFyZXNpemVIYW5kbGUgfHwgLy8gaWYgbm8gcmVzaXplSGFuZGxlIGV4aXN0IC8gbW91c2UgZXZlbnQgaGl0IHRoZSBjb250YWluZXIgbm90IHRoZSBoYW5kbGVcbiAgICAgICAgICAgICghaGFzSGFuZGxlciAmJiByZXNpemVIYW5kbGUucGFyZW50RWxlbWVudCAhPT0gdGhpcy5jb250YWluZXIpIHx8IC8vIG5vIGhhbmRsZXIgZnJvbSBjb25maWcgLT4gY2hlY2sgaWYgdGhlIGNvbnRhaW5lcnMgbWF0Y2hcbiAgICAgICAgICAgIChoYXNIYW5kbGVyICYmIHJlc2l6ZUhhbmRsZSAhPT0gaGFzSGFuZGxlcikpIHsgLy8gaGFuZGxlciBmcm9tIGNvbmZpZyAtPiBjaGVjayBpZiB0aGUgaGFuZGxlcnMgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgc3RhcnRpbmcgYSBkcmFnIG9wZXJhdGlvblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIG1hcmsgYXMgY3VycmVudGx5IHJlc2l6aW5nXG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMucmVzaXppbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyPy5jbGFzc0xpc3Q/LmFkZCh0aGlzLmNsYXNzTmFtZXMucmVzaXppbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5vblJlc2l6ZVN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5vblJlc2l6ZVN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHNpemVyLCBkaXN0cmlidXRvciB9ID0gdGhpcy5jcmVhdGVTaXplckFuZERpc3RyaWJ1dG9yKDxIVE1MRGl2RWxlbWVudD5yZXNpemVIYW5kbGUpO1xuICAgICAgICBkaXN0cmlidXRvci5zdGFydCgpO1xuXG4gICAgICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzaXplci5vZmZzZXRGcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgZGlzdHJpYnV0b3IucmVzaXplRnJvbUNvbnRhaW5lck9mZnNldChvZmZzZXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICBjb25zdCBmaW5pc2hSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzLnJlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXI/LmNsYXNzTGlzdD8ucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5yZXNpemluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0cmlidXRvci5maW5pc2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5vblJlc2l6ZVN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5vblJlc2l6ZVN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmluaXNoUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmaW5pc2hSZXNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZpbmlzaFJlc2l6ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmaW5pc2hSZXNpemUsIGZhbHNlKTtcbiAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgb25SZXNpemUgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpc3RyaWJ1dG9ycyA9IHRoaXMuZ2V0RGlzdHJpYnV0b3JzKCk7XG5cbiAgICAgICAgLy8gcmVsYXggYWxsIGl0ZW1zIGlmIHRoZXkgaGFkIGFueSBvdmVyY29uc3RyYWluZWQgZmxleGJveGVzXG4gICAgICAgIGRpc3RyaWJ1dG9ycy5mb3JFYWNoKGQgPT4gZC5zdGFydCgpKTtcbiAgICAgICAgZGlzdHJpYnV0b3JzLmZvckVhY2goZCA9PiBkLmZpbmlzaCgpKTtcbiAgICB9LCAxMDAsIHsgdHJhaWxpbmc6IHRydWUsIGxlYWRpbmc6IHRydWUgfSk7XG5cbiAgICBwdWJsaWMgZ2V0RGlzdHJpYnV0b3JzID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXNpemVIYW5kbGVzKCkubWFwKGhhbmRsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRpc3RyaWJ1dG9yIH0gPSB0aGlzLmNyZWF0ZVNpemVyQW5kRGlzdHJpYnV0b3IoPEhUTUxEaXZFbGVtZW50PmhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdHJpYnV0b3I7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGNyZWF0ZVNpemVyQW5kRGlzdHJpYnV0b3IoXG4gICAgICAgIHJlc2l6ZUhhbmRsZTogSFRNTERpdkVsZW1lbnQsXG4gICAgKToge3NpemVyOiBTaXplciwgZGlzdHJpYnV0b3I6IEZpeGVkRGlzdHJpYnV0b3I8YW55Pn0ge1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbCA9IHJlc2l6ZUhhbmRsZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jbGFzc05hbWVzLnZlcnRpY2FsKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHRoaXMuaXNSZXZlcnNlUmVzaXplSGFuZGxlKHJlc2l6ZUhhbmRsZSk7XG4gICAgICAgIGNvbnN0IERpc3RyaWJ1dG9yID0gdGhpcy5kaXN0cmlidXRvckN0b3I7XG4gICAgICAgIGNvbnN0IHVzZUl0ZW1Db250YWluZXIgPSB0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5oYW5kbGVyID8gdGhpcy5jb250YWluZXIgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpemVyID0gRGlzdHJpYnV0b3IuY3JlYXRlU2l6ZXIodGhpcy5jb250YWluZXIsIHZlcnRpY2FsLCByZXZlcnNlKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IERpc3RyaWJ1dG9yLmNyZWF0ZUl0ZW0ocmVzaXplSGFuZGxlLCB0aGlzLCBzaXplciwgdXNlSXRlbUNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IGRpc3RyaWJ1dG9yID0gbmV3IERpc3RyaWJ1dG9yKGl0ZW0pO1xuICAgICAgICByZXR1cm4geyBzaXplciwgZGlzdHJpYnV0b3IgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJlc2l6ZUhhbmRsZXMoKTogSFRNTEVsZW1lbnRbXSB7XG4gICAgICAgIGlmICh0aGlzPy5jb25maWc/LmhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5jb25maWcuaGFuZGxlcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcj8uY2hpbGRyZW4pIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChgLiR7dGhpcy5jbGFzc05hbWVzLmhhbmRsZX1gKSk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWdCQTs7QUFoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMEJlLE1BQU1BLE9BQU4sQ0FBMkM7RUFHdEQ7RUFDQTtFQUNBQyxXQUFXLENBQ0FDLFNBREEsRUFFVUMsZUFGVixFQWdCU0MsTUFoQlQsRUFpQlQ7SUFBQSxLQWhCU0YsU0FnQlQsR0FoQlNBLFNBZ0JUO0lBQUEsS0FmbUJDLGVBZW5CLEdBZm1CQSxlQWVuQjtJQUFBLEtBRGtCQyxNQUNsQixHQURrQkEsTUFDbEI7SUFBQTtJQUFBLG1EQXlEcUJDLEtBQUQsSUFBdUI7TUFDekM7TUFDQTtNQUNBLE1BQU1DLFlBQVksR0FBR0QsS0FBSyxDQUFDRSxNQUFOLElBQWlDRixLQUFLLENBQUNFLE1BQXZCLENBQStCQyxPQUEvQixDQUF3QyxJQUFHLEtBQUtDLFVBQUwsQ0FBZ0JDLE1BQU8sRUFBbEUsQ0FBckM7TUFDQSxNQUFNQyxVQUFVLEdBQUcsTUFBTVAsTUFBTixFQUFjUSxPQUFqQyxDQUp5QyxDQUt6QztNQUNBOztNQUNBLElBQUksQ0FBQ04sWUFBRCxJQUFpQjtNQUNoQixDQUFDSyxVQUFELElBQWVMLFlBQVksQ0FBQ08sYUFBYixLQUErQixLQUFLWCxTQURwRCxJQUNrRTtNQUNqRVMsVUFBVSxJQUFJTCxZQUFZLEtBQUtLLFVBRnBDLEVBRWlEO1FBQUU7UUFDL0M7TUFDSCxDQVh3QyxDQWF6Qzs7O01BQ0FOLEtBQUssQ0FBQ1MsY0FBTixHQWR5QyxDQWdCekM7O01BQ0EsSUFBSSxLQUFLTCxVQUFMLENBQWdCTSxRQUFwQixF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