"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TermsNotSignedError = exports.Service = void 0;
exports.dialogTermsInteractionCallback = dialogTermsInteractionCallback;
exports.startTermsFlow = startTermsFlow;

var _classnames = _interopRequireDefault(require("classnames"));

var _logger = require("matrix-js-sdk/src/logger");

var _MatrixClientPeg = require("./MatrixClientPeg");

var _Modal = _interopRequireDefault(require("./Modal"));

var _TermsDialog = _interopRequireDefault(require("./components/views/dialogs/TermsDialog"));

/*
Copyright 2019, 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class TermsNotSignedError extends Error {}
/**
 * Class representing a service that may have terms & conditions that
 * require agreement from the user before the user can use that service.
 */


exports.TermsNotSignedError = TermsNotSignedError;

class Service {
  /**
   * @param {MatrixClient.SERVICE_TYPES} serviceType The type of service
   * @param {string} baseUrl The Base URL of the service (ie. before '/_matrix')
   * @param {string} accessToken The user's access token for the service
   */
  constructor(serviceType, baseUrl, accessToken) {
    this.serviceType = serviceType;
    this.baseUrl = baseUrl;
    this.accessToken = accessToken;
  }

}

exports.Service = Service;

/**
 * Start a flow where the user is presented with terms & conditions for some services
 *
 * @param {Service[]} services Object with keys 'serviceType', 'baseUrl', 'accessToken'
 * @param {function} interactionCallback Function called with:
 *      * an array of { service: {Service}, policies: {terms response from API} }
 *      * an array of URLs the user has already agreed to
 *     Must return a Promise which resolves with a list of URLs of documents agreed to
 * @returns {Promise} resolves when the user agreed to all necessary terms or rejects
 *     if they cancel.
 */
async function startTermsFlow(services) {
  let interactionCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : dialogTermsInteractionCallback;
  const termsPromises = services.map(s => _MatrixClientPeg.MatrixClientPeg.get().getTerms(s.serviceType, s.baseUrl));
  /*
   * a /terms response looks like:
   * {
   *     "policies": {
   *         "terms_of_service": {
   *             "version": "2.0",
   *              "en": {
   *                 "name": "Terms of Service",
   *                 "url": "https://example.org/somewhere/terms-2.0-en.html"
   *             },
   *             "fr": {
   *                 "name": "Conditions d'utilisation",
   *                 "url": "https://example.org/somewhere/terms-2.0-fr.html"
   *             }
   *         }
   *     }
   * }
   */

  const terms = await Promise.all(termsPromises);
  const policiesAndServicePairs = terms.map((t, i) => {
    return {
      'service': services[i],
      'policies': t.policies
    };
  }); // fetch the set of agreed policy URLs from account data

  const currentAcceptedTerms = await _MatrixClientPeg.MatrixClientPeg.get().getAccountData('m.accepted_terms');
  let agreedUrlSet;

  if (!currentAcceptedTerms || !currentAcceptedTerms.getContent() || !currentAcceptedTerms.getContent().accepted) {
    agreedUrlSet = new Set();
  } else {
    agreedUrlSet = new Set(currentAcceptedTerms.getContent().accepted);
  } // remove any policies the user has already agreed to and any services where
  // they've already agreed to all the policies
  // NB. it could be nicer to show the user stuff they've already agreed to,
  // but then they'd assume they can un-check the boxes to un-agree to a policy,
  // but that is not a thing the API supports, so probably best to just show
  // things they've not agreed to yet.


  const unagreedPoliciesAndServicePairs = [];

  for (const {
    service,
    policies
  } of policiesAndServicePairs) {
    const unagreedPolicies = {};

    for (const [policyName, policy] of Object.entries(policies)) {
      let policyAgreed = false;

      for (const lang of Object.keys(policy)) {
        if (lang === 'version') continue;

        if (agreedUrlSet.has(policy[lang].url)) {
          policyAgreed = true;
          break;
        }
      }

      if (!policyAgreed) unagreedPolicies[policyName] = policy;
    }

    if (Object.keys(unagreedPolicies).length > 0) {
      unagreedPoliciesAndServicePairs.push({
        service,
        policies: unagreedPolicies
      });
    }
  } // if there's anything left to agree to, prompt the user


  const numAcceptedBeforeAgreement = agreedUrlSet.size;

  if (unagreedPoliciesAndServicePairs.length > 0) {
    const newlyAgreedUrls = await interactionCallback(unagreedPoliciesAndServicePairs, [...agreedUrlSet]);

    _logger.logger.log("User has agreed to URLs", newlyAgreedUrls); // Merge with previously agreed URLs


    newlyAgreedUrls.forEach(url => agreedUrlSet.add(url));
  } else {
    _logger.logger.log("User has already agreed to all required policies");
  } // We only ever add to the set of URLs, so if anything has changed then we'd see a different length


  if (agreedUrlSet.size !== numAcceptedBeforeAgreement) {
    const newAcceptedTerms = {
      accepted: Array.from(agreedUrlSet)
    };
    await _MatrixClientPeg.MatrixClientPeg.get().setAccountData('m.accepted_terms', newAcceptedTerms);
  }

  const agreePromises = policiesAndServicePairs.map(policiesAndService => {
    // filter the agreed URL list for ones that are actually for this service
    // (one URL may be used for multiple services)
    // Not a particularly efficient loop but probably fine given the numbers involved
    const urlsForService = Array.from(agreedUrlSet).filter(url => {
      for (const policy of Object.values(policiesAndService.policies)) {
        for (const lang of Object.keys(policy)) {
          if (lang === 'version') continue;
          if (policy[lang].url === url) return true;
        }
      }

      return false;
    });
    if (urlsForService.length === 0) return Promise.resolve();
    return _MatrixClientPeg.MatrixClientPeg.get().agreeToTerms(policiesAndService.service.serviceType, policiesAndService.service.baseUrl, policiesAndService.service.accessToken, urlsForService);
  });
  return Promise.all(agreePromises);
}

async function dialogTermsInteractionCallback(policiesAndServicePairs, agreedUrls, extraClassNames) {
  _logger.logger.log("Terms that need agreement", policiesAndServicePairs);

  const {
    finished
  } = _Modal.default.createDialog(_TermsDialog.default, {
    policiesAndServicePairs,
    agreedUrls
  }, (0, _classnames.default)("mx_TermsDialog", extraClassNames));

  const [done, _agreedUrls] = await finished;

  if (!done) {
    throw new TermsNotSignedError();
  }

  return _agreedUrls;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUZXJtc05vdFNpZ25lZEVycm9yIiwiRXJyb3IiLCJTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJzZXJ2aWNlVHlwZSIsImJhc2VVcmwiLCJhY2Nlc3NUb2tlbiIsInN0YXJ0VGVybXNGbG93Iiwic2VydmljZXMiLCJpbnRlcmFjdGlvbkNhbGxiYWNrIiwiZGlhbG9nVGVybXNJbnRlcmFjdGlvbkNhbGxiYWNrIiwidGVybXNQcm9taXNlcyIsIm1hcCIsInMiLCJNYXRyaXhDbGllbnRQZWciLCJnZXQiLCJnZXRUZXJtcyIsInRlcm1zIiwiUHJvbWlzZSIsImFsbCIsInBvbGljaWVzQW5kU2VydmljZVBhaXJzIiwidCIsImkiLCJwb2xpY2llcyIsImN1cnJlbnRBY2NlcHRlZFRlcm1zIiwiZ2V0QWNjb3VudERhdGEiLCJhZ3JlZWRVcmxTZXQiLCJnZXRDb250ZW50IiwiYWNjZXB0ZWQiLCJTZXQiLCJ1bmFncmVlZFBvbGljaWVzQW5kU2VydmljZVBhaXJzIiwic2VydmljZSIsInVuYWdyZWVkUG9saWNpZXMiLCJwb2xpY3lOYW1lIiwicG9saWN5IiwiT2JqZWN0IiwiZW50cmllcyIsInBvbGljeUFncmVlZCIsImxhbmciLCJrZXlzIiwiaGFzIiwidXJsIiwibGVuZ3RoIiwicHVzaCIsIm51bUFjY2VwdGVkQmVmb3JlQWdyZWVtZW50Iiwic2l6ZSIsIm5ld2x5QWdyZWVkVXJscyIsImxvZ2dlciIsImxvZyIsImZvckVhY2giLCJhZGQiLCJuZXdBY2NlcHRlZFRlcm1zIiwiQXJyYXkiLCJmcm9tIiwic2V0QWNjb3VudERhdGEiLCJhZ3JlZVByb21pc2VzIiwicG9saWNpZXNBbmRTZXJ2aWNlIiwidXJsc0ZvclNlcnZpY2UiLCJmaWx0ZXIiLCJ2YWx1ZXMiLCJyZXNvbHZlIiwiYWdyZWVUb1Rlcm1zIiwiYWdyZWVkVXJscyIsImV4dHJhQ2xhc3NOYW1lcyIsImZpbmlzaGVkIiwiTW9kYWwiLCJjcmVhdGVEaWFsb2ciLCJUZXJtc0RpYWxvZyIsImNsYXNzTmFtZXMiLCJkb25lIiwiX2FncmVlZFVybHMiXSwic291cmNlcyI6WyIuLi9zcmMvVGVybXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5LCAyMDIxIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBTRVJWSUNFX1RZUEVTIH0gZnJvbSAnbWF0cml4LWpzLXNkay9zcmMvc2VydmljZS10eXBlcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvbG9nZ2VyXCI7XG5cbmltcG9ydCB7IE1hdHJpeENsaWVudFBlZyB9IGZyb20gJy4vTWF0cml4Q2xpZW50UGVnJztcbmltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsJztcbmltcG9ydCBUZXJtc0RpYWxvZyBmcm9tIFwiLi9jb21wb25lbnRzL3ZpZXdzL2RpYWxvZ3MvVGVybXNEaWFsb2dcIjtcblxuZXhwb3J0IGNsYXNzIFRlcm1zTm90U2lnbmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNlcnZpY2UgdGhhdCBtYXkgaGF2ZSB0ZXJtcyAmIGNvbmRpdGlvbnMgdGhhdFxuICogcmVxdWlyZSBhZ3JlZW1lbnQgZnJvbSB0aGUgdXNlciBiZWZvcmUgdGhlIHVzZXIgY2FuIHVzZSB0aGF0IHNlcnZpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01hdHJpeENsaWVudC5TRVJWSUNFX1RZUEVTfSBzZXJ2aWNlVHlwZSBUaGUgdHlwZSBvZiBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgVGhlIEJhc2UgVVJMIG9mIHRoZSBzZXJ2aWNlIChpZS4gYmVmb3JlICcvX21hdHJpeCcpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSB1c2VyJ3MgYWNjZXNzIHRva2VuIGZvciB0aGUgc2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXJ2aWNlVHlwZTogU0VSVklDRV9UWVBFUywgcHVibGljIGJhc2VVcmw6IHN0cmluZywgcHVibGljIGFjY2Vzc1Rva2VuOiBzdHJpbmcpIHtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxpc2VkUG9saWN5IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdXJsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9saWN5IHtcbiAgICAvLyBAdHMtaWdub3JlOiBObyBncmVhdCB3YXkgdG8gZXhwcmVzcyBpbmRleGVkIHR5cGVzIHRvZ2V0aGVyIHdpdGggb3RoZXIga2V5c1xuICAgIHZlcnNpb246IHN0cmluZztcbiAgICBbbGFuZzogc3RyaW5nXTogTG9jYWxpc2VkUG9saWN5O1xufVxuXG5leHBvcnQgdHlwZSBQb2xpY2llcyA9IHtcbiAgICBbcG9saWN5OiBzdHJpbmddOiBQb2xpY3k7XG59O1xuXG5leHBvcnQgdHlwZSBUZXJtc0ludGVyYWN0aW9uQ2FsbGJhY2sgPSAoXG4gICAgcG9saWNpZXNBbmRTZXJ2aWNlUGFpcnM6IHtcbiAgICAgICAgc2VydmljZTogU2VydmljZTtcbiAgICAgICAgcG9saWNpZXM6IFBvbGljaWVzO1xuICAgIH1bXSxcbiAgICBhZ3JlZWRVcmxzOiBzdHJpbmdbXSxcbiAgICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmcsXG4pID0+IFByb21pc2U8c3RyaW5nW10+O1xuXG4vKipcbiAqIFN0YXJ0IGEgZmxvdyB3aGVyZSB0aGUgdXNlciBpcyBwcmVzZW50ZWQgd2l0aCB0ZXJtcyAmIGNvbmRpdGlvbnMgZm9yIHNvbWUgc2VydmljZXNcbiAqXG4gKiBAcGFyYW0ge1NlcnZpY2VbXX0gc2VydmljZXMgT2JqZWN0IHdpdGgga2V5cyAnc2VydmljZVR5cGUnLCAnYmFzZVVybCcsICdhY2Nlc3NUb2tlbidcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGludGVyYWN0aW9uQ2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdpdGg6XG4gKiAgICAgICogYW4gYXJyYXkgb2YgeyBzZXJ2aWNlOiB7U2VydmljZX0sIHBvbGljaWVzOiB7dGVybXMgcmVzcG9uc2UgZnJvbSBBUEl9IH1cbiAqICAgICAgKiBhbiBhcnJheSBvZiBVUkxzIHRoZSB1c2VyIGhhcyBhbHJlYWR5IGFncmVlZCB0b1xuICogICAgIE11c3QgcmV0dXJuIGEgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIGEgbGlzdCBvZiBVUkxzIG9mIGRvY3VtZW50cyBhZ3JlZWQgdG9cbiAqIEByZXR1cm5zIHtQcm9taXNlfSByZXNvbHZlcyB3aGVuIHRoZSB1c2VyIGFncmVlZCB0byBhbGwgbmVjZXNzYXJ5IHRlcm1zIG9yIHJlamVjdHNcbiAqICAgICBpZiB0aGV5IGNhbmNlbC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0VGVybXNGbG93KFxuICAgIHNlcnZpY2VzOiBTZXJ2aWNlW10sXG4gICAgaW50ZXJhY3Rpb25DYWxsYmFjazogVGVybXNJbnRlcmFjdGlvbkNhbGxiYWNrID0gZGlhbG9nVGVybXNJbnRlcmFjdGlvbkNhbGxiYWNrLFxuKSB7XG4gICAgY29uc3QgdGVybXNQcm9taXNlcyA9IHNlcnZpY2VzLm1hcChcbiAgICAgICAgKHMpID0+IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRUZXJtcyhzLnNlcnZpY2VUeXBlLCBzLmJhc2VVcmwpLFxuICAgICk7XG5cbiAgICAvKlxuICAgICAqIGEgL3Rlcm1zIHJlc3BvbnNlIGxvb2tzIGxpa2U6XG4gICAgICoge1xuICAgICAqICAgICBcInBvbGljaWVzXCI6IHtcbiAgICAgKiAgICAgICAgIFwidGVybXNfb2Zfc2VydmljZVwiOiB7XG4gICAgICogICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMi4wXCIsXG4gICAgICogICAgICAgICAgICAgIFwiZW5cIjoge1xuICAgICAqICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUZXJtcyBvZiBTZXJ2aWNlXCIsXG4gICAgICogICAgICAgICAgICAgICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLm9yZy9zb21ld2hlcmUvdGVybXMtMi4wLWVuLmh0bWxcIlxuICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgXCJmclwiOiB7XG4gICAgICogICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNvbmRpdGlvbnMgZCd1dGlsaXNhdGlvblwiLFxuICAgICAqICAgICAgICAgICAgICAgICBcInVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5vcmcvc29tZXdoZXJlL3Rlcm1zLTIuMC1mci5odG1sXCJcbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBjb25zdCB0ZXJtczogeyBwb2xpY2llczogUG9saWNpZXMgfVtdID0gYXdhaXQgUHJvbWlzZS5hbGwodGVybXNQcm9taXNlcyk7XG4gICAgY29uc3QgcG9saWNpZXNBbmRTZXJ2aWNlUGFpcnMgPSB0ZXJtcy5tYXAoKHQsIGkpID0+IHsgcmV0dXJuIHsgJ3NlcnZpY2UnOiBzZXJ2aWNlc1tpXSwgJ3BvbGljaWVzJzogdC5wb2xpY2llcyB9OyB9KTtcblxuICAgIC8vIGZldGNoIHRoZSBzZXQgb2YgYWdyZWVkIHBvbGljeSBVUkxzIGZyb20gYWNjb3VudCBkYXRhXG4gICAgY29uc3QgY3VycmVudEFjY2VwdGVkVGVybXMgPSBhd2FpdCBNYXRyaXhDbGllbnRQZWcuZ2V0KCkuZ2V0QWNjb3VudERhdGEoJ20uYWNjZXB0ZWRfdGVybXMnKTtcbiAgICBsZXQgYWdyZWVkVXJsU2V0OiBTZXQ8c3RyaW5nPjtcbiAgICBpZiAoIWN1cnJlbnRBY2NlcHRlZFRlcm1zIHx8ICFjdXJyZW50QWNjZXB0ZWRUZXJtcy5nZXRDb250ZW50KCkgfHwgIWN1cnJlbnRBY2NlcHRlZFRlcm1zLmdldENvbnRlbnQoKS5hY2NlcHRlZCkge1xuICAgICAgICBhZ3JlZWRVcmxTZXQgPSBuZXcgU2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWdyZWVkVXJsU2V0ID0gbmV3IFNldChjdXJyZW50QWNjZXB0ZWRUZXJtcy5nZXRDb250ZW50KCkuYWNjZXB0ZWQpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgcG9saWNpZXMgdGhlIHVzZXIgaGFzIGFscmVhZHkgYWdyZWVkIHRvIGFuZCBhbnkgc2VydmljZXMgd2hlcmVcbiAgICAvLyB0aGV5J3ZlIGFscmVhZHkgYWdyZWVkIHRvIGFsbCB0aGUgcG9saWNpZXNcbiAgICAvLyBOQi4gaXQgY291bGQgYmUgbmljZXIgdG8gc2hvdyB0aGUgdXNlciBzdHVmZiB0aGV5J3ZlIGFscmVhZHkgYWdyZWVkIHRvLFxuICAgIC8vIGJ1dCB0aGVuIHRoZXknZCBhc3N1bWUgdGhleSBjYW4gdW4tY2hlY2sgdGhlIGJveGVzIHRvIHVuLWFncmVlIHRvIGEgcG9saWN5LFxuICAgIC8vIGJ1dCB0aGF0IGlzIG5vdCBhIHRoaW5nIHRoZSBBUEkgc3VwcG9ydHMsIHNvIHByb2JhYmx5IGJlc3QgdG8ganVzdCBzaG93XG4gICAgLy8gdGhpbmdzIHRoZXkndmUgbm90IGFncmVlZCB0byB5ZXQuXG4gICAgY29uc3QgdW5hZ3JlZWRQb2xpY2llc0FuZFNlcnZpY2VQYWlycyA9IFtdO1xuICAgIGZvciAoY29uc3QgeyBzZXJ2aWNlLCBwb2xpY2llcyB9IG9mIHBvbGljaWVzQW5kU2VydmljZVBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHVuYWdyZWVkUG9saWNpZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbcG9saWN5TmFtZSwgcG9saWN5XSBvZiBPYmplY3QuZW50cmllcyhwb2xpY2llcykpIHtcbiAgICAgICAgICAgIGxldCBwb2xpY3lBZ3JlZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBPYmplY3Qua2V5cyhwb2xpY3kpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmcgPT09ICd2ZXJzaW9uJykgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGFncmVlZFVybFNldC5oYXMocG9saWN5W2xhbmddLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9saWN5QWdyZWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwb2xpY3lBZ3JlZWQpIHVuYWdyZWVkUG9saWNpZXNbcG9saWN5TmFtZV0gPSBwb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHVuYWdyZWVkUG9saWNpZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVuYWdyZWVkUG9saWNpZXNBbmRTZXJ2aWNlUGFpcnMucHVzaCh7IHNlcnZpY2UsIHBvbGljaWVzOiB1bmFncmVlZFBvbGljaWVzIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBhbnl0aGluZyBsZWZ0IHRvIGFncmVlIHRvLCBwcm9tcHQgdGhlIHVzZXJcbiAgICBjb25zdCBudW1BY2NlcHRlZEJlZm9yZUFncmVlbWVudCA9IGFncmVlZFVybFNldC5zaXplO1xuICAgIGlmICh1bmFncmVlZFBvbGljaWVzQW5kU2VydmljZVBhaXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV3bHlBZ3JlZWRVcmxzID0gYXdhaXQgaW50ZXJhY3Rpb25DYWxsYmFjayh1bmFncmVlZFBvbGljaWVzQW5kU2VydmljZVBhaXJzLCBbLi4uYWdyZWVkVXJsU2V0XSk7XG4gICAgICAgIGxvZ2dlci5sb2coXCJVc2VyIGhhcyBhZ3JlZWQgdG8gVVJMc1wiLCBuZXdseUFncmVlZFVybHMpO1xuICAgICAgICAvLyBNZXJnZSB3aXRoIHByZXZpb3VzbHkgYWdyZWVkIFVSTHNcbiAgICAgICAgbmV3bHlBZ3JlZWRVcmxzLmZvckVhY2godXJsID0+IGFncmVlZFVybFNldC5hZGQodXJsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlVzZXIgaGFzIGFscmVhZHkgYWdyZWVkIHRvIGFsbCByZXF1aXJlZCBwb2xpY2llc1wiKTtcbiAgICB9XG5cbiAgICAvLyBXZSBvbmx5IGV2ZXIgYWRkIHRvIHRoZSBzZXQgb2YgVVJMcywgc28gaWYgYW55dGhpbmcgaGFzIGNoYW5nZWQgdGhlbiB3ZSdkIHNlZSBhIGRpZmZlcmVudCBsZW5ndGhcbiAgICBpZiAoYWdyZWVkVXJsU2V0LnNpemUgIT09IG51bUFjY2VwdGVkQmVmb3JlQWdyZWVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5ld0FjY2VwdGVkVGVybXMgPSB7IGFjY2VwdGVkOiBBcnJheS5mcm9tKGFncmVlZFVybFNldCkgfTtcbiAgICAgICAgYXdhaXQgTWF0cml4Q2xpZW50UGVnLmdldCgpLnNldEFjY291bnREYXRhKCdtLmFjY2VwdGVkX3Rlcm1zJywgbmV3QWNjZXB0ZWRUZXJtcyk7XG4gICAgfVxuXG4gICAgY29uc3QgYWdyZWVQcm9taXNlcyA9IHBvbGljaWVzQW5kU2VydmljZVBhaXJzLm1hcCgocG9saWNpZXNBbmRTZXJ2aWNlKSA9PiB7XG4gICAgICAgIC8vIGZpbHRlciB0aGUgYWdyZWVkIFVSTCBsaXN0IGZvciBvbmVzIHRoYXQgYXJlIGFjdHVhbGx5IGZvciB0aGlzIHNlcnZpY2VcbiAgICAgICAgLy8gKG9uZSBVUkwgbWF5IGJlIHVzZWQgZm9yIG11bHRpcGxlIHNlcnZpY2VzKVxuICAgICAgICAvLyBOb3QgYSBwYXJ0aWN1bGFybHkgZWZmaWNpZW50IGxvb3AgYnV0IHByb2JhYmx5IGZpbmUgZ2l2ZW4gdGhlIG51bWJlcnMgaW52b2x2ZWRcbiAgICAgICAgY29uc3QgdXJsc0ZvclNlcnZpY2UgPSBBcnJheS5mcm9tKGFncmVlZFVybFNldCkuZmlsdGVyKCh1cmwpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9saWN5IG9mIE9iamVjdC52YWx1ZXMocG9saWNpZXNBbmRTZXJ2aWNlLnBvbGljaWVzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBPYmplY3Qua2V5cyhwb2xpY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nID09PSAndmVyc2lvbicpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9saWN5W2xhbmddLnVybCA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1cmxzRm9yU2VydmljZS5sZW5ndGggPT09IDApIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgICByZXR1cm4gTWF0cml4Q2xpZW50UGVnLmdldCgpLmFncmVlVG9UZXJtcyhcbiAgICAgICAgICAgIHBvbGljaWVzQW5kU2VydmljZS5zZXJ2aWNlLnNlcnZpY2VUeXBlLFxuICAgICAgICAgICAgcG9saWNpZXNBbmRTZXJ2aWNlLnNlcnZpY2UuYmFzZVVybCxcbiAgICAgICAgICAgIHBvbGljaWVzQW5kU2VydmljZS5zZXJ2aWNlLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgdXJsc0ZvclNlcnZpY2UsXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFncmVlUHJvbWlzZXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlhbG9nVGVybXNJbnRlcmFjdGlvbkNhbGxiYWNrKFxuICAgIHBvbGljaWVzQW5kU2VydmljZVBhaXJzOiB7XG4gICAgICAgIHNlcnZpY2U6IFNlcnZpY2U7XG4gICAgICAgIHBvbGljaWVzOiB7IFtwb2xpY3k6IHN0cmluZ106IFBvbGljeSB9O1xuICAgIH1bXSxcbiAgICBhZ3JlZWRVcmxzOiBzdHJpbmdbXSxcbiAgICBleHRyYUNsYXNzTmFtZXM/OiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgbG9nZ2VyLmxvZyhcIlRlcm1zIHRoYXQgbmVlZCBhZ3JlZW1lbnRcIiwgcG9saWNpZXNBbmRTZXJ2aWNlUGFpcnMpO1xuXG4gICAgY29uc3QgeyBmaW5pc2hlZCB9ID0gTW9kYWwuY3JlYXRlRGlhbG9nPFtib29sZWFuLCBzdHJpbmdbXV0+KFRlcm1zRGlhbG9nLCB7XG4gICAgICAgIHBvbGljaWVzQW5kU2VydmljZVBhaXJzLFxuICAgICAgICBhZ3JlZWRVcmxzLFxuICAgIH0sIGNsYXNzTmFtZXMoXCJteF9UZXJtc0RpYWxvZ1wiLCBleHRyYUNsYXNzTmFtZXMpKTtcblxuICAgIGNvbnN0IFtkb25lLCBfYWdyZWVkVXJsc10gPSBhd2FpdCBmaW5pc2hlZDtcbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRlcm1zTm90U2ln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