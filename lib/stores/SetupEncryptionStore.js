"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetupEncryptionStore = exports.Phase = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var _VerificationRequest = require("matrix-js-sdk/src/crypto/verification/request/VerificationRequest");

var _logger = require("matrix-js-sdk/src/logger");

var _crypto = require("matrix-js-sdk/src/crypto");

var _MatrixClientPeg = require("../MatrixClientPeg");

var _SecurityManager = require("../SecurityManager");

var _Modal = _interopRequireDefault(require("../Modal"));

var _InteractiveAuthDialog = _interopRequireDefault(require("../components/views/dialogs/InteractiveAuthDialog"));

var _languageHandler = require("../languageHandler");

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
let Phase;
exports.Phase = Phase;

(function (Phase) {
  Phase[Phase["Loading"] = 0] = "Loading";
  Phase[Phase["Intro"] = 1] = "Intro";
  Phase[Phase["Busy"] = 2] = "Busy";
  Phase[Phase["Done"] = 3] = "Done";
  Phase[Phase["ConfirmSkip"] = 4] = "ConfirmSkip";
  Phase[Phase["Finished"] = 5] = "Finished";
  Phase[Phase["ConfirmReset"] = 6] = "ConfirmReset";
})(Phase || (exports.Phase = Phase = {}));

class SetupEncryptionStore extends _events.default {
  constructor() {
    super(...arguments);
    (0, _defineProperty2.default)(this, "started", void 0);
    (0, _defineProperty2.default)(this, "phase", void 0);
    (0, _defineProperty2.default)(this, "verificationRequest", void 0);
    (0, _defineProperty2.default)(this, "backupInfo", void 0);
    (0, _defineProperty2.default)(this, "keyId", void 0);
    (0, _defineProperty2.default)(this, "keyInfo", void 0);
    (0, _defineProperty2.default)(this, "hasDevicesToVerifyAgainst", void 0);
    (0, _defineProperty2.default)(this, "onUserTrustStatusChanged", userId => {
      if (userId !== _MatrixClientPeg.MatrixClientPeg.get().getUserId()) return;

      const publicKeysTrusted = _MatrixClientPeg.MatrixClientPeg.get().getCrossSigningId();

      if (publicKeysTrusted) {
        this.phase = Phase.Done;
        this.emit("update");
      }
    });
    (0, _defineProperty2.default)(this, "onVerificationRequest", request => {
      this.setActiveVerificationRequest(request);
    });
    (0, _defineProperty2.default)(this, "onVerificationRequestChange", () => {
      if (this.verificationRequest.cancelled) {
        this.verificationRequest.off(_VerificationRequest.VerificationRequestEvent.Change, this.onVerificationRequestChange);
        this.verificationRequest = null;
        this.emit("update");
      } else if (this.verificationRequest.phase === _VerificationRequest.PHASE_DONE) {
        this.verificationRequest.off(_VerificationRequest.VerificationRequestEvent.Change, this.onVerificationRequestChange);
        this.verificationRequest = null; // At this point, the verification has finished, we just need to wait for
        // cross signing to be ready to use, so wait for the user trust status to
        // change (or change to DONE if it's already ready).

        const publicKeysTrusted = _MatrixClientPeg.MatrixClientPeg.get().getCrossSigningId();

        this.phase = publicKeysTrusted ? Phase.Done : Phase.Busy;
        this.emit("update");
      }
    });
  }

  static sharedInstance() {
    if (!window.mxSetupEncryptionStore) window.mxSetupEncryptionStore = new SetupEncryptionStore();
    return window.mxSetupEncryptionStore;
  }

  start() {
    if (this.started) {
      return;
    }

    this.started = true;
    this.phase = Phase.Loading;
    this.verificationRequest = null;
    this.backupInfo = null; // ID of the key that the secrets we want are encrypted with

    this.keyId = null; // Descriptor of the key that the secrets we want are encrypted with

    this.keyInfo = null;

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    cli.on(_crypto.CryptoEvent.VerificationRequest, this.onVerificationRequest);
    cli.on(_crypto.CryptoEvent.UserTrustStatusChanged, this.onUserTrustStatusChanged);
    const requestsInProgress = cli.getVerificationRequestsToDeviceInProgress(cli.getUserId());

    if (requestsInProgress.length) {
      // If there are multiple, we take the most recent. Equally if the user sends another request from
      // another device after this screen has been shown, we'll switch to the new one, so this
      // generally doesn't support multiple requests.
      this.setActiveVerificationRequest(requestsInProgress[requestsInProgress.length - 1]);
    }

    this.fetchKeyInfo();
  }

  stop() {
    if (!this.started) {
      return;
    }

    this.started = false;
    this.verificationRequest?.off(_VerificationRequest.VerificationRequestEvent.Change, this.onVerificationRequestChange);

    if (_MatrixClientPeg.MatrixClientPeg.get()) {
      _MatrixClientPeg.MatrixClientPeg.get().removeListener(_crypto.CryptoEvent.VerificationRequest, this.onVerificationRequest);

      _MatrixClientPeg.MatrixClientPeg.get().removeListener(_crypto.CryptoEvent.UserTrustStatusChanged, this.onUserTrustStatusChanged);
    }
  }

  async fetchKeyInfo() {
    if (!this.started) return; // bail if we were stopped

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    const keys = await cli.isSecretStored('m.cross_signing.master');

    if (keys === null || Object.keys(keys).length === 0) {
      this.keyId = null;
      this.keyInfo = null;
    } else {
      // If the secret is stored under more than one key, we just pick an arbitrary one
      this.keyId = Object.keys(keys)[0];
      this.keyInfo = keys[this.keyId];
    } // do we have any other verified devices which are E2EE which we can verify against?


    const dehydratedDevice = await cli.getDehydratedDevice();
    const ownUserId = cli.getUserId();
    const crossSigningInfo = cli.getStoredCrossSigningForUser(ownUserId);
    this.hasDevicesToVerifyAgainst = cli.getStoredDevicesForUser(ownUserId).some(device => device.getIdentityKey() && (!dehydratedDevice || device.deviceId != dehydratedDevice.device_id) && crossSigningInfo.checkDeviceTrust(crossSigningInfo, device, false, true).isCrossSigningVerified());
    this.phase = Phase.Intro;
    this.emit("update");
  }

  async usePassPhrase() {
    this.phase = Phase.Busy;
    this.emit("update");

    const cli = _MatrixClientPeg.MatrixClientPeg.get();

    try {
      const backupInfo = await cli.getKeyBackupVersion();
      this.backupInfo = backupInfo;
      this.emit("update"); // The control flow is fairly twisted here...
      // For the purposes of completing security, we only wait on getting
      // as far as the trust check and then show a green shield.
      // We also begin the key backup restore as well, which we're
      // awaiting inside `accessSecretStorage` only so that it keeps your
      // passphase cached for that work. This dialog itself will only wait
      // on the first trust check, and the key backup restore will happen
      // in the background.

      await new Promise((resolve, reject) => {
        (0, _SecurityManager.accessSecretStorage)(async () => {
          await cli.checkOwnCrossSigningTrust();
          resolve();

          if (backupInfo) {
            // A complete restore can take many minutes for large
            // accounts / slow servers, so we allow the dialog
            // to advance before this.
            await cli.restoreKeyBackupWithSecretStorage(backupInfo);
          }
        }).catch(reject);
      });

      if (cli.getCrossSigningId()) {
        this.phase = Phase.Done;
        this.emit("update");
      }
    } catch (e) {
      if (!(e instanceof _SecurityManager.AccessCancelledError)) {
        _logger.logger.log(e);
      } // this will throw if the user hits cancel, so ignore


      this.phase = Phase.Intro;
      this.emit("update");
    }
  }

  skip() {
    this.phase = Phase.ConfirmSkip;
    this.emit("update");
  }

  skipConfirm() {
    this.phase = Phase.Finished;
    this.emit("update");
  }

  returnAfterSkip() {
    this.phase = Phase.Intro;
    this.emit("update");
  }

  reset() {
    this.phase = Phase.ConfirmReset;
    this.emit("update");
  }

  async resetConfirm() {
    try {
      // If we've gotten here, the user presumably lost their
      // secret storage key if they had one. Start by resetting
      // secret storage and setting up a new recovery key, then
      // create new cross-signing keys once that succeeds.
      await (0, _SecurityManager.accessSecretStorage)(async () => {
        const cli = _MatrixClientPeg.MatrixClientPeg.get();

        await cli.bootstrapCrossSigning({
          authUploadDeviceSigningKeys: async makeRequest => {
            const {
              finished
            } = _Modal.default.createDialog(_InteractiveAuthDialog.default, {
              title: (0, _languageHandler._t)("Setting up keys"),
              matrixClient: cli,
              makeRequest
            });

            const [confirmed] = await finished;

            if (!confirmed) {
              throw new Error("Cross-signing key upload auth canceled");
            }
          },
          setupNewCrossSigning: true
        });
        this.phase = Phase.Finished;
      }, true);
    } catch (e) {
      _logger.logger.error("Error resetting cross-signing", e);

      this.phase = Phase.Intro;
    }

    this.emit("update");
  }

  returnAfterReset() {
    this.phase = Phase.Intro;
    this.emit("update");
  }

  done() {
    this.phase = Phase.Finished;
    this.emit("update"); // async - ask other clients for keys, if necessary

    _MatrixClientPeg.MatrixClientPeg.get().crypto.cancelAndResendAllOutgoingKeyRequests();
  }

  async setActiveVerificationRequest(request) {
    if (!this.started) return; // bail if we were stopped

    if (request.otherUserId !== _MatrixClientPeg.MatrixClientPeg.get().getUserId()) return;

    if (this.verificationRequest) {
      this.verificationRequest.off(_VerificationRequest.VerificationRequestEvent.Change, this.onVerificationRequestChange);
    }

    this.verificationRequest = request;
    await request.accept();
    request.on(_VerificationRequest.VerificationRequestEvent.Change, this.onVerificationRequestChange);
    this.emit("update");
  }

  lostKeys() {
    return !this.hasDevicesToVerifyAgainst && !this.keyInfo;
  }

}

exports.SetupEncryptionStore = SetupEncryptionStore;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQaGFzZSIsIlNldHVwRW5jcnlwdGlvblN0b3JlIiwiRXZlbnRFbWl0dGVyIiwidXNlcklkIiwiTWF0cml4Q2xpZW50UGVnIiwiZ2V0IiwiZ2V0VXNlcklkIiwicHVibGljS2V5c1RydXN0ZWQiLCJnZXRDcm9zc1NpZ25pbmdJZCIsInBoYXNlIiwiRG9uZSIsImVtaXQiLCJyZXF1ZXN0Iiwic2V0QWN0aXZlVmVyaWZpY2F0aW9uUmVxdWVzdCIsInZlcmlmaWNhdGlvblJlcXVlc3QiLCJjYW5jZWxsZWQiLCJvZmYiLCJWZXJpZmljYXRpb25SZXF1ZXN0RXZlbnQiLCJDaGFuZ2UiLCJvblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UiLCJWRVJJRl9QSEFTRV9ET05FIiwiQnVzeSIsInNoYXJlZEluc3RhbmNlIiwid2luZG93IiwibXhTZXR1cEVuY3J5cHRpb25TdG9yZSIsInN0YXJ0Iiwic3RhcnRlZCIsIkxvYWRpbmciLCJiYWNrdXBJbmZvIiwia2V5SWQiLCJrZXlJbmZvIiwiY2xpIiwib24iLCJDcnlwdG9FdmVudCIsIlZlcmlmaWNhdGlvblJlcXVlc3QiLCJvblZlcmlmaWNhdGlvblJlcXVlc3QiLCJVc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkIiwib25Vc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkIiwicmVxdWVzdHNJblByb2dyZXNzIiwiZ2V0VmVyaWZpY2F0aW9uUmVxdWVzdHNUb0RldmljZUluUHJvZ3Jlc3MiLCJsZW5ndGgiLCJmZXRjaEtleUluZm8iLCJzdG9wIiwicmVtb3ZlTGlzdGVuZXIiLCJrZXlzIiwiaXNTZWNyZXRTdG9yZWQiLCJPYmplY3QiLCJkZWh5ZHJhdGVkRGV2aWNlIiwiZ2V0RGVoeWRyYXRlZERldmljZSIsIm93blVzZXJJZCIsImNyb3NzU2lnbmluZ0luZm8iLCJnZXRTdG9yZWRDcm9zc1NpZ25pbmdGb3JVc2VyIiwiaGFzRGV2aWNlc1RvVmVyaWZ5QWdhaW5zdCIsImdldFN0b3JlZERldmljZXNGb3JVc2VyIiwic29tZSIsImRldmljZSIsImdldElkZW50aXR5S2V5IiwiZGV2aWNlSWQiLCJkZXZpY2VfaWQiLCJjaGVja0RldmljZVRydXN0IiwiaXNDcm9zc1NpZ25pbmdWZXJpZmllZCIsIkludHJvIiwidXNlUGFzc1BocmFzZSIsImdldEtleUJhY2t1cFZlcnNpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFjY2Vzc1NlY3JldFN0b3JhZ2UiLCJjaGVja093bkNyb3NzU2lnbmluZ1RydXN0IiwicmVzdG9yZUtleUJhY2t1cFdpdGhTZWNyZXRTdG9yYWdlIiwiY2F0Y2giLCJlIiwiQWNjZXNzQ2FuY2VsbGVkRXJyb3IiLCJsb2dnZXIiLCJsb2ciLCJza2lwIiwiQ29uZmlybVNraXAiLCJza2lwQ29uZmlybSIsIkZpbmlzaGVkIiwicmV0dXJuQWZ0ZXJTa2lwIiwicmVzZXQiLCJDb25maXJtUmVzZXQiLCJyZXNldENvbmZpcm0iLCJib290c3RyYXBDcm9zc1NpZ25pbmciLCJhdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXMiLCJtYWtlUmVxdWVzdCIsImZpbmlzaGVkIiwiTW9kYWwiLCJjcmVhdGVEaWFsb2ciLCJJbnRlcmFjdGl2ZUF1dGhEaWFsb2ciLCJ0aXRsZSIsIl90IiwibWF0cml4Q2xpZW50IiwiY29uZmlybWVkIiwiRXJyb3IiLCJzZXR1cE5ld0Nyb3NzU2lnbmluZyIsImVycm9yIiwicmV0dXJuQWZ0ZXJSZXNldCIsImRvbmUiLCJjcnlwdG8iLCJjYW5jZWxBbmRSZXNlbmRBbGxPdXRnb2luZ0tleVJlcXVlc3RzIiwib3RoZXJVc2VySWQiLCJhY2NlcHQiLCJsb3N0S2V5cyJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yZXMvU2V0dXBFbmNyeXB0aW9uU3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtcbiAgICBQSEFTRV9ET05FIGFzIFZFUklGX1BIQVNFX0RPTkUsXG4gICAgVmVyaWZpY2F0aW9uUmVxdWVzdCxcbiAgICBWZXJpZmljYXRpb25SZXF1ZXN0RXZlbnQsXG59IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9jcnlwdG8vdmVyaWZpY2F0aW9uL3JlcXVlc3QvVmVyaWZpY2F0aW9uUmVxdWVzdFwiO1xuaW1wb3J0IHsgSUtleUJhY2t1cEluZm8gfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvY3J5cHRvL2tleWJhY2t1cFwiO1xuaW1wb3J0IHsgSVNlY3JldFN0b3JhZ2VLZXlJbmZvIH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NyeXB0by9hcGlcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9sb2dnZXJcIjtcbmltcG9ydCB7IENyeXB0b0V2ZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL2NyeXB0b1wiO1xuXG5pbXBvcnQgeyBNYXRyaXhDbGllbnRQZWcgfSBmcm9tICcuLi9NYXRyaXhDbGllbnRQZWcnO1xuaW1wb3J0IHsgQWNjZXNzQ2FuY2VsbGVkRXJyb3IsIGFjY2Vzc1NlY3JldFN0b3JhZ2UgfSBmcm9tICcuLi9TZWN1cml0eU1hbmFnZXInO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uL01vZGFsJztcbmltcG9ydCBJbnRlcmFjdGl2ZUF1dGhEaWFsb2cgZnJvbSAnLi4vY29tcG9uZW50cy92aWV3cy9kaWFsb2dzL0ludGVyYWN0aXZlQXV0aERpYWxvZyc7XG5pbXBvcnQgeyBfdCB9IGZyb20gJy4uL2xhbmd1YWdlSGFuZGxlcic7XG5cbmV4cG9ydCBlbnVtIFBoYXNlIHtcbiAgICBMb2FkaW5nID0gMCxcbiAgICBJbnRybyA9IDEsXG4gICAgQnVzeSA9IDIsXG4gICAgRG9uZSA9IDMsIC8vIGZpbmFsIGRvbmUgc3RhZ2UsIGJ1dCBzdGlsbCBzaG93aW5nIFVYXG4gICAgQ29uZmlybVNraXAgPSA0LFxuICAgIEZpbmlzaGVkID0gNSwgLy8gVVggY2FuIGJlIGNsb3NlZFxuICAgIENvbmZpcm1SZXNldCA9IDYsXG59XG5cbmV4cG9ydCBjbGFzcyBTZXR1cEVuY3J5cHRpb25TdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHJpdmF0ZSBzdGFydGVkOiBib29sZWFuO1xuICAgIHB1YmxpYyBwaGFzZTogUGhhc2U7XG4gICAgcHVibGljIHZlcmlmaWNhdGlvblJlcXVlc3Q6IFZlcmlmaWNhdGlvblJlcXVlc3Q7XG4gICAgcHVibGljIGJhY2t1cEluZm86IElLZXlCYWNrdXBJbmZvO1xuICAgIHB1YmxpYyBrZXlJZDogc3RyaW5nO1xuICAgIHB1YmxpYyBrZXlJbmZvOiBJU2VjcmV0U3RvcmFnZUtleUluZm87XG4gICAgcHVibGljIGhhc0RldmljZXNUb1ZlcmlmeUFnYWluc3Q6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgc3RhdGljIHNoYXJlZEluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIXdpbmRvdy5teFNldHVwRW5jcnlwdGlvblN0b3JlKSB3aW5kb3cubXhTZXR1cEVuY3J5cHRpb25TdG9yZSA9IG5ldyBTZXR1cEVuY3J5cHRpb25TdG9yZSgpO1xuICAgICAgICByZXR1cm4gd2luZG93Lm14U2V0dXBFbmNyeXB0aW9uU3RvcmU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkxvYWRpbmc7XG4gICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja3VwSW5mbyA9IG51bGw7XG5cbiAgICAgICAgLy8gSUQgb2YgdGhlIGtleSB0aGF0IHRoZSBzZWNyZXRzIHdlIHdhbnQgYXJlIGVuY3J5cHRlZCB3aXRoXG4gICAgICAgIHRoaXMua2V5SWQgPSBudWxsO1xuICAgICAgICAvLyBEZXNjcmlwdG9yIG9mIHRoZSBrZXkgdGhhdCB0aGUgc2VjcmV0cyB3ZSB3YW50IGFyZSBlbmNyeXB0ZWQgd2l0aFxuICAgICAgICB0aGlzLmtleUluZm8gPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IGNsaSA9IE1hdHJpeENsaWVudFBlZy5nZXQoKTtcbiAgICAgICAgY2xpLm9uKENyeXB0b0V2ZW50LlZlcmlmaWNhdGlvblJlcXVlc3QsIHRoaXMub25WZXJpZmljYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgY2xpLm9uKENyeXB0b0V2ZW50LlVzZXJUcnVzdFN0YXR1c0NoYW5nZWQsIHRoaXMub25Vc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkKTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0c0luUHJvZ3Jlc3MgPSBjbGkuZ2V0VmVyaWZpY2F0aW9uUmVxdWVzdHNUb0RldmljZUluUHJvZ3Jlc3MoY2xpLmdldFVzZXJJZCgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3RzSW5Qcm9ncmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSwgd2UgdGFrZSB0aGUgbW9zdCByZWNlbnQuIEVxdWFsbHkgaWYgdGhlIHVzZXIgc2VuZHMgYW5vdGhlciByZXF1ZXN0IGZyb21cbiAgICAgICAgICAgIC8vIGFub3RoZXIgZGV2aWNlIGFmdGVyIHRoaXMgc2NyZWVuIGhhcyBiZWVuIHNob3duLCB3ZSdsbCBzd2l0Y2ggdG8gdGhlIG5ldyBvbmUsIHNvIHRoaXNcbiAgICAgICAgICAgIC8vIGdlbmVyYWxseSBkb2Vzbid0IHN1cHBvcnQgbXVsdGlwbGUgcmVxdWVzdHMuXG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVZlcmlmaWNhdGlvblJlcXVlc3QocmVxdWVzdHNJblByb2dyZXNzW3JlcXVlc3RzSW5Qcm9ncmVzcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZldGNoS2V5SW5mbygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3Q/Lm9mZihWZXJpZmljYXRpb25SZXF1ZXN0RXZlbnQuQ2hhbmdlLCB0aGlzLm9uVmVyaWZpY2F0aW9uUmVxdWVzdENoYW5nZSk7XG4gICAgICAgIGlmIChNYXRyaXhDbGllbnRQZWcuZ2V0KCkpIHtcbiAgICAgICAgICAgIE1hdHJpeENsaWVudFBlZy5nZXQoKS5yZW1vdmVMaXN0ZW5lcihDcnlwdG9FdmVudC5WZXJpZmljYXRpb25SZXF1ZXN0LCB0aGlzLm9uVmVyaWZpY2F0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBNYXRyaXhDbGllbnRQZWcuZ2V0KCkucmVtb3ZlTGlzdGVuZXIoQ3J5cHRvRXZlbnQuVXNlclRydXN0U3RhdHVzQ2hhbmdlZCwgdGhpcy5vblVzZXJUcnVzdFN0YXR1c0NoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGZldGNoS2V5SW5mbygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHJldHVybjsgLy8gYmFpbCBpZiB3ZSB3ZXJlIHN0b3BwZWRcbiAgICAgICAgY29uc3QgY2xpID0gTWF0cml4Q2xpZW50UGVnLmdldCgpO1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgY2xpLmlzU2VjcmV0U3RvcmVkKCdtLmNyb3NzX3NpZ25pbmcubWFzdGVyJyk7XG4gICAgICAgIGlmIChrZXlzID09PSBudWxsIHx8IE9iamVjdC5rZXlzKGtleXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUluZm8gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlY3JldCBpcyBzdG9yZWQgdW5kZXIgbW9yZSB0aGFuIG9uZSBrZXksIHdlIGp1c3QgcGljayBhbiBhcmJpdHJhcnkgb25lXG4gICAgICAgICAgICB0aGlzLmtleUlkID0gT2JqZWN0LmtleXMoa2V5cylbMF07XG4gICAgICAgICAgICB0aGlzLmtleUluZm8gPSBrZXlzW3RoaXMua2V5SWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gd2UgaGF2ZSBhbnkgb3RoZXIgdmVyaWZpZWQgZGV2aWNlcyB3aGljaCBhcmUgRTJFRSB3aGljaCB3ZSBjYW4gdmVyaWZ5IGFnYWluc3Q/XG4gICAgICAgIGNvbnN0IGRlaHlkcmF0ZWREZXZpY2UgPSBhd2FpdCBjbGkuZ2V0RGVoeWRyYXRlZERldmljZSgpO1xuICAgICAgICBjb25zdCBvd25Vc2VySWQgPSBjbGkuZ2V0VXNlcklkKCk7XG4gICAgICAgIGNvbnN0IGNyb3NzU2lnbmluZ0luZm8gPSBjbGkuZ2V0U3RvcmVkQ3Jvc3NTaWduaW5nRm9yVXNlcihvd25Vc2VySWQpO1xuICAgICAgICB0aGlzLmhhc0RldmljZXNUb1ZlcmlmeUFnYWluc3QgPSBjbGkuZ2V0U3RvcmVkRGV2aWNlc0ZvclVzZXIob3duVXNlcklkKS5zb21lKFxuICAgICAgICAgICAgZGV2aWNlID0+XG4gICAgICAgICAgICAgICAgZGV2aWNlLmdldElkZW50aXR5S2V5KCkgJiZcbiAgICAgICAgICAgICAgICAoIWRlaHlkcmF0ZWREZXZpY2UgfHwgKGRldmljZS5kZXZpY2VJZCAhPSBkZWh5ZHJhdGVkRGV2aWNlLmRldmljZV9pZCkpICYmXG4gICAgICAgICAgICAgICAgY3Jvc3NTaWduaW5nSW5mby5jaGVja0RldmljZVRydXN0KFxuICAgICAgICAgICAgICAgICAgICBjcm9zc1NpZ25pbmdJbmZvLFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICkuaXNDcm9zc1NpZ25pbmdWZXJpZmllZCgpLFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5JbnRybztcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyB1c2VQYXNzUGhyYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnBoYXNlID0gUGhhc2UuQnVzeTtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgICAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrdXBJbmZvID0gYXdhaXQgY2xpLmdldEtleUJhY2t1cFZlcnNpb24oKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3VwSW5mbyA9IGJhY2t1cEluZm87XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgICAgICAvLyBUaGUgY29udHJvbCBmbG93IGlzIGZhaXJseSB0d2lzdGVkIGhlcmUuLi5cbiAgICAgICAgICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgY29tcGxldGluZyBzZWN1cml0eSwgd2Ugb25seSB3YWl0IG9uIGdldHRpbmdcbiAgICAgICAgICAgIC8vIGFzIGZhciBhcyB0aGUgdHJ1c3QgY2hlY2sgYW5kIHRoZW4gc2hvdyBhIGdyZWVuIHNoaWVsZC5cbiAgICAgICAgICAgIC8vIFdlIGFsc28gYmVnaW4gdGhlIGtleSBiYWNrdXAgcmVzdG9yZSBhcyB3ZWxsLCB3aGljaCB3ZSdyZVxuICAgICAgICAgICAgLy8gYXdhaXRpbmcgaW5zaWRlIGBhY2Nlc3NTZWNyZXRTdG9yYWdlYCBvbmx5IHNvIHRoYXQgaXQga2VlcHMgeW91clxuICAgICAgICAgICAgLy8gcGFzc3BoYXNlIGNhY2hlZCBmb3IgdGhhdCB3b3JrLiBUaGlzIGRpYWxvZyBpdHNlbGYgd2lsbCBvbmx5IHdhaXRcbiAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCB0cnVzdCBjaGVjaywgYW5kIHRoZSBrZXkgYmFja3VwIHJlc3RvcmUgd2lsbCBoYXBwZW5cbiAgICAgICAgICAgIC8vIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmU6ICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc1NlY3JldFN0b3JhZ2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGkuY2hlY2tPd25Dcm9zc1NpZ25pbmdUcnVzdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWNrdXBJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGNvbXBsZXRlIHJlc3RvcmUgY2FuIHRha2UgbWFueSBtaW51dGVzIGZvciBsYXJnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjb3VudHMgLyBzbG93IHNlcnZlcnMsIHNvIHdlIGFsbG93IHRoZSBkaWFsb2dcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGFkdmFuY2UgYmVmb3JlIHRoaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGkucmVzdG9yZUtleUJhY2t1cFdpdGhTZWNyZXRTdG9yYWdlKGJhY2t1cEluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2xpLmdldENyb3NzU2lnbmluZ0lkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBoYXNlID0gUGhhc2UuRG9uZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBBY2Nlc3NDYW5jZWxsZWRFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRocm93IGlmIHRoZSB1c2VyIGhpdHMgY2FuY2VsLCBzbyBpZ25vcmVcbiAgICAgICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5JbnRybztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25Vc2VyVHJ1c3RTdGF0dXNDaGFuZ2VkID0gKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh1c2VySWQgIT09IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRVc2VySWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlzVHJ1c3RlZCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRDcm9zc1NpZ25pbmdJZCgpO1xuICAgICAgICBpZiAocHVibGljS2V5c1RydXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5Eb25lO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBvblZlcmlmaWNhdGlvblJlcXVlc3QgPSAocmVxdWVzdDogVmVyaWZpY2F0aW9uUmVxdWVzdCk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZVZlcmlmaWNhdGlvblJlcXVlc3QocmVxdWVzdCk7XG4gICAgfTtcblxuICAgIHB1YmxpYyBvblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3QuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3Qub2ZmKFZlcmlmaWNhdGlvblJlcXVlc3RFdmVudC5DaGFuZ2UsIHRoaXMub25WZXJpZmljYXRpb25SZXF1ZXN0Q2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52ZXJpZmljYXRpb25SZXF1ZXN0LnBoYXNlID09PSBWRVJJRl9QSEFTRV9ET05FKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3Qub2ZmKFZlcmlmaWNhdGlvblJlcXVlc3RFdmVudC5DaGFuZ2UsIHRoaXMub25WZXJpZmljYXRpb25SZXF1ZXN0Q2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgdmVyaWZpY2F0aW9uIGhhcyBmaW5pc2hlZCwgd2UganVzdCBuZWVkIHRvIHdhaXQgZm9yXG4gICAgICAgICAgICAvLyBjcm9zcyBzaWduaW5nIHRvIGJlIHJlYWR5IHRvIHVzZSwgc28gd2FpdCBmb3IgdGhlIHVzZXIgdHJ1c3Qgc3RhdHVzIHRvXG4gICAgICAgICAgICAvLyBjaGFuZ2UgKG9yIGNoYW5nZSB0byBET05FIGlmIGl0J3MgYWxyZWFkeSByZWFkeSkuXG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlzVHJ1c3RlZCA9IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRDcm9zc1NpZ25pbmdJZCgpO1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9IHB1YmxpY0tleXNUcnVzdGVkID8gUGhhc2UuRG9uZSA6IFBoYXNlLkJ1c3k7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHVibGljIHNraXAoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5Db25maXJtU2tpcDtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBza2lwQ29uZmlybSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkZpbmlzaGVkO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIHJldHVybkFmdGVyU2tpcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBoYXNlID0gUGhhc2UuQ29uZmlybVJlc2V0O1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHJlc2V0Q29uZmlybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiBoZXJlLCB0aGUgdXNlciBwcmVzdW1hYmx5IGxvc3QgdGhlaXJcbiAgICAgICAgICAgIC8vIHNlY3JldCBzdG9yYWdlIGtleSBpZiB0aGV5IGhhZCBvbmUuIFN0YXJ0IGJ5IHJlc2V0dGluZ1xuICAgICAgICAgICAgLy8gc2VjcmV0IHN0b3JhZ2UgYW5kIHNldHRpbmcgdXAgYSBuZXcgcmVjb3Zlcnkga2V5LCB0aGVuXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGNyb3NzLXNpZ25pbmcga2V5cyBvbmNlIHRoYXQgc3VjY2VlZHMuXG4gICAgICAgICAgICBhd2FpdCBhY2Nlc3NTZWNyZXRTdG9yYWdlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGkgPSBNYXRyaXhDbGllbnRQZWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2xpLmJvb3RzdHJhcENyb3NzU2lnbmluZyh7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhVcGxvYWREZXZpY2VTaWduaW5nS2V5czogYXN5bmMgKG1ha2VSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbmlzaGVkIH0gPSBNb2RhbC5jcmVhdGVEaWFsb2coSW50ZXJhY3RpdmVBdXRoRGlhbG9nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF90KFwiU2V0dGluZyB1cCBrZXlzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeENsaWVudDogY2xpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbY29uZmlybWVkXSA9IGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcm9zcy1zaWduaW5nIGtleSB1cGxvYWQgYXV0aCBjYW5jZWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBOZXdDcm9zc1NpZ25pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkZpbmlzaGVkO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHJlc2V0dGluZyBjcm9zcy1zaWduaW5nXCIsIGUpO1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmV0dXJuQWZ0ZXJSZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5waGFzZSA9IFBoYXNlLkludHJvO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGRvbmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGhhc2UgPSBQaGFzZS5GaW5pc2hlZDtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIpO1xuICAgICAgICAvLyBhc3luYyAtIGFzayBvdGhlciBjbGllbnRzIGZvciBrZXlzLCBpZiBuZWNlc3NhcnlcbiAgICAgICAgTWF0cml4Q2xpZW50UGVnLmdldCgpLmNyeXB0by5jYW5jZWxBbmRSZXNlbmRBbGxPdXRnb2luZ0tleVJlcXVlc3RzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBzZXRBY3RpdmVWZXJpZmljYXRpb25SZXF1ZXN0KHJlcXVlc3Q6IFZlcmlmaWNhdGlvblJlcXVlc3QpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHJldHVybjsgLy8gYmFpbCBpZiB3ZSB3ZXJlIHN0b3BwZWRcbiAgICAgICAgaWYgKHJlcXVlc3Qub3RoZXJVc2VySWQgIT09IE1hdHJpeENsaWVudFBlZy5nZXQoKS5nZXRVc2VySWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnZlcmlmaWNhdGlvblJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdC5vZmYoVmVyaWZpY2F0aW9uUmVxdWVzdEV2ZW50LkNoYW5nZSwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyaWZpY2F0aW9uUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIGF3YWl0IHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIHJlcXVlc3Qub24oVmVyaWZpY2F0aW9uUmVxdWVzdEV2ZW50LkNoYW5nZSwgdGhpcy5vblZlcmlmaWNhdGlvblJlcXVlc3RDaGFuZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGxvc3RLZXlzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGV2aWNlc1RvVmVyaWZ5QWdhaW5zdCAmJiAhdGhpcy5rZXlJbmZvO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBT0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQW1CWUEsSzs7O1dBQUFBLEs7RUFBQUEs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