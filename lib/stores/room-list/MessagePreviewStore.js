"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessagePreviewStore = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("matrix-js-sdk/src/utils");

var _matrixEventsSdk = require("matrix-events-sdk");

var _AsyncStoreWithClient = require("../AsyncStoreWithClient");

var _dispatcher = _interopRequireDefault(require("../../dispatcher/dispatcher"));

var _MessageEventPreview = require("./previews/MessageEventPreview");

var _PollStartEventPreview = require("./previews/PollStartEventPreview");

var _LegacyCallInviteEventPreview = require("./previews/LegacyCallInviteEventPreview");

var _LegacyCallAnswerEventPreview = require("./previews/LegacyCallAnswerEventPreview");

var _LegacyCallHangupEvent = require("./previews/LegacyCallHangupEvent");

var _StickerEventPreview = require("./previews/StickerEventPreview");

var _ReactionEventPreview = require("./previews/ReactionEventPreview");

var _AsyncStore = require("../AsyncStore");

/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Emitted event for when a room's preview has changed. First argument will the room for which
// the change happened.
const ROOM_PREVIEW_CHANGED = "room_preview_changed";
const PREVIEWS = {
  'm.room.message': {
    isState: false,
    previewer: new _MessageEventPreview.MessageEventPreview()
  },
  'm.call.invite': {
    isState: false,
    previewer: new _LegacyCallInviteEventPreview.LegacyCallInviteEventPreview()
  },
  'm.call.answer': {
    isState: false,
    previewer: new _LegacyCallAnswerEventPreview.LegacyCallAnswerEventPreview()
  },
  'm.call.hangup': {
    isState: false,
    previewer: new _LegacyCallHangupEvent.LegacyCallHangupEvent()
  },
  'm.sticker': {
    isState: false,
    previewer: new _StickerEventPreview.StickerEventPreview()
  },
  'm.reaction': {
    isState: false,
    previewer: new _ReactionEventPreview.ReactionEventPreview()
  },
  [_matrixEventsSdk.M_POLL_START.name]: {
    isState: false,
    previewer: new _PollStartEventPreview.PollStartEventPreview()
  },
  [_matrixEventsSdk.M_POLL_START.altName]: {
    isState: false,
    previewer: new _PollStartEventPreview.PollStartEventPreview()
  }
}; // The maximum number of events we're willing to look back on to get a preview.

const MAX_EVENTS_BACKWARDS = 50; // type merging ftw

// eslint-disable-line @typescript-eslint/naming-convention
const TAG_ANY = "im.vector.any";

class MessagePreviewStore extends _AsyncStoreWithClient.AsyncStoreWithClient {
  // null indicates the preview is empty / irrelevant
  constructor() {
    super(_dispatcher.default, {});
    (0, _defineProperty2.default)(this, "previews", new Map());
  }

  static get instance() {
    return MessagePreviewStore.internalInstance;
  }

  static getPreviewChangedEventName(room) {
    return `${ROOM_PREVIEW_CHANGED}:${room?.roomId}`;
  }
  /**
   * Gets the pre-translated preview for a given room
   * @param room The room to get the preview for.
   * @param inTagId The tag ID in which the room resides
   * @returns The preview, or null if none present.
   */


  async getPreviewForRoom(room, inTagId) {
    if (!room) return null; // invalid room, just return nothing

    if (!this.previews.has(room.roomId)) await this.generatePreview(room, inTagId);
    const previews = this.previews.get(room.roomId);
    if (!previews) return null;

    if (!previews.has(inTagId)) {
      return previews.get(TAG_ANY);
    }

    return previews.get(inTagId);
  }

  generatePreviewForEvent(event) {
    const previewDef = PREVIEWS[event.getType()];
    return previewDef?.previewer.getTextFor(event, null, true) ?? "";
  }

  async generatePreview(room, tagId) {
    const events = room.timeline;
    if (!events) return; // should only happen in tests

    let map = this.previews.get(room.roomId);

    if (!map) {
      map = new Map();
      this.previews.set(room.roomId, map);
    } // Set the tags so we know what to generate


    if (!map.has(TAG_ANY)) map.set(TAG_ANY, null);
    if (tagId && !map.has(tagId)) map.set(tagId, null);
    let changed = false;

    for (let i = events.length - 1; i >= 0; i--) {
      if (i === events.length - MAX_EVENTS_BACKWARDS) {
        // limit reached - clear the preview by breaking out of the loop
        break;
      }

      const event = events[i];
      await this.matrixClient.decryptEventIfNeeded(event);
      const previewDef = PREVIEWS[event.getType()];
      if (!previewDef) continue;
      if (previewDef.isState && (0, _utils.isNullOrUndefined)(event.getStateKey())) continue;
      const anyPreview = previewDef.previewer.getTextFor(event, null);
      if (!anyPreview) continue; // not previewable for some reason

      changed = changed || anyPreview !== map.get(TAG_ANY);
      map.set(TAG_ANY, anyPreview);
      const tagsToGenerate = Array.from(map.keys()).filter(t => t !== TAG_ANY); // we did the any tag above

      for (const genTagId of tagsToGenerate) {
        const realTagId = genTagId === TAG_ANY ? null : genTagId;
        const preview = previewDef.previewer.getTextFor(event, realTagId);

        if (preview === anyPreview) {
          changed = changed || anyPreview !== map.get(genTagId);
          map.delete(genTagId);
        } else {
          changed = changed || preview !== map.get(genTagId);
          map.set(genTagId, preview);
        }
      }

      if (changed) {
        // We've muted the underlying Map, so just emit that we've changed.
        this.previews.set(room.roomId, map);
        this.emit(_AsyncStore.UPDATE_EVENT, this);
        this.emit(MessagePreviewStore.getPreviewChangedEventName(room), room);
      }

      return; // we're done
    } // At this point, we didn't generate a preview so clear it


    this.previews.set(room.roomId, new Map());
    this.emit(_AsyncStore.UPDATE_EVENT, this);
    this.emit(MessagePreviewStore.getPreviewChangedEventName(room), room);
  }

  async onAction(payload) {
    if (!this.matrixClient) return;

    if (payload.action === 'MatrixActions.Room.timeline' || payload.action === 'MatrixActions.Event.decrypted') {
      const event = payload.event; // TODO: Type out the dispatcher

      const isHistoricalEvent = payload.hasOwnProperty("isLiveEvent") && !payload.isLiveEvent;
      if (!this.previews.has(event.getRoomId()) || isHistoricalEvent) return; // not important

      await this.generatePreview(this.matrixClient.getRoom(event.getRoomId()), TAG_ANY);
    }
  }

}

exports.MessagePreviewStore = MessagePreviewStore;
(0, _defineProperty2.default)(MessagePreviewStore, "internalInstance", (() => {
  const instance = new MessagePreviewStore();
  instance.start();
  return instance;
})());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJST09NX1BSRVZJRVdfQ0hBTkdFRCIsIlBSRVZJRVdTIiwiaXNTdGF0ZSIsInByZXZpZXdlciIsIk1lc3NhZ2VFdmVudFByZXZpZXciLCJMZWdhY3lDYWxsSW52aXRlRXZlbnRQcmV2aWV3IiwiTGVnYWN5Q2FsbEFuc3dlckV2ZW50UHJldmlldyIsIkxlZ2FjeUNhbGxIYW5ndXBFdmVudCIsIlN0aWNrZXJFdmVudFByZXZpZXciLCJSZWFjdGlvbkV2ZW50UHJldmlldyIsIk1fUE9MTF9TVEFSVCIsIm5hbWUiLCJQb2xsU3RhcnRFdmVudFByZXZpZXciLCJhbHROYW1lIiwiTUFYX0VWRU5UU19CQUNLV0FSRFMiLCJUQUdfQU5ZIiwiTWVzc2FnZVByZXZpZXdTdG9yZSIsIkFzeW5jU3RvcmVXaXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJkZWZhdWx0RGlzcGF0Y2hlciIsIk1hcCIsImluc3RhbmNlIiwiaW50ZXJuYWxJbnN0YW5jZSIsImdldFByZXZpZXdDaGFuZ2VkRXZlbnROYW1lIiwicm9vbSIsInJvb21JZCIsImdldFByZXZpZXdGb3JSb29tIiwiaW5UYWdJZCIsInByZXZpZXdzIiwiaGFzIiwiZ2VuZXJhdGVQcmV2aWV3IiwiZ2V0IiwiZ2VuZXJhdGVQcmV2aWV3Rm9yRXZlbnQiLCJldmVudCIsInByZXZpZXdEZWYiLCJnZXRUeXBlIiwiZ2V0VGV4dEZvciIsInRhZ0lkIiwiZXZlbnRzIiwidGltZWxpbmUiLCJtYXAiLCJzZXQiLCJjaGFuZ2VkIiwiaSIsImxlbmd0aCIsIm1hdHJpeENsaWVudCIsImRlY3J5cHRFdmVudElmTmVlZGVkIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJnZXRTdGF0ZUtleSIsImFueVByZXZpZXciLCJ0YWdzVG9HZW5lcmF0ZSIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJmaWx0ZXIiLCJ0IiwiZ2VuVGFnSWQiLCJyZWFsVGFnSWQiLCJwcmV2aWV3IiwiZGVsZXRlIiwiZW1pdCIsIlVQREFURV9FVkVOVCIsIm9uQWN0aW9uIiwicGF5bG9hZCIsImFjdGlvbiIsImlzSGlzdG9yaWNhbEV2ZW50IiwiaGFzT3duUHJvcGVydHkiLCJpc0xpdmVFdmVudCIsImdldFJvb21JZCIsImdldFJvb20iLCJzdGFydCJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yZXMvcm9vbS1saXN0L01lc3NhZ2VQcmV2aWV3U3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgUm9vbSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbVwiO1xuaW1wb3J0IHsgaXNOdWxsT3JVbmRlZmluZWQgfSBmcm9tIFwibWF0cml4LWpzLXNkay9zcmMvdXRpbHNcIjtcbmltcG9ydCB7IE1hdHJpeEV2ZW50IH0gZnJvbSBcIm1hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9ldmVudFwiO1xuaW1wb3J0IHsgTV9QT0xMX1NUQVJUIH0gZnJvbSBcIm1hdHJpeC1ldmVudHMtc2RrXCI7XG5cbmltcG9ydCB7IEFjdGlvblBheWxvYWQgfSBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9wYXlsb2Fkc1wiO1xuaW1wb3J0IHsgQXN5bmNTdG9yZVdpdGhDbGllbnQgfSBmcm9tIFwiLi4vQXN5bmNTdG9yZVdpdGhDbGllbnRcIjtcbmltcG9ydCBkZWZhdWx0RGlzcGF0Y2hlciBmcm9tIFwiLi4vLi4vZGlzcGF0Y2hlci9kaXNwYXRjaGVyXCI7XG5pbXBvcnQgeyBNZXNzYWdlRXZlbnRQcmV2aWV3IH0gZnJvbSBcIi4vcHJldmlld3MvTWVzc2FnZUV2ZW50UHJldmlld1wiO1xuaW1wb3J0IHsgUG9sbFN0YXJ0RXZlbnRQcmV2aWV3IH0gZnJvbSBcIi4vcHJldmlld3MvUG9sbFN0YXJ0RXZlbnRQcmV2aWV3XCI7XG5pbXBvcnQgeyBUYWdJRCB9IGZyb20gXCIuL21vZGVsc1wiO1xuaW1wb3J0IHsgTGVnYWN5Q2FsbEludml0ZUV2ZW50UHJldmlldyB9IGZyb20gXCIuL3ByZXZpZXdzL0xlZ2FjeUNhbGxJbnZpdGVFdmVudFByZXZpZXdcIjtcbmltcG9ydCB7IExlZ2FjeUNhbGxBbnN3ZXJFdmVudFByZXZpZXcgfSBmcm9tIFwiLi9wcmV2aWV3cy9MZWdhY3lDYWxsQW5zd2VyRXZlbnRQcmV2aWV3XCI7XG5pbXBvcnQgeyBMZWdhY3lDYWxsSGFuZ3VwRXZlbnQgfSBmcm9tIFwiLi9wcmV2aWV3cy9MZWdhY3lDYWxsSGFuZ3VwRXZlbnRcIjtcbmltcG9ydCB7IFN0aWNrZXJFdmVudFByZXZpZXcgfSBmcm9tIFwiLi9wcmV2aWV3cy9TdGlja2VyRXZlbnRQcmV2aWV3XCI7XG5pbXBvcnQgeyBSZWFjdGlvbkV2ZW50UHJldmlldyB9IGZyb20gXCIuL3ByZXZpZXdzL1JlYWN0aW9uRXZlbnRQcmV2aWV3XCI7XG5pbXBvcnQgeyBVUERBVEVfRVZFTlQgfSBmcm9tIFwiLi4vQXN5bmNTdG9yZVwiO1xuaW1wb3J0IHsgSVByZXZpZXcgfSBmcm9tIFwiLi9wcmV2aWV3cy9JUHJldmlld1wiO1xuXG4vLyBFbWl0dGVkIGV2ZW50IGZvciB3aGVuIGEgcm9vbSdzIHByZXZpZXcgaGFzIGNoYW5nZWQuIEZpcnN0IGFyZ3VtZW50IHdpbGwgdGhlIHJvb20gZm9yIHdoaWNoXG4vLyB0aGUgY2hhbmdlIGhhcHBlbmVkLlxuY29uc3QgUk9PTV9QUkVWSUVXX0NIQU5HRUQgPSBcInJvb21fcHJldmlld19jaGFuZ2VkXCI7XG5cbmNvbnN0IFBSRVZJRVdTOiBSZWNvcmQ8c3RyaW5nLCB7XG4gICAgaXNTdGF0ZTogYm9vbGVhbjtcbiAgICBwcmV2aWV3ZXI6IElQcmV2aWV3O1xufT4gPSB7XG4gICAgJ20ucm9vbS5tZXNzYWdlJzoge1xuICAgICAgICBpc1N0YXRlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld2VyOiBuZXcgTWVzc2FnZUV2ZW50UHJldmlldygpLFxuICAgIH0sXG4gICAgJ20uY2FsbC5pbnZpdGUnOiB7XG4gICAgICAgIGlzU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3ZXI6IG5ldyBMZWdhY3lDYWxsSW52aXRlRXZlbnRQcmV2aWV3KCksXG4gICAgfSxcbiAgICAnbS5jYWxsLmFuc3dlcic6IHtcbiAgICAgICAgaXNTdGF0ZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdlcjogbmV3IExlZ2FjeUNhbGxBbnN3ZXJFdmVudFByZXZpZXcoKSxcbiAgICB9LFxuICAgICdtLmNhbGwuaGFuZ3VwJzoge1xuICAgICAgICBpc1N0YXRlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld2VyOiBuZXcgTGVnYWN5Q2FsbEhhbmd1cEV2ZW50KCksXG4gICAgfSxcbiAgICAnbS5zdGlja2VyJzoge1xuICAgICAgICBpc1N0YXRlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld2VyOiBuZXcgU3RpY2tlckV2ZW50UHJldmlldygpLFxuICAgIH0sXG4gICAgJ20ucmVhY3Rpb24nOiB7XG4gICAgICAgIGlzU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3ZXI6IG5ldyBSZWFjdGlvbkV2ZW50UHJldmlldygpLFxuICAgIH0sXG4gICAgW01fUE9MTF9TVEFSVC5uYW1lXToge1xuICAgICAgICBpc1N0YXRlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld2VyOiBuZXcgUG9sbFN0YXJ0RXZlbnRQcmV2aWV3KCksXG4gICAgfSxcbiAgICBbTV9QT0xMX1NUQVJULmFsdE5hbWVdOiB7XG4gICAgICAgIGlzU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3ZXI6IG5ldyBQb2xsU3RhcnRFdmVudFByZXZpZXcoKSxcbiAgICB9LFxufTtcblxuLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB3ZSdyZSB3aWxsaW5nIHRvIGxvb2sgYmFjayBvbiB0byBnZXQgYSBwcmV2aWV3LlxuY29uc3QgTUFYX0VWRU5UU19CQUNLV0FSRFMgPSA1MDtcblxuLy8gdHlwZSBtZXJnaW5nIGZ0d1xudHlwZSBUQUdfQU5ZID0gXCJpbS52ZWN0b3IuYW55XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5jb25zdCBUQUdfQU5ZOiBUQUdfQU5ZID0gXCJpbS52ZWN0b3IuYW55XCI7XG5cbmludGVyZmFjZSBJU3RhdGUge1xuICAgIC8vIEVtcHR5IGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZVxufVxuXG5leHBvcnQgY2xhc3MgTWVzc2FnZVByZXZpZXdTdG9yZSBleHRlbmRzIEFzeW5jU3RvcmVXaXRoQ2xpZW50PElTdGF0ZT4ge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGludGVybmFsSW5zdGFuY2UgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBNZXNzYWdlUHJldmlld1N0b3JlKCk7XG4gICAgICAgIGluc3RhbmNlLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9KSgpO1xuXG4gICAgLy8gbnVsbCBpbmRpY2F0ZXMgdGhlIHByZXZpZXcgaXMgZW1wdHkgLyBpcnJlbGV2YW50XG4gICAgcHJpdmF0ZSBwcmV2aWV3cyA9IG5ldyBNYXA8c3RyaW5nLCBNYXA8VGFnSUR8VEFHX0FOWSwgc3RyaW5nfG51bGw+PigpO1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZGVmYXVsdERpc3BhdGNoZXIsIHt9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldCBpbnN0YW5jZSgpOiBNZXNzYWdlUHJldmlld1N0b3JlIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VQcmV2aWV3U3RvcmUuaW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldFByZXZpZXdDaGFuZ2VkRXZlbnROYW1lKHJvb206IFJvb20pOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7Uk9PTV9QUkVWSUVXX0NIQU5HRUR9OiR7cm9vbT8ucm9vbUlkfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJlLXRyYW5zbGF0ZWQgcHJldmlldyBmb3IgYSBnaXZlbiByb29tXG4gICAgICogQHBhcmFtIHJvb20gVGhlIHJvb20gdG8gZ2V0IHRoZSBwcmV2aWV3IGZvci5cbiAgICAgKiBAcGFyYW0gaW5UYWdJZCBUaGUgdGFnIElEIGluIHdoaWNoIHRoZSByb29tIHJlc2lkZXNcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJldmlldywgb3IgbnVsbCBpZiBub25lIHByZXNlbnQuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFByZXZpZXdGb3JSb29tKHJvb206IFJvb20sIGluVGFnSWQ6IFRhZ0lEKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgaWYgKCFyb29tKSByZXR1cm4gbnVsbDsgLy8gaW52YWxpZCByb29tLCBqdXN0IHJldHVybiBub3RoaW5nXG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpZXdzLmhhcyhyb29tLnJvb21JZCkpIGF3YWl0IHRoaXMuZ2VuZXJhdGVQcmV2aWV3KHJvb20sIGluVGFnSWQpO1xuXG4gICAgICAgIGNvbnN0IHByZXZpZXdzID0gdGhpcy5wcmV2aWV3cy5nZXQocm9vbS5yb29tSWQpO1xuICAgICAgICBpZiAoIXByZXZpZXdzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAoIXByZXZpZXdzLmhhcyhpblRhZ0lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpZXdzLmdldChUQUdfQU5ZKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldmlld3MuZ2V0KGluVGFnSWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZW5lcmF0ZVByZXZpZXdGb3JFdmVudChldmVudDogTWF0cml4RXZlbnQpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBwcmV2aWV3RGVmID0gUFJFVklFV1NbZXZlbnQuZ2V0VHlwZSgpXTtcbiAgICAgICAgcmV0dXJuIHByZXZpZXdEZWY/LnByZXZpZXdlci5nZXRUZXh0Rm9yKGV2ZW50LCBudWxsLCB0cnVlKSA/PyBcIlwiO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVQcmV2aWV3KHJvb206IFJvb20sIHRhZ0lkPzogVGFnSUQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gcm9vbS50aW1lbGluZTtcbiAgICAgICAgaWYgKCFldmVudHMpIHJldHVybjsgLy8gc2hvdWxkIG9ubHkgaGFwcGVuIGluIHRlc3RzXG5cbiAgICAgICAgbGV0IG1hcCA9IHRoaXMucHJldmlld3MuZ2V0KHJvb20ucm9vbUlkKTtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IG5ldyBNYXA8VGFnSUQgfCBUQUdfQU5ZLCBzdHJpbmcgfCBudWxsPigpO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3cy5zZXQocm9vbS5yb29tSWQsIG1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIHRhZ3Mgc28gd2Uga25vdyB3aGF0IHRvIGdlbmVyYXRlXG4gICAgICAgIGlmICghbWFwLmhhcyhUQUdfQU5ZKSkgbWFwLnNldChUQUdfQU5ZLCBudWxsKTtcbiAgICAgICAgaWYgKHRhZ0lkICYmICFtYXAuaGFzKHRhZ0lkKSkgbWFwLnNldCh0YWdJZCwgbnVsbCk7XG5cbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGV2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IGV2ZW50cy5sZW5ndGggLSBNQVhfRVZFTlRTX0JBQ0tXQVJEUykge1xuICAgICAgICAgICAgICAgIC8vIGxpbWl0IHJlYWNoZWQgLSBjbGVhciB0aGUgcHJldmlldyBieSBicmVha2luZyBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubWF0cml4Q2xpZW50LmRlY3J5cHRFdmVudElmTmVlZGVkKGV2ZW50KTtcblxuICAgICAgICAgICAgY29uc3QgcHJldmlld0RlZiA9IFBSRVZJRVdTW2V2ZW50LmdldFR5cGUoKV07XG4gICAgICAgICAgICBpZiAoIXByZXZpZXdEZWYpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByZXZpZXdEZWYuaXNTdGF0ZSAmJiBpc051bGxPclVuZGVmaW5lZChldmVudC5nZXRTdGF0ZUtleSgpKSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IGFueVByZXZpZXcgPSBwcmV2aWV3RGVmLnByZXZpZXdlci5nZXRUZXh0Rm9yKGV2ZW50LCBudWxsKTtcbiAgICAgICAgICAgIGlmICghYW55UHJldmlldykgY29udGludWU7IC8vIG5vdCBwcmV2aWV3YWJsZSBmb3Igc29tZSByZWFzb25cblxuICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgYW55UHJldmlldyAhPT0gbWFwLmdldChUQUdfQU5ZKTtcbiAgICAgICAgICAgIG1hcC5zZXQoVEFHX0FOWSwgYW55UHJldmlldyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhZ3NUb0dlbmVyYXRlID0gQXJyYXkuZnJvbShtYXAua2V5cygpKS5maWx0ZXIodCA9PiB0ICE9PSBUQUdfQU5ZKTsgLy8gd2UgZGlkIHRoZSBhbnkgdGFnIGFib3ZlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdlblRhZ0lkIG9mIHRhZ3NUb0dlbmVyYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbFRhZ0lkOiBUYWdJRCA9IGdlblRhZ0lkID09PSBUQUdfQU5ZID8gbnVsbCA6IGdlblRhZ0lkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpZXcgPSBwcmV2aWV3RGVmLnByZXZpZXdlci5nZXRUZXh0Rm9yKGV2ZW50LCByZWFsVGFnSWQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3ID09PSBhbnlQcmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGFueVByZXZpZXcgIT09IG1hcC5nZXQoZ2VuVGFnSWQpO1xuICAgICAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGdlblRhZ0lkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwcmV2aWV3ICE9PSBtYXAuZ2V0KGdlblRhZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldChnZW5UYWdJZCwgcHJldmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIG11dGVkIHRoZSB1bmRlcmx5aW5nIE1hcCwgc28ganVzdCBlbWl0IHRoYXQgd2UndmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpZXdzLnNldChyb29tLnJvb21JZCwgbWFwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX0VWRU5ULCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoTWVzc2FnZVByZXZpZXdTdG9yZS5nZXRQcmV2aWV3Q2hhbmdlZEV2ZW50TmFtZShyb29tKSwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47IC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGRpZG4ndCBnZW5lcmF0ZSBhIHByZXZpZXcgc28gY2xlYXIgaXRcbiAgICAgICAgdGhpcy5wcmV2aWV3cy5zZXQocm9vbS5yb29tSWQsIG5ldyBNYXA8VGFnSUR8VEFHX0FOWSwgc3RyaW5nfG51bGw+KCkpO1xuICAgICAgICB0aGlzLmVtaXQoVVBEQVRFX0VWRU5ULCB0aGlzKTtcbiAgICAgICAgdGhpcy5lbWl0KE1lc3NhZ2VQcmV2aWV3U3RvcmUuZ2V0UHJldmlld0NoYW5nZWRFdmVudE5hbWUocm9vbSksIHJvb20pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBvbkFjdGlvbihwYXlsb2FkOiBBY3Rpb25QYXlsb2FkKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRyaXhDbGllbnQpIHJldHVybjtcblxuICAgICAgICBpZiAocGF5bG9hZC5hY3Rpb24gPT09ICdNYXRyaXhBY3Rpb25zLlJvb20udGltZWxpbmUnIHx8IHBheWxvYWQuYWN0aW9uID09PSAnTWF0cml4QWN0aW9ucy5FdmVudC5kZWNyeXB0ZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBheWxvYWQuZXZlbnQ7IC8vIFRPRE86IFR5cGUgb3V0IHRoZSBkaXNwYXRjaGVyXG4gICAgICAgICAgICBjb25zdCBpc0hpc3RvcmljYWxFdmVudCA9IHBheWxvYWQuaGFzT3duUHJvcGVydHkoXCJpc0xpdmVFdmVudFwiKSAmJiAhcGF5bG9hZC5pc0xpdmVFdmVudDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aWV3cy5oYXMoZXZlbnQuZ2V0Um9vbUlkKCkpIHx8IGlzSGlzdG9yaWNhbEV2ZW50KSByZXR1cm47IC8vIG5vdCBpbXBvcnRhbnRcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVQcmV2aWV3KHRoaXMubWF0cml4Q2xpZW50LmdldFJvb20oZXZlbnQuZ2V0Um9vbUlkKCkpLCBUQUdfQU5ZKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFpQkE7O0FBRUE7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQUNBO0FBQ0EsTUFBTUEsb0JBQW9CLEdBQUcsc0JBQTdCO0FBRUEsTUFBTUMsUUFHSixHQUFHO0VBQ0Qsa0JBQWtCO0lBQ2RDLE9BQU8sRUFBRSxLQURLO0lBRWRDLFNBQVMsRUFBRSxJQUFJQyx3Q0FBSjtFQUZHLENBRGpCO0VBS0QsaUJBQWlCO0lBQ2JGLE9BQU8sRUFBRSxLQURJO0lBRWJDLFNBQVMsRUFBRSxJQUFJRSwwREFBSjtFQUZFLENBTGhCO0VBU0QsaUJBQWlCO0lBQ2JILE9BQU8sRUFBRSxLQURJO0lBRWJDLFNBQVMsRUFBRSxJQUFJRywwREFBSjtFQUZFLENBVGhCO0VBYUQsaUJBQWlCO0lBQ2JKLE9BQU8sRUFBRSxLQURJO0lBRWJDLFNBQVMsRUFBRSxJQUFJSSw0Q0FBSjtFQUZFLENBYmhCO0VBaUJELGFBQWE7SUFDVEwsT0FBTyxFQUFFLEtBREE7SUFFVEMsU0FBUyxFQUFFLElBQUlLLHdDQUFKO0VBRkYsQ0FqQlo7RUFxQkQsY0FBYztJQUNWTixPQUFPLEVBQUUs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