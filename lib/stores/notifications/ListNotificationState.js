"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListNotificationState = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _NotificationColor = require("./NotificationColor");

var _arrays = require("../../utils/arrays");

var _NotificationState = require("./NotificationState");

/*
Copyright 2020 - 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class ListNotificationState extends _NotificationState.NotificationState {
  constructor() {
    let byTileCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let getRoomFn = arguments.length > 1 ? arguments[1] : undefined;
    super();
    this.byTileCount = byTileCount;
    this.getRoomFn = getRoomFn;
    (0, _defineProperty2.default)(this, "rooms", []);
    (0, _defineProperty2.default)(this, "states", {});
    (0, _defineProperty2.default)(this, "onRoomNotificationStateUpdate", () => {
      this.calculateTotalState();
    });
  }

  get symbol() {
    return this._color === _NotificationColor.NotificationColor.Unsent ? "!" : null;
  }

  setRooms(rooms) {
    // If we're only concerned about the tile count, don't bother setting up listeners.
    if (this.byTileCount) {
      this.rooms = rooms;
      this.calculateTotalState();
      return;
    }

    const oldRooms = this.rooms;
    const diff = (0, _arrays.arrayDiff)(oldRooms, rooms);
    this.rooms = rooms;

    for (const oldRoom of diff.removed) {
      const state = this.states[oldRoom.roomId];
      if (!state) continue; // We likely just didn't have a badge (race condition)

      delete this.states[oldRoom.roomId];
      state.off(_NotificationState.NotificationStateEvents.Update, this.onRoomNotificationStateUpdate);
    }

    for (const newRoom of diff.added) {
      const state = this.getRoomFn(newRoom);
      state.on(_NotificationState.NotificationStateEvents.Update, this.onRoomNotificationStateUpdate);
      this.states[newRoom.roomId] = state;
    }

    this.calculateTotalState();
  }

  getForRoom(room) {
    const state = this.states[room.roomId];
    if (!state) throw new Error("Unknown room for notification state");
    return state;
  }

  destroy() {
    super.destroy();

    for (const state of Object.values(this.states)) {
      state.off(_NotificationState.NotificationStateEvents.Update, this.onRoomNotificationStateUpdate);
    }

    this.states = {};
  }

  calculateTotalState() {
    const snapshot = this.snapshot();

    if (this.byTileCount) {
      this._color = _NotificationColor.NotificationColor.Red;
      this._count = this.rooms.length;
    } else {
      this._count = 0;
      this._color = _NotificationColor.NotificationColor.None;

      for (const state of Object.values(this.states)) {
        this._count += state.count;
        this._color = Math.max(this.color, state.color);
      }
    } // finally, publish an update if needed


    this.emitIfUpdated(snapshot);
  }

}

exports.ListNotificationState = ListNotificationState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJMaXN0Tm90aWZpY2F0aW9uU3RhdGUiLCJOb3RpZmljYXRpb25TdGF0ZSIsImNvbnN0cnVjdG9yIiwiYnlUaWxlQ291bnQiLCJnZXRSb29tRm4iLCJjYWxjdWxhdGVUb3RhbFN0YXRlIiwic3ltYm9sIiwiX2NvbG9yIiwiTm90aWZpY2F0aW9uQ29sb3IiLCJVbnNlbnQiLCJzZXRSb29tcyIsInJvb21zIiwib2xkUm9vbXMiLCJkaWZmIiwiYXJyYXlEaWZmIiwib2xkUm9vbSIsInJlbW92ZWQiLCJzdGF0ZSIsInN0YXRlcyIsInJvb21JZCIsIm9mZiIsIk5vdGlmaWNhdGlvblN0YXRlRXZlbnRzIiwiVXBkYXRlIiwib25Sb29tTm90aWZpY2F0aW9uU3RhdGVVcGRhdGUiLCJuZXdSb29tIiwiYWRkZWQiLCJvbiIsImdldEZvclJvb20iLCJyb29tIiwiRXJyb3IiLCJkZXN0cm95IiwiT2JqZWN0IiwidmFsdWVzIiwic25hcHNob3QiLCJSZWQiLCJfY291bnQiLCJsZW5ndGgiLCJOb25lIiwiY291bnQiLCJNYXRoIiwibWF4IiwiY29sb3IiLCJlbWl0SWZVcGRhdGVkIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0b3Jlcy9ub3RpZmljYXRpb25zL0xpc3ROb3RpZmljYXRpb25TdGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMjAgLSAyMDIyIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgUm9vbSB9IGZyb20gXCJtYXRyaXgtanMtc2RrL3NyYy9tb2RlbHMvcm9vbVwiO1xuXG5pbXBvcnQgeyBOb3RpZmljYXRpb25Db2xvciB9IGZyb20gXCIuL05vdGlmaWNhdGlvbkNvbG9yXCI7XG5pbXBvcnQgeyBhcnJheURpZmYgfSBmcm9tIFwiLi4vLi4vdXRpbHMvYXJyYXlzXCI7XG5pbXBvcnQgeyBSb29tTm90aWZpY2F0aW9uU3RhdGUgfSBmcm9tIFwiLi9Sb29tTm90aWZpY2F0aW9uU3RhdGVcIjtcbmltcG9ydCB7IE5vdGlmaWNhdGlvblN0YXRlLCBOb3RpZmljYXRpb25TdGF0ZUV2ZW50cyB9IGZyb20gXCIuL05vdGlmaWNhdGlvblN0YXRlXCI7XG5cbmV4cG9ydCB0eXBlIEZldGNoUm9vbUZuID0gKHJvb206IFJvb20pID0+IFJvb21Ob3RpZmljYXRpb25TdGF0ZTtcblxuZXhwb3J0IGNsYXNzIExpc3ROb3RpZmljYXRpb25TdGF0ZSBleHRlbmRzIE5vdGlmaWNhdGlvblN0YXRlIHtcbiAgICBwcml2YXRlIHJvb21zOiBSb29tW10gPSBbXTtcbiAgICBwcml2YXRlIHN0YXRlczogeyBbcm9vbUlkOiBzdHJpbmddOiBSb29tTm90aWZpY2F0aW9uU3RhdGUgfSA9IHt9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBieVRpbGVDb3VudCA9IGZhbHNlLCBwcml2YXRlIGdldFJvb21GbjogRmV0Y2hSb29tRm4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN5bWJvbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3IgPT09IE5vdGlmaWNhdGlvbkNvbG9yLlVuc2VudCA/IFwiIVwiIDogbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0Um9vbXMocm9vbXM6IFJvb21bXSkge1xuICAgICAgICAvLyBJZiB3ZSdyZSBvbmx5IGNvbmNlcm5lZCBhYm91dCB0aGUgdGlsZSBjb3VudCwgZG9uJ3QgYm90aGVyIHNldHRpbmcgdXAgbGlzdGVuZXJzLlxuICAgICAgICBpZiAodGhpcy5ieVRpbGVDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5yb29tcyA9IHJvb21zO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRSb29tcyA9IHRoaXMucm9vbXM7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBhcnJheURpZmYob2xkUm9vbXMsIHJvb21zKTtcbiAgICAgICAgdGhpcy5yb29tcyA9IHJvb21zO1xuICAgICAgICBmb3IgKGNvbnN0IG9sZFJvb20gb2YgZGlmZi5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVzW29sZFJvb20ucm9vbUlkXTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIGNvbnRpbnVlOyAvLyBXZSBsaWtlbHkganVzdCBkaWRuJ3QgaGF2ZSBhIGJhZGdlIChyYWNlIGNvbmRpdGlvbilcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0YXRlc1tvbGRSb29tLnJvb21JZF07XG4gICAgICAgICAgICBzdGF0ZS5vZmYoTm90aWZpY2F0aW9uU3RhdGVFdmVudHMuVXBkYXRlLCB0aGlzLm9uUm9vbU5vdGlmaWNhdGlvblN0YXRlVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5ld1Jvb20gb2YgZGlmZi5hZGRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFJvb21GbihuZXdSb29tKTtcbiAgICAgICAgICAgIHN0YXRlLm9uKE5vdGlmaWNhdGlvblN0YXRlRXZlbnRzLlVwZGF0ZSwgdGhpcy5vblJvb21Ob3RpZmljYXRpb25TdGF0ZVVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlc1tuZXdSb29tLnJvb21JZF0gPSBzdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxTdGF0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGb3JSb29tKHJvb206IFJvb20pIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlc1tyb29tLnJvb21JZF07XG4gICAgICAgIGlmICghc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm9vbSBmb3Igbm90aWZpY2F0aW9uIHN0YXRlXCIpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGVzKSkge1xuICAgICAgICAgICAgc3RhdGUub2ZmKE5vdGlmaWNhdGlvblN0YXRlRXZlbnRzLlVwZGF0ZSwgdGhpcy5vblJvb21Ob3RpZmljYXRpb25TdGF0ZVVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUm9vbU5vdGlmaWNhdGlvblN0YXRlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsU3RhdGUoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVUb3RhbFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuc25hcHNob3QoKTtcblxuICAgICAgICBpZiAodGhpcy5ieVRpbGVDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBOb3RpZmljYXRpb25Db2xvci5SZWQ7XG4gICAgICAgICAgICB0aGlzLl9jb3VudCA9IHRoaXMucm9vbXMubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBOb3RpZmljYXRpb25Db2xvci5Ob25lO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ICs9IHN0YXRlLmNvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gTWF0aC5tYXgodGhpcy5jb2xvciwgc3RhdGUuY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSwgcHVibGlzaCBhbiB1cGRhdGUgaWYgbmVlZGVkXG4gICAgICAgIHRoaXMuZW1pdElmVXBkYXRlZChzbmFwc2hvdCk7XG4gICAgfVxufVxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBa0JBOztBQUNBOztBQUVBOztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXTyxNQUFNQSxxQkFBTixTQUFvQ0Msb0NBQXBDLENBQXNEO0VBSXpEQyxXQUFXLEdBQThEO0lBQUEsSUFBckRDLFdBQXFELHVFQUF2QyxLQUF1QztJQUFBLElBQXhCQyxTQUF3QjtJQUNyRTtJQURxRSxLQUFyREQsV0FBcUQsR0FBckRBLFdBQXFEO0lBQUEsS0FBeEJDLFNBQXdCLEdBQXhCQSxTQUF3QjtJQUFBLDZDQUhqRCxFQUdpRDtJQUFB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